[{"title":"把《Flask Web开发》读薄系列之第七章 大型程序的结构","date":"2017-11-25T10:17:41.000Z","path":"2017/11/25/把《Flask Web开发》读薄系列之第七章 大型程序的结构/","text":"7.1 项目结构多文件Flask程序的结构：1234567891011121314151617181920|-flasky |-app/ |-init__.py |-templates/ # 模板 |-static/ # 静态文件 |-main/ # 蓝本，名字可更改 |-__init__.py |-errors.py # 路由，视图函数 |-forms.py # 表单 |-views.py # 路由器，视图函数 |-email.py # 邮件支持 |-models.py # 数据库模型 |-migrations # 数据库迁移 |-tests/ # 单元测试 |-__init__.py |-test*.py |-venv/ |-requirements.txt # 依赖包文本 |-config.py # 配置 |-manage.py # 启动程序 7.2 配置config.py在前面的章节中，我们在hello.py中是使用字典状结构配置的（如app.config[&#39;FLASKY_ADMIN&#39;] = 12345678@qq.com），现在我们把相关配置提取出来，在config.py中使用层次结构的配置类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546import osbasedir = os.path.abspath(os.path.dirname(__file__))# 设置通用配置class Config: SECRET_KEY = os.environ.get(&apos;SECRET_KEY&apos;) or &apos;hard to guess string&apos; SQLALCHEMY_COMMIT_ON_TEARDOWN = True FLASK_MAIL-SUBJECT_PREFECT = &apos;[Flasky]&apos; FLASKY_MAIL_SENDER = &apos;Flasky Admin 123456789@qq.com&apos; FLASK_ADMIN = os.environ.get(&apos;FLASKY_ADMIN&apos;) @staticmethod # init_app()可对当前环境的配置初始化，参数是程序实例 def init_app(app): pass # 开发环境配置（继承Config基类）class DevelopmentConfig(Config): DEBUG = True MAIL_SERVER = &apos;smtp.qq.com&apos; MAIL_PORT = 465 MAIL_USE_SSL = True MAIL_USENAME = os.environ.get(&apos;MAIL_USENAME&apos;) MAIL_PASSWORD = os.environ.get(&apos;MAIL_PASSWORD&apos;) SQLALCHEMY_DATABASE_URI = os.environ,get(&apos;DEV_DATABASE_URI&apos;) or \\&apos;sqlite:///&apos; + os.path.join(basedir, &apos;data-dev.sqlite&apos;) # 测试环境配置（继承Config基类） class TestingConfig(Config): TESTING = True SQLALCHEMY_DATABASE_URI = os.environ,get(&apos;TEST_DATABASE_URI&apos;) or \\&apos;sqlite:///&apos; + os.path.join(basedir, &apos;data-test.sqlite&apos;) # 生产环境配置（继承Config基类） class ProductionConfig(Config): SQLALCHEMY_DATABASE_URI = os.environ,get(&apos;DATABASE_URI&apos;) or \\&apos;sqlite:///&apos; + os.path.join(basedir, &apos;data.sqlite&apos;) # 配置字典config = &#123; &apos;development&apos;: DevelopmentConfig, &apos;testing&apos;: TestingConfig, &apos;production&apos;: ProductionConfig, &apos;default&apos;: DevelopmentConfig &#125; 7.3 程序包（app文件夹）程序包用来保存程序的所有代码、模板和静态文件。 7.3.1 使用程序工厂函数存在问题：在单脚本中开发程序的缺点是：脚步在运行时，程序实例已经创建，已经不能修改配置，自然也无法动态修改配置。这样也不利于单元测试。 解决思路：延迟创建程序实例。解决方法：把创建过程移到可显式调用的工厂函数中。这样不仅可以给脚步流出配置程序时间，还能创建多个程序实例。 程序的工厂函数在app包的构造文件（__init__.py）中定义。app/__inti__.py如下：12345678910111213141516171819202122232425262728from flask import Flaskfrom flask_bootstrap import Bootstrapfrom flask_mail import Mailfrom flask_moment import Momentfrom flask_sqlalchemy import SQLAlchemyfrom config import configbootstrap = Bootstrap()mail = Mail()moment = Moment()db = SQLAlchemy()# 定义工厂函数，参数为程序使用的配置环境名def create_app(config_name): app = Flask(__name__) # 根据配置环境名获取对应的配置类从而获取相应的配置（类变量） app.config.from_object(config[&apos;config_name&apos;] # 使用配置类中的init_app()方法初始化配置 config[&apos;config_name&apos;].init_app(app) bootstrap.init_app(app) mail.init_app(app) moment.init_app(app) db.init_app(app) # 附加路由和自定义的错误页面 return app config.py文件中定义的配置类，可以使用app.config配置对象提供的from_object()方法直接导入程序。程序创建（app=Flask(__name__))并配置好后，就能初始化Flask拓展（在Flask拓展实例对象上调用init_app()方法，如bootstrap.init(app)） 工厂函数返回的是程序实例，不过此时工厂函数创建的程序实例还不完整，因为还没有路由和自定义的错误页面处理程序（简单来说就是缺少路由）。 7.3.2 在蓝本中实现程序功能存在问题：在单脚本程序中，程序实例存在于全局作用域中，路由可以直接使用app.route修饰器定义，但是现在程序实例时在运行时创建的（调用create_app()函数），这时定义路由已经太晚了（因为只有调用create_app()函数创建实例后才能使用app.route修饰器，而路由又要定义在create_app()函数里） 解决方法：使用蓝本。蓝本和程序类似，也可以定义路由，但不同的是：在蓝本中定义的路由会处于休眠状态，直到调用app.register_blueprint()方法把蓝本注册到程序后，路由在真正称为程序的一部分。 理解蓝本：蓝本通常作用于相同的URL前缀，如user/id、user/profile这样的地址，都是以/user开头，它们是一组用户相关的操作，那么就可以放在一个模块中。大多数项目都是把蓝本当做拆分视图用的。 使用位于全局作用域中的蓝本时，定义路由方法和单脚本程序基本一样（不同之处下面会讲到） 创建蓝本app/main/__init__.py:123456from flask import Blueprintmain = Blueprint(&apos;main&apos;, __name__)# 导入view和error模块，导入之后就能将路由和错误处理程序与蓝本关联起来from . import views, errors Blueprint()类的第一个参数是蓝本名字，第二个参数是篮本所在的包或模块（一般使用__name__即可）。 注意： 像view和error这些模块，为了避免循环导入，要在app/main/__init.py__的末尾处导入，因为在view.py和error.py中还要导入蓝本main。 app/main/error.py如下： 12345678910from flask import render_templatefrom . import main@main.app_errorhandler(404)def page_not_found(e): return render_template(&apos;404.html&apos;), 404 @main.app_errorhandler(500)def internal_server_error(e): return render_template(&apos;500.html&apos;), 500 注意：在蓝本中编写错误处理程序稍有不同，如果是使用errorhandler修饰器，那么只有蓝本中的错误才能触发处理程序。因此要想注册程序全局的错误处理程序，必须使用app_errorhandler修饰器。 app/main/view.py如下： 12345678910111213141516from datetime import datetimefrom flask import render_template, session, redirect, url_for, current_appfrom . import mainfrom .froms import NameFormfrom .. import dbfrom ..models import User@main.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def index(): form = NmaeForm() if form.validate_on_submit(): # ... return redirect(url_for(&apos;.index&apos;) return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;), know=session.get(&apos;know&apos;, Flase), current_time=datetime.utcnow()) 注意：在蓝本中编写视图函数主要有两点不同：（1）和前面的错误处理程序一样，路由修饰器由蓝本提供（体现在main.route()，而不是app.route()）。（2）url_for()函数的第一个参数。url_for()函数的第一个参数时路由的端点名，在程序中默认为视图函数的名字（所以在单脚本中可以url_for(&#39;index&#39;)），但是在蓝本中，Flask会为蓝本中的全部端点加上一个命名空间（也就是蓝本的名字），这样做是为了可以在不同的蓝本中使用相同的端点名（函数名）定义视图函数。所以该蓝本中视图函数index()注册的端点名是main.index，因此需要使用url_for(&#39;main.index&#39;)，也可以简写为url_for(&#39;.index&#39;)（前提是同一蓝本，跨蓝本的话必须使用带有命名空间的端点名）。 另外：模板中的hrfe属性中的链接，使用url_for()获取的，其中参数也是同样写端点名。 重点注意：如果在其他地方（如这里的app/main/view.py、app/email.py等）需要用到程序实例app，均需使用from flask import current_app来导入程序上下文。 2.在工厂函数create_app()中把蓝本注册到程序上，app/__init__.py如下： 12345678910# ...def create_app(config_name): # ... # 导入整个包 from .main import main as main_blueprint app.register_blueprint(main_blueprint) return app 7.4 启动脚本manage.py用于启动脚本：1234567891011121314151617181920#!/usr/bin/env pythonimport osfrom app import create_app, dbfrom app.models import User, Rolefrom flask_script import Manager, Shellfrom flask_migrate import Migrate, MigrateCommand# 获取配置名，并创建程序app = create_app(os.getenv(&apos;FLASK_CONFIG&apos;) or &apos;default&apos;)manager = Manager(app)migrate = Migrate(app, db)def make_shell_context(): return dict(app=app, db=db, User=User, Role=Role)manager.add_command(&apos;shell&apos;, Shell(make_context=make_shell_context))manager.add_command(&apos;db&apos;, MigrateCommand)if __name__ == &apos;__main__&apos;: manager.run() 在脚本中加入了#!/usr/bin/env python声明，因此在Unix系统中可以直接通过./manage.py命令运行脚步，而无需使用python manage.py命令。 7.5 需求文件requirements.txt文件：用于记录所有依赖包及其精确的版本号。可以使用如下命令自动生成这个文件：(venv) $ pip freeze &gt; requirements.txt 当要创建同一个环境时，可以使用如下命令：(venv) $ pip install -r requirements.txt 7.6 单元测试 tests/test_basics.py文件如下： 12345678910111213141516171819202122232425import unittestfrom flask import current_appfrom app import create_app, dbclass BasicsTestCase(unittest.TestCase): # 创建一个测试环境，并激活程序上下文，并创建数据库 def setUp(self): self.app = create_app(&apos;testing&apos;) self.app_context = self.app.app_context() self.app_context.push() db.create_all() # 删除数据库、程序上下文 def tearDown(self): db.session.remove() db.drop_all() self.app_context.pop() # 测试程序实例是否存在 def test_app_exists(self): self.assertFalse(current_app is None) # 测试程序的环境是否为TESTING def test_app_is_testing(self): self.assertTrue(current_app.config[&apos;TESTING&apos;]) setUp()和tearDown()方法分别在各测试前后运行。函数名字以test_开头的函数都作为测试执行。 运行单元测试。可在manage.py文件中添加一个自定义命令，用于执行测试： 123456789# ...@manager.commanddef test(): # 字符串内容会显示在帮助消息中 &quot;&quot;&quot;Run the unit tests&quot;&quot;&quot; import unittest tests = unittest.TestLoader().discover(&apos;tests&apos;) unittest.TextRunner(verbosity=2).run(tests) manager.command修饰器修饰的函数名就是命令名。因此可以使用如下命令运行测试： 12345678(venv) $ python manage.py testtest_app_exits (test_basics.BasicsTestCase) ... oktest_app_is_testing (test_basics.BasicsTestCase) ... ok--------------------------------------------------------Ran 2 tests in 0.001sOK 7.7 创建数据库首先需要在环境变量中定义所需要的数据库URI，然后再创建数据库。 不管从哪里获取数据库URI，都要在新数据库中创建数据表，如果使用Flask-Migrate跟踪迁移，可以使用如下命令创建数据表或者更新到最新版本：(venv) $ python manage.py db upgrade","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第六章 电子邮件","date":"2017-11-14T12:57:23.000Z","path":"2017/11/14/把《Flask Web开发》读薄系列之第六章 电子邮件/","text":"使用Flask-Mail提供电子邮件支持表6-1 Flask-Mail SMTP服务器的配置 配置 默认值 说明 MAIL_SERVER localhost 邮件服务器主机名或IP地址 MAIL_PORT 25 电子邮件服务器的端口 MAIL_USE_TLS False 启用传输层安全（TLS）协议 MAIL_USE_SSL False 启用安全套接层（SSL）协议 MAIL_USENAME None 邮件账户的用户名 MAIL_PASSWORD None 邮件账户的授权码 在hello.py中配置Flask-Mail使用QQ邮箱： 12345678import os# ...app.config[&apos;MAIL_SERVER&apos;] = &apos;smtp.qq.com&apos;app.config[&apos;MAIL_PORT&apos;] = 465app.config[&apos;MAIL_USE_SSL&apos;] = Trueapp.config[&apos;MAIL_USERNAME&apos;] = os.environ.get(&apos;MAIL_USERNAME&apos;)app.config[&apos;MAIL_PASSWORD&apos;] = os.environ.get(&apos;MAIL_PASSWORD&apos;) 注意：千万不要把账号密令直接写在脚本中，应该从环境变量中导入。 初始化Flask-Mail： 1234from flask_mail import Mail# ...mail = Mail(app) 在环境变量中定义MAIL_USERNAME和MAIL_PASSWORD： 12(venv) $ export MAIL_USERNAME=&apos;12345678@qq.com&apos;(venv) $ export MAIL_PASSWORD=&apos;qwertyuiop&apos; 此时可以使用echo命令打印出来检查一下：1234(venv) $ echo $MAIL_USERNAME&gt;&gt;&gt; &apos;12345678@qq.com&apos;(venv) $ echo $MAIL_PASSWORD&gt;&gt;&gt; &apos;qwertyuiop&apos; 定义环境变量后，此时在同一个终端中执行python hello.py shell命令，便能获取到想要的环境变量。 注意：如果定义好环境变量后把终端关闭再重新打开，那么此时是没有上次定义的环境变量的。所以需要在同一个终端中执行。 如何让QQ邮箱开启SMTP功能，可以参考flask-mail常见的邮箱配置问题解决 在Python shell中发送电子邮件在上一个终端中，发送电子邮件：12345678(venv) $ python hello.py shell&gt;&gt;&gt; from flask_mail import Message&gt;&gt;&gt; from hello import mail&gt;&gt;&gt; msg = Message(&apos;test subject&apos;, sender=&apos;12345678@qq.com&apos;, recipients=[&apos;87654321@qq.com&apos;])&gt;&gt;&gt; msg.body = &apos;test body&apos;&gt;&gt;&gt; msg.html = &apos;&lt;p&gt;test body&lt;/p&gt;&apos;&gt;&gt;&gt; with app.app_context():··· mail.send(msg) 注意：在Flask-Mail中的send()函数使用current_app（程序上下文），因此在shell中发送邮件，需要激活程序上下文。 在程序中集成发送电子邮件功能 定义用于发邮件的函数，使hello.py支持电子邮件： 12345678910111213from flask_mail import Message# ...# 给邮件标题添加一个前缀app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] = &apos;[Flasky]&apos;# 定义发件人app.config[&apos;FLASKY_MAIL_SENDER&apos;] = &apos;12345678@qq.com&apos;def send_email(recipients, subject, template, **kwargs): msg = Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] + subject, sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;], recipients=[recilients]) msg.body = render_template(template + &apos;.txt&apos;, **kwargs) msg.html = render_template(template + &apos;.html&apos;, **kwargs) mail.send(msg) 邮件有纯文本.txt，也有HTML文本.html，客户端显示哪个，取决于邮件客户端的设置。 拓展：为什么send()函数中需要**kwargs？**kwargs的作用是什么？答：（1）因为我们不确定模板中需要什么变量参数，在此例中，模板需要的时user这个参数，但是如果换成别的模版，它不仅需要user参数，也需要其他一些参数（如datatime等，关键取决于模板设计成什么样），此时如果我们死死地把send_email()函数写成send_email(recipient, subject, template, user)，那么就失去了灵活性，当换成其他模版时，datatime参数也就无法传入了，因此send()函数需要**kwargs。（2）**kwargs的作用是：当我们不知道需要往函数中传入多少个关键字参数或者想以字典的形式作为参数时，我们可以用**kwargs，这样我们就可以根据实际情况需要，往函数中传入特定个数的参数（数量使具体情况而定）。 结合视图函数发送电子邮件： 1234567891011121314151617181920212223242526# ...# 定义收件人为Flasky的管理员app.config[&apos;FLASKY_ADMIN&apos;] = os.environ.get(&apos;FLASKY_ADMIN&apos;)# ...@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]def index(): form = NameForm() if form.validate_on_submit(): session[&apos;name&apos;] = form.name.data # 查找数据库中是否有该用户名，如果没有，就向数据库中添加新用户， # 因为前面已经设置了SQLALCHEMY_COMMIT_ON_TEARDOWN，所以当请求结束时会自动提交事务 user = User.query.filter_by(user_name=form.name.data).first() if user is None: # 插入数据库 user = User(user_name=form.name.data) db.session.add(user) # 用于模板中判断是显示Pleased to meet you 还是 Happy to see you again session[&apos;known&apos;] = Flase # 如果收件人不为空，则发送邮件 if app.config[&apos;FLASKY_ADMIN&apos;]: send_email(app.config[&apos;FLASKY_ADMIN&apos;], &apos;New User&apos;, &apos;mail/new_user&apos;, user=user) else: session[&apos;konwn&apos;] = True return redirect(url_for(&apos;index&apos;) return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;), known=session.get(&apos;known&apos;, Flase)) 此时我们也需要定义环境变量FLASKY_ADMIN：(venv) $ export FLASKY_ADMIN=&#39;12345678@qq.com&#39; template文件夹下的模板文件mail/new_user有两个，分别为new_user.txt和new_user.html。 new_user.txt如下：1There has a new user that name is &#123;&#123; user.user_name &#125;&#125; new_user.html如下：1&lt;h1&gt;There has a new user that name is &#123;&#123; user.user_name &#125;&#125;&lt;/h1&gt; 异步发送电子邮件为了避免处理请求过程中不必要的延迟，我们可以把发送电子邮件的函数移到后台线程中处理：1234567891011121314from threading import Thread# ...def send_async_email(app, msg): with app.app_context(): mail.send(msg) def send_email(recipients, subject, template, **kwargs): msg = Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] + subject, sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;], recipients=[recilients]) msg.body = render_template(template + &apos;.txt&apos;, **kwargs) msg.html = render_template(template + &apos;.html&apos;, **kwargs) thr = Thread(target=send_async_email, args=[app, msg]) thr.start() return thr 注意：由于在不同线程中执行mail.send()函数，就如前面在Python shell中发送电子邮件章节中提到，send()函数需要程序current_app（程序上下文）中执行，因此需要在执行send()函数的线程中使用app.app_context()人工创建current_app。 当需要发送大量电子邮件时，使用专门发送电子邮件的作业（如Celery任务队列）处理更合适。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第五章 数据库","date":"2017-11-14T12:56:25.000Z","path":"2017/11/14/把《Flask Web开发》读薄系列之第五章 数据库/","text":"5.1 SQL数据库表中有个特殊的列，称为主键，其值是表中各行的唯一标识符，表中还可以有称为外键的列，引用同一个表或不同表中某行的主键，行之间的这种联系称为关系，这是SQL数据库的基础。 5.2 NoSQL数据库所有不遵循上节所述关系模型的数据库统称为NoSQL数据库。NoSQL数据库一般使用集合Collection代替表，使用文档Document代替记录（行）。 NoSQL数据库可以减少表的数量，但却增加了数据重复量，但数据重复又可以提高查询速度。 5.3 使用SQL还是NoSQL视实际情况所需。 5.4 Python数据库框架数据库包：MySQL、Postgres、SQLite、Redis、MongoDB、CouchDB数据库抽象层代码包（ORM或ODM）：SQLAlchemy、MongoEngine 一般情况下，ORM和ODM对生产率的提升远远超过“把对象业务转换成数据库业务”而带来的性能降低。 5.5 使用Flask-SQLAlchemy管理数据库在Flask-SQLAlchemy中，使用哪种数据库，要通过URL指定。常用的数据库引擎采用的数据库URL格式如下： 表5-1 Flask-SQLAlchemy数据库URL 数据库引擎 URL MySQL mysql://username:password@hostname/database Postgres postgres://username:password@hostname/database SQLite(Unix) sqlite:////absolute/path/to/database SQLite(Windows) sqlite:///c:/absolute/path/to/database hostname可以是本地主机（localhost)，也可以是原创服务器。database表示要使用的数据库名称。 程序使用的数据库URL必须保存到Flask配置对象的SQLALCHEMY_DATABASE_URI键中。配置对象中有个SQLALCHEMY_COMMIT_ON_TEARDOWN键，将其设为True时，每次请求结束后都会自动提交数据库中的变动（相当于自动commit）。 初始化及配置SQLite如下：123456789101112form flask_sqlalchemy import SQLAlchemyimport os# ...# 获取文件当前文件父路径basedir = os.path.abspath(os.path.dirname(__file__))app = Flask(__name__)app.config[&apos;SQLALCHEMY_DATABASE_URI`] = &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data.sqlite&apos;)app.config[`SQLALCHEMY_COMMIT_ON_TEARDOWN`] = Truedb = SQLAlchemy(app) db对象是SQLAlchemy类的实例，表示程序所使用的数据库。 5.6 定义模型在ORM中，模型（相当于数据库表table）一般是个Python类，类中的属性对应数据库表中的列。 在hello.py中定义Role模型和User模型：123456789101112131415class Role(db.Model): __tablename__ &apos;roles&apos; id = db.Column(db.Integer, primary_key=True) role_name = db.Column(db.String(64), unique=True) def __repr__(self): return &apos;&lt;Role &#123;&#125;&gt;&apos;.format(self.role_name) def User(db.Model): __tablename__ = &apos;users&apos; id = db.Column(db.integer, primary_key=True) user_name = db.Column(db.String(64), unique=True, index=True) def __repr__(self): return &apos;&lt;User &#123;&#125;&gt;&apos;.format(self.user_name) 类变量__tablename__定义在数据库中使用的表名，如果没有定义，Flask-SQLAlchemy会使用一个默认名字，但该名字没有遵守使用复数形式进行命名的约定。 db.Column类构造函数的第一个参数是数据库列的类型（如Integer、String等），对应模型（即Python类）的对象类型（如int、str等） 表5-2 最常用的SQLAlchemy列类型 类型名称 对应Python类型 说明 Integer int 普通整数，一般时32位 Float int 浮点数 String str 变长字符串 Text str 变成字符串，对较长或不限长度的字符串做了优化 Unicode unicode 变长Unicode字符串 UnicodeText unicode 变长Unicode字符串，对较长货不限长度的字符串做了优化 Date datetime.data 日期 Time datetime.time 时间 DateTime datetime.datetime 日期和时间 db.Column中其余的参数可对列中的数据做一些配置或设置 表5-3 最常用的SQLAlchemy列选项 选项名 说明 primary_key 如果设为True，这列是主键 unique 如果设为True，这列不允许出现重复值 index 如果设为True，为这列创建索引，提高查询效率 nullable 如果设为True，这列允许使用空值；设为False，则不允许为空 default 为这列设置默认值 注意：Flask-SQLAlchemy要求每个模型都要定义主键。 5.7 关系定义一对多关系（Role对User）：1234567class Role(db.Model): # ... users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;) class User(db.Model): # .... role_id = db.Column(db.Integer, db.ForeignKey(&apos;roles.id&apos;) # 外键：roles表中的id 添加到Role模型中的类变量users代表这个关系（Role与User的关系）的面向对象视角，它将返回与具体Role实例相关联的用户（具体User实例）组成的列表。（如Role实例role_admin返回的users为[richard, john]，其中richard和john都是User实例，即role_admin.users = [richard,john]体现了面向对象视角的一对多关系） db.relationship()的第一个参数是这个关系的另一端对应的模型。如果模型尚未定义，可使用字符串形式指定。backref参数为&#39;role&#39;表明：在User模型中添加一个属性（或称为类变量）role（可理解成在User表中添加一列名为role的列。但实际查看数据库表时是看不到的），从而定义反向关系。注意：一般情况下，db.relationship()都能自行找到关系中的外键，有在某些情况下无法决定把哪一列作为外键。如User模型中有两列或以上的列定义为Role模型的外键，那么SQLAlchemy就不知道该使用哪列了。此时，你就要为db.relationship()提供额外参数，从而确定使用哪列外键。常用配置如表5-4。 表5-4 db.relationship()常用的SQLAlchemy关系选项 选项名 说明 backref 在关系的另一端模型中添加反向作用 primaryjoin 明确指定两个模型之间使用的联结条件。只在模凌两可的关系中需要指定 lazy 指定如何加载相关记录。可选值有：select（首次访问时按需加载），immediate（源对象加载后加载），joined（加载记录，但使用联结），subquery（立即加载，但使用子查询），noload（永不加载），dynamic（不加载记录，单提供加载记录的查询） userlist 如果设为Fales，不适用列表，而使用标量值 order_by 指定关系中记录的排序方式 secondary 指定多对多关系中关系表的名字 secondaryjoin SQLAlchemy无法自行决定时，指定多对多关系中的二级联结条件 一对一关系：可以用前面介绍的一对多关系表示，但调用db.relationship()时要把userlist设为False。多对一关系：可以用一对多关系表示，只是两个表对调。或者把外键和db.relationship()都放在“多”这一侧。多对多关系：需要用到第三张表（关系表）。 5.8 数据库操作需要在Python Shell中进行操作。 5.8.1 创建表123(venv)$ python hello.py shell&gt;&gt;&gt; from hello.py import db&gt;&gt;&gt; db.create_all() 如果修改模型（如增加了一列）后要把修改的地方应用到现在的数据库中，那么更新现有数据库表的粗暴方式是先删除旧表，在重新创建表：12&gt;&gt;&gt; db.drop_all()&gt;&gt;&gt; db.create_all() 但是这种方法会把数据库中原有的数据都删除掉。在5.11 使用Flask-Migrate实现数据库迁移中会介绍更新数据库更好的方式。 5.8.2 插入行1234567&gt;&gt;&gt; from hello import Role, User&gt;&gt;&gt; role_admin = Role(role_name=&apos;admin&apos;)&gt;&gt;&gt; role_moderator = Role(role_name=&apos;moderator&apos;)&gt;&gt;&gt; role_visitor = Role(role_name=&apos;visitor&apos;)&gt;&gt;&gt; user_richard = User(user_name=&apos;richard&apos;)&gt;&gt;&gt; user_john = User(user_name=&apos;john&apos;)&gt;&gt;&gt; user_david = User(user_name=&apos;david&apos;) 现在这些对象只存在于Python中，还没有写入数据库。因此id尚未赋值，所以print(role_admin.id)的结果为None。 要把对象写入数据库要分两步： 要把对象添加到会话(db.session)中:12&gt;&gt;&gt; db.session.add(role_admin)&gt;&gt;&gt; db.session.add(user_richard) 或者简写成：1&gt;&gt;&gt; db.session.add_all([role_moderator, role_visitor, user_john, user_david]) 调用commit()提交会话1&gt;&gt;&gt; db.session.commit() 此时对象已经写入数据库，再print(role_admin.id)时，它的结果时1。 调用db.session.rollback()后，可实现事务回滚。添加到数据库会话中的所有对象都会还原为它们在数据库时的状态。 注意：如果在写入会话过程中发生了错误，那么整个会话都会实效。这样就保证了数据库的一致性。因为可以防止只更新正确部分，而发生错误的部分没有更新。 5.8.3 更新行在数据库会话上调用add()方法可以更新数据。如：123&gt;&gt;&gt; role_admin.role_name = &apos;administrator&apos;&gt;&gt;&gt; db.session.add(role_admin)&gt;&gt;&gt; db.session.commit() 5.8.4 删除行在数据库会话上调用delete()方法删除数据。如：12&gt;&gt;&gt; db.session.delete(role_moderator)&gt;&gt;&gt; db.session.commit() 注意：插入、更新、删除，只有commit()后才会真正写入数据库。 5.8.5 查询行Flask-SQLAlechemy为每个模型（注意不是具体的模型实例）都提供了query对象，在query对象上调用相应方法可进行查询。如查询所有记录：12&gt;&gt;&gt; Role.query.all()&gt;&gt;&gt;[&lt;Role &apos;admin&apos;&gt;, &lt;Role &apos;visitor&apos;&gt;] 在query对象上可使用过滤器进行更精确的查询，如：12&gt;&gt;&gt; User.query.filter_by(role=role_visitor).all()&gt;&gt;&gt; [&lt;User &apos;john&apos;&gt;, &lt;User &apos;david&apos;&gt;] 表5-5 常用的SQLAlchemy查询过滤器 过滤器 说明 filter() 把过滤器添加到原查询上，返回一个新查询 filter_by() 把等值过滤器添加到原查询上，返回一个新查询 limit() 使用指定的值限制原查询返回的结果数量，返回一个新查询 offset() 偏移原查询返回的结果，返回一个新查询 order_by() 根据指定条件对原查询结果进行排序，返回一个新查询 group_by() 根据指定条件对原查询结果进行分组，返回一个新查询 注意：在查询上应用指定过滤器后，需通过一些执行函数执行查询。 表5-6 最常用的SQLAlchemy查询执行函数 方法 说明 all() 以列表的形式返回查询的所有结果 fitst() 返回查询的第一个结果，如果没有，则返回None first_or_404() 返回查询的第一个结果，如果没有，则终止请求，返回404错误响应 get() 返回指定主键对应的行，如果没有，则返回None get_or_404() 返回指定主键对应的行，如果没有，则返回None count() 返回查询结果的数量 paginate() 返回一个Paginate对象，它包含指定范围的结果 再看一个从关系的两端查询Role和User之间一对多的关系的例子：12345&gt;&gt;&gt; users = role_visitor.users&gt;&gt;&gt; users[&lt;User &apos;john&apos;&gt;, &lt;User &apos;david&apos;&gt;]&gt;&gt;&gt; users[0].role&gt;&gt;&gt; &lt;Role &apos;visitor&apos;&gt; 执行role_visitor.users时，隐含的查询会调用all()方法返回一个列表，query对象时隐藏的，因此很难做更进一步的查询。此时可在db.relationship()中添加lazy=&#39;dynamic参数，从而禁止自动执行查询（添加后需调用all()等方法才能执行查询，当然也可在执行前调用过滤器）。 5.9 在视图函数中操作数据库新版的hello.py当输入新用户名时，会把新用户名写入数据库，并显示Pleased to meet you!信息；当输入的是旧用户名（数据库中已有的名字）时，会显示Happy to see you again! hello.py如下：1234567891011121314151617181920# ...@app.route(&apos;/&apos;,methods=[&apos;GET&apos;, &apos;POST&apos;])def index(): form = NameForm() if form.validate_on_submit(): session[&apos;name&apos;] = form.name.data # 查找数据库中是否有该用户名，如果没有，就向数据库中添加新用户， # 因为前面已经设置了SQLALCHEMY_COMMIT_ON_TEARDOWN，所以当请求结束时会自动提交事务 user = User.query.filter_by(user_name=form.name.data).first() if user is None: # 插入数据库 user = User(user_name=form.name.data) db.session.add(user) # 用于模板中判断是显示Pleased to meet you 还是 Happy to see you again session[&apos;known&apos;] = Flase else: session[&apos;konwn&apos;] = True return redirect(url_for(&apos;index&apos;) return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;), known=session.get(&apos;known&apos;, Flase)) index.html如下：12345678910111213141516&#123;% extends &quot;base.html&quot; %&#125;&#123;% import &quot;bootstarp/wtf.html&quot; as wtf %&#125;&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block page_content %&#125;&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Hello, &#123;% if name %&#125;&#123;&#123; name &#125;&#125;&#123;% else %&#125;Stranger&#123;% endif %&#125;!&lt;/h1&gt; &#123;% if known %&#125; &lt;p&gt;Happy to see you again!&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;Pleased to meet you!&lt;/p&gt; &#123;% endif %&#125;&lt;/div&gt;&#123;&#123; wtf.quick_form(form) &#125;&#125;&#123;% endblock %&#125; 5.10 集成Python shell每次启动shell会话都要将数据库模型和实例一个一个地import进去很麻烦，对此我们可以为shell命令注册一个make_context回调函数，把想import的对象导入列表。对hello.py修改如下：123456789from flask-script import Shell, Manager# ...app = Flask(__name__)manager = Manager(app)def make_shell_context(): return dict(app=app, db=db, Role=Role, User=User)manager.add_command(&apos;shell&apos;, Shell(make_context=make_shell_context)) 这样启动shell时就会将对象直接导入shell中：12345&gt;&gt;&gt; python hello.py shell&gt;&gt;&gt; app&lt;Flask &apos;app&gt;&gt;&gt;&gt; User&lt;class &apos;app.User&apos;&gt; 5.11 使用Flask-Migrate实现数据库迁移在5.8.1 创建数据库表中我们说到，更新表的方法之一是删除旧表再重新创建表，但是这会丢失原有的数据。现在介绍方法二：使用数据库迁移框架。数据库迁移框架：能够跟踪数据库模式的变化，然后增量式地把变化应用到已有数据库中。（其功能类似与Git，能够跟踪数据库模式的变化） 可从理解Git的角度理解数据库迁移框架。 5.11.1 创建迁移仓库hello.py如下：12345from flask-migrate import Migrate, MigrateCommand# ...migrate = Migrate(app, db)manager.add_command(&apos;db&apos;, MigrateCommand) Flask-Migrate提供了一个MigrateCommand类，它可以附加到Flask-Script的manager对象上，从而导出数据库迁移命令。该例中，MigrateCommand类使用db命令附加（类似于5.10中，将Shell类使用shell命令附加）。 注意：在维护数据库迁移之前，首先要使用init子命令创建迁移仓库：12345(venv)$ python hello.py db initCreating directory /home/flask/...........Please edit configuration/connection/logging setting in &apos;/home/flask/..../alembic.ini&apos; before proceeding. 这个命令会创建一个migrations的文件夹，所有迁移脚本都在里面。 5.11.2 创建迁移脚本在Alembic中，数据库迁移用迁移脚本表示。脚本中有两个函数：upgrade()函数：把迁移中的改动应用到数据库中。downgrade()函数：将改动删除。 我们可以用revision命令手动创建Alembic迁移（upgrade()和downgrade()都是空的，需使用Alembic提供的Operations对象指令实现具体操作），也可以用migrate命令自动创建Alembic迁移（会根据模型定义和数据库当前的状态之前的差异生成upgrade()和downgrade()函数的内容）。 使用migrate命令自动创建迁移脚本：123456(venv)$ python hello.py db migrate -m &quot;initial migration&quot;INFO [alembic.migration] Context impl SQLiteImpl...INFO [alembic.qutogenerate] Detected added table &apos;users&apos;....../falsky/migrations/versions/1bc...bb5_initial_migration.py...done 5.11.3 更新数据库检查并修正好迁移脚本后，可以使用db upgrade命令把迁移应用到数据库中。如：1234(venv)$ python hello.py db upgradeINFO [alembic.migration] Context impl SQLiteImpl...INFO [alembic.migration] Running upgrade None -&gt; 1bc...bb5, initial migration 对于第一个迁移来说，其作用和调用db.create_all()方法一样，但在后续的迁移中，upgrade命令能把改动应用到数据库中，而且不影响其中保存的数据。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第四章 Web表单","date":"2017-11-14T12:54:15.000Z","path":"2017/11/14/把《Flask Web开发》读薄系列之第四章 Web表单/","text":"4.1 跨站请求伪造保护跨站请求伪造(CSRF)：恶意网站吧请求发送到，被攻击者已登录的其他网站。flask-wtf需要程序设置一个密匙。然后利用这个密匙生成加密令牌，再用令牌验证请求中表单数据的真伪，从而实现CSRF保护。 设置flask-wtf：123# ...app = Flask(__name__)app.config[&apos;SECRET_KEY&apos;] = &apos;hard to guess string&apos; 注意：为了增强安全性，密匙不应该直接写入代码中，而要保存环境变量中（第七章介绍）。 4.2 定义表单类使用flask-wtf时，每个Web表单都继承自Form类。这个类定义表单中的一组字段，每组字段都用对象（字段类的实例对象，如StringField（‘hello’））表示。字段对象可以附有一个或多个验证函数。验证函数(validator)：用来验证用户提交的数据是否符合要求。 定义名为NameForm的表单类：1234567from flask-wtf import Formfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import Requiredclass NameForm(Form): name = StringField(&apos;What is your name?&apos;, validators=[Required()]) submit = SubmitField(&apos;Submit&apos;) NameForm表单中的字段定义为类变量，类变量的值为对应字段的对象。 字段构造函数（如SubmitField()）：的第一个参数是把表单渲染成HTML时使用的标号（或文本）。 validators参数：一个由验证函数组成的列表。 表4-1 WTFORMS支持的HTML标准字段 字段类型 说明 StringField 文本字段 TextAreaField 多行文本字段 PasswordField 密码文本字段 表4-2 WTFORMS验证函数 验证函数 说明 Email 验证电子邮件地址 Required 确保字段中有数据 AnyOf 确保输入值在可选值列表中 4.3 把表单渲染成HTML假设视图函数把一个NameForm实例（通过参数form）传给模板，那么在模板中可以生成一个简单的表单：12345&lt;form method=&quot;POST&quot;&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &#123;&#123; form.name.label&#125;&#125; &#123;&#123; form.name() &#125;&#125; &#123;&#123; form.submit() &#125;&#125;&lt;/form&gt; 为了改进外观，可以将HTML属性（如id、class等）传给渲染字段的函数，如：12345&lt;form method=&quot;POST&quot;&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &#123;&#123; form.name.label&#125;&#125; &#123;&#123; form.name(id=&apos;my-text-field&apos;) &#125;&#125; &#123;&#123; form.submit() &#125;&#125;&lt;/form&gt; flask-bootstrap提供了一个辅助函数涌来渲染flask-wtf表单。用法如下：12&#123;% import &quot;bootstrap/wtf.html&quot; as wtf %&#125;&#123;&#123; wtf.quick_form(form) &#125;&#125; bootstrap/wtf.html文件中定义了一个用于渲染Flask-WTF表单对象的辅助函数。 wtf.qucik_form()函数的参数为Flask-WTF表单对象（表单类的实例）。 4.4 在视图函数中处理表单12345678910# ...@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]def index(): name = None form = NameForm() # 实例化表单类 if form.validate_on_submit(): name = form.name.data form.name.data = &apos;&apos; # 将form.name.data的值设置为空字符串 return render_template(&apos;index.html&apos;, form=form, name=name) methods参数告诉Flask在URL映射中把这个视图函数注册为GET和POST请求的处理程序。如果没有指定methods参数，就只把视图函数注册为GET请求的处理程序。 validate_on_submit()：提交表单后，如果数据能被全部验证函数接受，那么validate_on_submit()的返回值为True，否则返回False。 4.5 重定向和用户会话现在的hello.py存在一个问题：用户输入名字后提交表单，然后刷新页面，会出现一个警告（要求在再次提交表单前进行确认）。出现这种情况的原因是：刷新页面时，浏览器会重新发送之前已经发送过的最后一个请求。如果这个请求是一个包含表单数据的POST请求，刷新页面会再次提交表单。 解决思路：使浏览器发送的最后一个请求不是POST请求。解决方法：使用重定向作为POST请求的响应，而不是使用常规响应。 重定向：是一个特殊响应，响应的内容是URL，而不是包含HTML代码的字符串。浏览器收到这种响应时，会向重定向的URL发起GET请求（第二个请求），显示页面内容。 存在问题：这种方法会带来另一个问题，程序处理POST请求时，使用form.name.data来获取用户输入值，可是一旦这个请求结束，数据也就丢失（因为这个POST请求使用重定向作为响应）。所以程序需要保存输入值，方便重定向后的请求可以获得并使用这个值。 解决方法2 ：把数据存储在用户会话中。 使用重定向和用户会话重写hello.py：12345678910from flask import Flask, render_template, session, redirect, url_for# ...@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def index(): form = NameForm() if form.validate_on_submit(): session[&apos;name&apos;] = form.name.data return redirect(url_for(&apos;index&apos;)) return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;)) 使用session.get()方法获取字典中键对应的值，避免未找到键的异常情况。因为对于不存在的键， get()会返回默认值None。 4.6 Flash消息请求完成后，有时需要让用户知道状态发生了变化（如使用确认消息、警告或错误提醒）。一个典型例子是，提交了一项有错误的登录表单后，服务器发回的响应重新渲染登录表单，并且在表单上面显示一个消息，提示用户名或密码错误。 设置Flash消息的hello.py：12345678910111213form flask import Flask, render_template, session, redirect, url_for, flash# ...@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]def index(): form = NameForm() if form.validate_on_submit(): old_name = session.get(&apos;name&apos;) if old_name is not None and old_name != form.name.data: flash(&apos;Looks like you have changed your name!&apos;) session[&apos;name&apos;] = form.name.data return redirect(url_for(&apos;index&apos;) return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;)) 在这个示例中，将用户提交的数据和用户会话中的数据比较，如果两个数据不一样，就会调用flash()函数，在发给客户端的下一个响应中显示一个信息。 在模板中渲染Flash消息：仅调用flash()函数并不能将消息显示出来，这个可以在模板中渲染Flash消息。如base.html：12345678910111213&#123;% block content %&#125;&lt;div class=&quot;container&quot;&gt; &#123;% for message in get_flashed_messages() %&#125; &lt;div class=&quot;alert alert-warning&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt; &amp;times; &lt;/button&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% block page_content %&#125; &#123;% endblock %&#125;&lt;/div&gt;&#123;% endblock %&#125; get_flashed_messages()函数用来获取并渲染Flash消息。 注意： 在模板中使用for循环是因为，每次调用falsh()函数时，都会生产一个消息，所以可能有多个消息在排队等待显示，所需需要用for循环将消息都显示出来。 get_flashed_messages()函数获取的消息在下次调用时不会再次返回（如这次获取了消息队列1，那么在下次调用时就不会再返回消息队列1，有点类似于列表的pop()方法），因此Flash消息只显示一次，然后就消失了。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第三章 模板","date":"2017-11-14T12:52:00.000Z","path":"2017/11/14/把《Flask Web开发》读薄系列之第三章 模板/","text":"使用Flask-Mail提供电子邮件支持表6-1 Flask-Mail SMTP服务器的配置 配置 默认值 说明 MAIL_SERVER localhost 电子邮件服务器的主机名或IP地址 MAIL_PORT 25 电子邮件服务器的端口 MAIL_USE_TLS False 启用传输层安全（TLS）协议 MAIL_USE_SSL False 启用安全套接层（SSL）协议 MAIL_USENAME None 邮件账户的用户名 MAIL_PASSWORD None 邮件账户的授权码 在hello.py中配置Flask-Mail使用QQ邮箱： 12345678import os #...app.config[&apos;MAIL_SERVER&apos;] = &apos;smtp.qq.com&apos;app.config[&apos;MAIL_PORT&apos;] = 465app.config[&apos;MAIL_USE_SSL&apos;] = Trueapp.config[&apos;MAIL_USERNAME&apos;] = os.environ.get(&apos;MAIL_USERNAME&apos;)app.config[&apos;MAIL_PASSWORD&apos;] = os.environ.get(&apos;MAIL_PASSWORD&apos;) 注意：千万不要把账号密令直接写在脚本中，应该从环境变量中导入。 初始化Flask-Mail： 1234from flask_mail import Mail# ...mail = Mail(app) 在环境变量中定义MAIL_USERNAME和MAIL_PASSWORD： 12(venv) $ export MAIL_USERNAME=&apos;12345678@qq.com&apos;(venv) $ export MAIL_PASSWORD=&apos;qwertyuiop&apos; 此时可以使用echo命令打印出来检查一下： 1234(venv) $ echo $MAIL_USERNAME&gt;&gt;&gt; &apos;12345678@qq.com&apos;(venv) $ echo $MAIL_PASSWORD&gt;&gt;&gt; &apos;qwertyuiop&apos; 定义环境变量后，此时在同一个终端中执行python hello.py shell命令，便能获取到想要的环境变量。 注意：如果定义好环境变量后把终端关闭再重新打开，那么此时是没有上次定义的环境变量的。所以需要在同一个终端中执行。 如何让QQ邮箱开启SMTP功能，可以参考flask-mail常见的邮箱配置问题解决 在Python shell中发送电子邮件在上一个终端中，发送电子邮件：12345678(venv) $ python hello.py shell&gt;&gt;&gt; from flask_mail import Message&gt;&gt;&gt; from hello import mail&gt;&gt;&gt; msg = Message(&apos;test subject&apos;, sender=&apos;12345678@qq.com&apos;, recipients=[&apos;87654321@qq.com&apos;])&gt;&gt;&gt; msg.body = &apos;test body&apos;&gt;&gt;&gt; msg.html = &apos;&lt;p&gt;test body&lt;/p&gt;&apos;&gt;&gt;&gt; with app.app_context():··· mail.send(msg) 注意：在Flask-Mail中的send()函数使用current_app（程序上下文），因此在shell中发送邮件，需要激活程序上下文。 在程序中集成发送电子邮件功能 定义用于发邮件的函数，使hello.py支持电子邮件： 12345678910111213from flask_mail import Message# ...# 给邮件标题添加一个前缀app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] = &apos;[Flasky]&apos;# 定义发件人app.config[&apos;FLASKY_MAIL_SENDER&apos;] = &apos;12345678@qq.com&apos;def send_email(recipients, subject, template, **kwargs): msg = Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] + subject, sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;], recipients=[recilients]) msg.body = render_template(template + &apos;.txt&apos;, **kwargs) msg.html = render_template(template + &apos;.html&apos;, **kwargs) mail.send(msg) 邮件有纯文本.txt，也有HTML文本.html，客户端显示哪个，取决于邮件客户端的设置。 拓展：为什么send()函数中需要**kwargs？**kwargs的作用是什么？答：（1）因为我们不确定模板中需要什么变量参数，在此例中，模板需要的时user这个参数，但是如果换成别的模版，它不仅需要user参数，也需要其他一些参数（如datatime等，关键取决于模板设计成什么样），此时如果我们死死地把send_email()函数写成send_email(recipient, subject, template, user)，那么就失去了灵活性，当换成其他模版时，datatime参数也就无法传入了，因此send()函数需要**kwargs。（2）**kwargs的作用是：当我们不知道需要往函数中传入多少个关键字参数或者想以字典的形式作为参数时，我们可以用**kwargs，这样我们就可以根据实际情况需要，往函数中传入特定个数的参数（数量使具体情况而定）。 结合视图函数发送电子邮件： 1234567891011121314151617181920212223242526# ...# 定义收件人为Flasky的管理员app.config[&apos;FLASKY_ADMIN&apos;] = os.environ.get(&apos;FLASKY_ADMIN&apos;)# ...@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]def index(): form = NameForm() if form.validate_on_submit(): session[&apos;name&apos;] = form.name.data # 查找数据库中是否有该用户名，如果没有，就向数据库中添加新用户， # 因为前面已经设置了SQLALCHEMY_COMMIT_ON_TEARDOWN，所以当请求结束时会自动提交事务 user = User.query.filter_by(user_name=form.name.data).first() if user is None: # 插入数据库 user = User(user_name=form.name.data) db.session.add(user) # 用于模板中判断是显示Pleased to meet you 还是 Happy to see you again session[&apos;known&apos;] = Flase # 如果收件人不为空，则发送邮件 if app.config[&apos;FLASKY_ADMIN&apos;]: send_email(app.config[&apos;FLASKY_ADMIN&apos;], &apos;New User&apos;, &apos;mail/new_user&apos;, user=user) else: session[&apos;konwn&apos;] = True return redirect(url_for(&apos;index&apos;) return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;), known=session.get(&apos;known&apos;, Flase)) 此时我们也需要定义环境变量FLASKY_ADMIN：(venv) $ export FLASKY_ADMIN=&#39;12345678@qq.com&#39; template文件夹下的模板文件mail/new_user有两个，分别为new_user.txt和new_user.html。 new_user.txt如下： 1There has a new user that name is &#123;&#123; user.user_name &#125;&#125; new_user.html如下： 1&lt;h1&gt;There has a new user that name is &#123;&#123; user.user_name &#125;&#125;&lt;/h1&gt; 异步发送电子邮件为了避免处理请求过程中不必要的延迟，我们可以把发送电子邮件的函数移到后台线程中处理： 1234567891011121314from threading import Thread# ...def send_async_email(app, msg): with app.app_context(): mail.send(msg) def send_email(recipients, subject, template, **kwargs): msg = Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] + subject, sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;], recipients=[recilients]) msg.body = render_template(template + &apos;.txt&apos;, **kwargs) msg.html = render_template(template + &apos;.html&apos;, **kwargs) thr = Thread(target=send_async_email, args=[app, msg]) thr.start() return thr 注意：由于在不同线程中执行mail.send()函数，就如前面在Python shell中发送电子邮件章节中提到，send()函数需要程序current_app（程序上下文）中执行，因此需要在执行send()函数的线程中使用app.app_context()人工创建current_app。 当需要发送大量电子邮件时，使用专门发送电子邮件的作业（如Celery任务队列）处理更合适。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第二章 程序的基本概念","date":"2017-11-14T12:45:31.000Z","path":"2017/11/14/把《Flask Web开发》读薄系列之第二章 程序的基本概念/","text":"2.1 初始化123from flask import Flaskapp = Flask(__name__) Flask实例化只有一个必须指定的参数，即程序主模块或包的名字（也即__name__）1234# 2.2 路由和视图函数1. **路由**：处理URL和函数之间的关系（URL到Python函数的映射关系）的程序。```可通过Flask实例提供的`app.route()`装饰器把函数注册为路由。 视图函数：像index()这样的函数。 2.4 一个完整的程序1234567891011121314from flask import Flaskapp = Flask(__name__)@app.route(&apos;/&apos;)def index(): return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;@app.route(&apos;/user/&lt;name&gt;&apos;) # &lt; &gt;尖括号部门是动态url部分def user(name): # Flask会将动态部分（也即&lt; &gt;部分）作为参数传入视图函数中 return &apos;&lt;h1&gt;Hello &#123;&#125;!&apos;.format(name) if __name__ == &apos;__main__&apos;: app.run(debug=True) 2.5 请求-响应2.5.1 程序与请求上下文 程序上下文： 请求上下文: 2.5.2 请求调度Flask使用app.route()装饰器或者非装饰器形式的app.add_url_rule()生成URL和视图函数之间的映射 2.5.3 请求钩子应用场景：在请求开始时，创建数据库链接或认证用户。（即在处理请求之前或之后，执行某些代码）Flask提供以下4种钩子： before_first_request：注册一个函数，在处理第一个请求之前运行 before_request：注册一个函数，在每次请求之前运行 after_request：注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行 teardown_request：注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行 2.5.4 响应视图函数返回值可以接受3个参数：响应文本，状态码，一个由header组成的字典。make_response()函数可以接受3个参数（和视图函数返回值一样），并返回一个response对象，此时我们可以在response对象上调用各种方法，进一步设置响应。如获得一个response对象，然后设置cookie：12345678910from flask import Flaskfrom flask import make_responseapp = Flask(__name__)@app.route(&apos;/&apos;)def index(): response = make_response(&apos;&lt;h1&gt;This document carries a cookie!&lt;/h1&gt;&apos;) response.set_cookie(&apos;answer&apos;, &apos;42&apos;) return response redirect()函数用于生成重定向（一种特殊的响应）。 abort函数用于生产另一种特殊响应，用于处理错误。如：12345678910111213141516from flask import Flaskfrom flask import redirectfrom flask import abortapp = Flask(__name__)@app.route(&apos;/&apos;)def index(): return redirect(&apos;http://www.example.com&apos;) @app.route(&apos;/user/&lt;id&gt;&apos;)def get_user(id): user = load_user(id) # load_user()用于读取id，不展开写 if not user: abort(404) # 如果id不存在，返回状态吗404 return &apos;&lt;h1&gt;Hello &#123;&#125;&lt;/h1&gt;&apos;.format(id) 2.6 Flask扩展可使用flask-script扩展为Flask程序添加一个命令行解析器，那么就可以自定义很多参数，如监听的host、port等。实现方式：1234567from flask.ext.script import Manager# ...manager = Manager(app)if __name__ = &apos;__main__&apos;: manager.run() 把Flask实例app作为参数传给Manager()，初始化实例。注意：Flask扩展都在flask.ext命名空间下，而Python3.5之后都直接使用from flask-xxx import xxx来导入。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第一章 创建虚拟环境","date":"2017-11-14T12:43:30.000Z","path":"2017/11/14/把《Flask Web开发》读薄系列之第一章 创建虚拟环境/","text":"切换到目标文件夹目录 执行virtualenv venv命令，其中venv为虚拟环境名称 执行source venv/bin/activate激活虚拟环境","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之序言","date":"2017-11-14T12:20:58.000Z","path":"2017/11/14/把《Flask Web开发》读薄系列之序言/","text":"读者的疑惑《把读薄系列》主要是对《Flask Web开发》一书的概括，或许你读起来会吐槽说“卧靠，这不就是书中的内容吗，直接把书中的内容搬过来就可以成一个系列了，真牛逼“。对此，我只能说读书笔记大概就是这样吧。你对其中的内容懂了，就会觉得很容易，觉得很没必要做这样的一种记录，完全是照搬书中内容，没有什么实质东西。但是，该系列也并不完全是书中内容，它还包括作者对一些该概念的理解、类比，以及代码实现过程中可能遇到的、应该注意的坑等。如：把第五章数据库中的5.11 使用Flask-Migrate实现数据库迁移，跟Git版本控制联系起来，结合理解。如：第六章电子邮件中通过QQ邮箱服务器发送邮件应该注意的坑，以及拓展对**kwargs的理解和实际应用情景。总的来说，该系列主要起到的作用如下： 起到思维导图作用。当你初学完或者之前学过但是没有实际应用过，那么该系列可以帮助你勾起记忆，尽快掌握Flask的一些基本知识。另外也能让你根据思维导图你查漏补缺。 加入一些类比，加强理解书中概念。如前面说到的Flask-Migrate与Git的类比。书中的一些类比能否帮助你，视人而已，因为每个人对概念的理解都不同，就像不是所有读者都了解Git一样。 拓展对Python一些概念的理解。亦如前面说到的对**kwargs的理解。 最后说两句可能是翻译的原因，书中偶尔会出现的一些句子或内容读起来很费劲，很难理解，对此，作者也尽量以平实的语言概括该系列，甚至是以提炼出“存在问题—解决思路—解决方法“或者问答的形式来概括书中内容，加深理解。如第四章4.5 重定向和用户会话，作者根据书中内容提炼出“存在问题—解决思路—解决方法”来解释为什么使用重定向和用户会话。 另外，为了更准确地表达意思，该系列中的一些章节的名字可能与原书的章节名字不同，但这并不要紧，意思对了就行。 联系作者如果你对《Flask Web开发——基于Python的Web应用开发实战》书中的内容有一些很好的个人理解（如用类比来理解）等，可以把你的理解整理好发送到作者邮箱：weichang321@gmail.com。我将会筛选一些好的内容加入到该系列中，并署上你的名字。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"构建爬取大众点评美食数据的多线程爬虫（含多进程实现）（一）","date":"2017-10-20T14:07:02.000Z","path":"2017/10/20/构建爬取大众点评美食数据的多进程爬虫（一）/","text":"构建爬取大众点评美食数据的多进程爬虫（一）一、要抓取哪些数据以东莞美食为例大众点评-美食-东莞，可以看到，在美食页面，我们想要爬取的信息有： 商户标题 星级 评论数 人均价格 各项评分 菜系 地址 二、分析页面（一）多观察页面通过点击小吃快餐，我们看到小吃快餐下一共有50个页面。再点击面包甜点，发现也只有50个页面。接下来我们看看面包甜点-东城区，发现最多也只有50个页面。如此类推，我们大概可以确定，某菜系-某区域最多只有50个页面，由此基本可以判断，这应该是大众点评做大反爬虫措施。对此，我们在稍后的爬虫设计中，不能简单地从某一菜系下爬取所有页面或者从某一区域下爬取所有页面，因为单独选定菜系或者区域，服务器最多只返回50个页面给你。 因此我们需要将菜系-区域组合起来爬取，尽可能多的爬取商户信息。 通过观察，我们发现在一个网页中，如：http://www.dianping.com/search/category/219/10/g117r434g117代表菜系，r434代表区域，因此我们可以获取所有的菜系链接，接着在菜系链接的基础上获取菜系-区域链接，这就相当于在用浏览器浏览时，先选定了某一菜系，再选定某一区域。 （二）分析页面结构这里就是要通过定位来选定我们需要的元素。如一级菜系，它所处的位置是id=&quot;classfy的div标签下的a标签中。商户标题，它所处的位置是class=&quot;tit&quot;的div标签下的第一个a标签中。通过一个个地查看，我们可以得出我们要爬取的7个商户信息的位置，方便我们后续设计爬虫时进行定位。 三、设计爬虫（一）爬虫思路 爬虫流程图 从start_url开始，爬取所有一级菜系链接，得到tag1_url，存入数据库。 从数据库中读取tag1_url，爬取所有二级菜系链接，得到tag2_url，存入数据库。 从数据库中读取tag2_url，爬取所有一级区域链接，得到addr1_url，存入数据库。 从数据库中读取addr1_url，爬取所有二级区域链接，得到addr2_url，存入数据库。 从数据库中读取addr2_url，爬取所有商户信息，得到dpshop_msg，存入数据库。1-4目的都是一样，为了获取最终要爬取的页面链接，5就是为了实际爬取上述7个商户信息，所以我们把1-4写到cate_parsing.py文件中，把5写到shop_parsing.py文件中。另外，为了应对反爬虫，我们将用于伪装的User-Agent和代理IP等一些爬虫参数写到config.py文件中。（二）构建代码config.py代码如下：1234567891011121314151617181920212223242526272829303132#coding=utf-8#伪装浏览器USER_AGENT = [ &apos;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&apos;, &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36&apos;, &apos;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11&apos;, &apos;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16&apos;, &apos;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0&apos;, &apos;Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10&apos; ]# 代理IPPROXY = [ &apos;111.13.111.184:80&apos;, &apos;49.119.164.175:80&apos;, &apos;61.136.163.245:3128&apos;, &apos;116.199.2.210:80&apos;, &apos;116.199.2.209:80&apos;, &apos;116.199.115.79:80&apos;, &apos;116.199.2.196:80&apos;, &apos;121.40.199.105:80&apos;, &apos;125.77.25.118:80&apos;, &apos;122.228.253.55:808&apos; ]TIMEOUT = 5LINKTIME = 3PAGE_NUM_MAX = 50 cate_parsing.py代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#coding=utf-8import requestsimport randomimport pymongoimport timefrom lxml import etreefrom config import USER_AGENT, PROXY, TIMEOUT, LINKTIMEclient = pymongo.MongoClient(&apos;localhost&apos;, 27017)dp = client[&apos;dp&apos;]# 爬取一级菜系、二级菜系、二级菜系下的一级地址class GetTagAddr(object): headers = random.choice(USER_AGENT) proxies = &#123;&apos;http&apos;:random.choice(PROXY)&#125; s = requests.Session() s.headers.update(&#123;&apos;User-Agent&apos;:headers&#125;) linktime = LINKTIME timeout = TIMEOUT tag1_url_db = dp[&apos;tag1_url_db&apos;] # 存储从start_url中成功爬取到的tag1_url tag2_url_db = dp[&apos;tag2_url_db&apos;] # 存储从tag1_url中成功爬取到的tag2_url crawly_tag1_ok = dp[&apos;crawly_tag1_ok&apos;] # 存储爬取成功的tag1_url addr1_url_db = dp[&apos;addr1_url_db&apos;] # 存储从tag2_url中成功爬取到的addr1_url crawly_tag2_ok = dp[&apos;crawly_tag2_ok&apos;] # 存储爬取成功的tag2_url addr2_url_db = dp[&apos;addr2_url_db&apos;] # 存储从addr1_url中成功爬取到的addr2_url crawly_addr1_ok = dp[&apos;crawly_addr1_ok&apos;] # 存储爬取成功的addr1_url def get_tag1_from(self, start_url): try: r = self.s.get(start_url, proxies=self.proxies, timeout=self.timeout) tree = etree.HTML(r.text) tag1_items = tree.xpath(&apos;//div[@id=&quot;classfy&quot;]/a&apos;) for i in tag1_items: tag1 = i.getchildren()[0].text url = i.attrib[&apos;href&apos;] tag1_url_msg = &#123;&apos;tag1&apos;: tag1, &apos;url&apos;: url, &apos;status&apos;: &apos;ok&apos;&#125; self.tag1_url_db.insert_one(tag1_url_msg) self.linktime = 3 # 重置linktime time.sleep(1) except(requests.exceptions.ProxyError, requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError): if self.linktime &gt; 0: print(&apos;爬取失败，现在重新链接&apos;) self.get_tag1_from(start_url) self.linktime -= 1 else: print(&apos;&#123;&#125;爬取失败&apos;.format(start_url)) def get_tag2_from(self, tag1_url): tag1_url_msg = self.tag1_url_db.find_one(&#123;&apos;url&apos;: tag1_url&#125;) tag1 = tag1_url_msg[&apos;tag1&apos;] try: r = self.s.get(tag1_url, proxies=self.proxies, timeout=self.timeout) tree = etree.HTML(r.text) tag2_items = tree.xpath(&apos;//div[@id=&quot;classfy-sub&quot;]/a&apos;) if len(tag2_items) == 0: tag2 = &apos;no_sub&apos; tag2_url_msg = &#123;&apos;tag1&apos;: tag1, &apos;tag2&apos;: tag2, &apos;url&apos;: tag1_url, &apos;status&apos;: &apos;tag1_not_sub&apos;&#125; self.tag2_url_db.insert_one(tag2_url_msg) else: for i in tag2_items: tag2 = i.getchildren()[0].text url = i.attrib[&apos;href&apos;] tag2_url_msg = &#123;&apos;tag1&apos;: tag1, &apos;tag2&apos;: tag2, &apos;url&apos;: url, &apos;status&apos;: &apos;ok&apos;&#125; self.tag2_url_db.insert_one(tag2_url_msg) self.crawly_tag1_ok.insert_one(&#123;&apos;url&apos;: tag1_url&#125;) self.linktime = 3 # 重置linktime time.sleep(1) except(requests.exceptions.ProxyError, requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError): if self.linktime &gt; 0: print(&apos;爬取失败，现在重新链接&apos;) self.get_tag2_from(tag1_url) self.linktime -= 1 else: print(&apos;&#123;&#125;爬取失败&apos;.format(tag1_url)) def get_addr1_from(self, tag2_url): tag2_url_msg = self.tag2_url_db.find_one(&#123;&apos;url&apos;: tag2_url&#125;) tag1 = tag2_url_msg[&apos;tag1&apos;] tag2 = tag2_url_msg[&apos;tag2&apos;] try: r = self.s.get(tag2_url, proxies=self.proxies, timeout=self.timeout) tree = etree.HTML(r.text) addr1_items = tree.xpath(&apos;//div[@id=&quot;region-nav&quot;]/a&apos;) for i in addr1_items: addr1 = i.getchildren()[0].text url = i.attrib[&apos;href&apos;] addr1_url_msg = &#123;&apos;tag1&apos;: tag1, &apos;tag2&apos;: tag2, &apos;addr1&apos;: addr1, &apos;url&apos;: url&#125; self.addr1_url_db.insert_one(addr1_url_msg) self.crawly_tag2_ok.insert_one(&#123;&apos;url&apos;: tag2_url&#125;) self.linktime = 3 # 重置linktime time.sleep(1) except(requests.exceptions.ProxyError, requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError): if self.linktime &gt; 0: print(&apos;爬取失败，现在重新链接&apos;) self.get_addr1_from(tag2_url) self.linktime -= 1 else: print(&apos;&#123;&#125;爬取失败&apos;.format(tag2_url)) def get_addr2_from(self, addr1_url): addr1_url_msg = self.addr1_url_db.find_one(&#123;&apos;url&apos;: addr1_url&#125;) tag1 = addr1_url_msg[&apos;tag1&apos;] tag2 = addr1_url_msg[&apos;tag2&apos;] addr1 = addr1_url_msg[&apos;addr1&apos;] try: r = self.s.get(addr1_url, proxies=self.proxies, timeout=self.timeout) tree = etree.HTML(r.text) addr2_items = tree.xpath(&apos;//div[@id=&quot;region-nav-sub&quot;]/a&apos;) if len(addr2_items) == 0: addr2 = &apos;no_sub&apos; addr2_url_msg = &#123;&apos;tag1&apos;: tag1, &apos;tag2&apos;: tag2, &apos;addr1&apos;: addr1, &apos;addr2&apos;: addr2, &apos;url&apos;: addr1_url, &apos;status&apos;: &apos;addr1_not_sub&apos;&#125; self.addr2_url_db.insert_one(addr2_url_msg) else: for i in addr2_items: addr2 = i.getchildren()[0].text url = i.attrib[&apos;href&apos;] addr2_url_msg = &#123;&apos;tag1&apos;:tag1, &apos;tag2&apos;: tag2, &apos;addr1&apos;:addr1, &apos;addr2&apos;: addr2, &apos;url&apos;:url&#125; self.addr2_url_db.insert_one(addr2_url_msg) self.crawly_addr1_ok.insert_one(&#123;&apos;url&apos;: addr1_url&#125;) self.linktime = 3 # 重置linktime time.sleep(1) except( requests.exceptions.ProxyError, requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError): if self.linktime &gt; 0: print(&apos;爬取失败，现在重新链接&apos;) self.get_addr2_from(addr1_url) self.linktime -= 1 else: print(&apos;&#123;&#125;爬取失败&apos;.format(addr1_url))if __name__ == &apos;__main__&apos;: url = &apos;http://www.dianping.com/search/category/219/10/g0r0&apos; get_tag1_from, get_tag2_from, get_addr1_from和get_addr2_from都采用了同样的逻辑： 先请求url，获得response。 使用etree.HTML解析网页。 定位所要爬取元素的位置。 存储。 shop_parsing.py代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#coding=utf-8import requestsimport randomimport pymongoimport timefrom lxml import etreefrom config import USER_AGENT, PROXY, TIMEOUT, LINKTIME, PAGE_NUM_MAXclient = pymongo.MongoClient(&apos;localhost&apos;, 27017)dp = client[&apos;dp&apos;]addr2_url_db = dp[&apos;addr2_url_db&apos;] # 存储从addr1_url中成功爬取到的addr2_urldpshop = dp[&apos;dpshop&apos;] # 存储从addr2中成功爬取到的dpshop_msgcrawly_addr2_ok = dp[&apos;crawly_addr2_ok&apos;] # 存储爬取成功的addr2_url# def callback(future):# response, addr2_url = future.result()# get_msg_from(response, addr2_url)def get_msg_from(response, addr2_url): addr2_url_msg = addr2_url_db.find_one(&#123;&apos;url&apos;: addr2_url&#125;) tag1 = addr2_url_msg[&apos;tag1&apos;] tag2 = addr2_url_msg[&apos;tag2&apos;] addr1 = addr2_url_msg[&apos;addr1&apos;] addr2 = addr2_url_msg[&apos;addr2&apos;] tree = etree.HTML(response.text) # 提取标题信息 title_items = tree.xpath(&apos;//div[@id=&quot;shop-all-list&quot;]//div[@class=&quot;tit&quot;]/a[1]&apos;) # 提取商户星级 star_items = tree.xpath(&apos;//div[@class=&quot;comment&quot;]/span&apos;) # 提取评论数-人均价格 review_price_items = tree.xpath(&apos;//div[@class=&quot;comment&quot;]/a&apos;) review_price_list = [] for i in review_price_items: # 判断评论数-价格的a标签是否存在子元素，如果存在，则在子元素中提取评论数-价格，否则评论数-价格都为“None” if i.getchildren(): text = i.getchildren()[0].text review_price_list.append(text) else: review_price_list.append(&quot;None&quot;) review_price_list = [review_price_list[i:i + 2] for i in range(0, len(review_price_list), 2)] # 提取各项评分 score_items = tree.xpath(&apos;//span[@class=&quot;comment-list&quot;]/span/b&apos;) score_items = [i.text for i in score_items] score_items = [score_items[i:i + 3] for i in range(0, len(score_items), 3)] # 提取菜系-商区-详细地址 tag_items = tree.xpath(&apos;//div[@class=&quot;tag-addr&quot;]//span&apos;) tag_items = [i.text for i in tag_items] tag_items = [tag_items[i:i + 3] for i in range(0, len(tag_items), 3)] for title_url, star, review_price, score, tag_area_addr in zip(title_items, star_items, review_price_list, score_items, tag_items): dpshop_msg = &#123; &apos;title&apos;: title_url.attrib[&apos;title&apos;], &apos;url&apos;: title_url.attrib[&apos;href&apos;], &apos;star&apos;: star.attrib[&apos;title&apos;], &apos;review&apos;: review_price[0], &apos;price&apos;: review_price[1], &apos;taste&apos;: score[0], &apos;env&apos;: score[1], &apos;service&apos;: score[2], &apos;tag1&apos;: tag1, &apos;tag2&apos;: tag2, &apos;addr1&apos;: addr1, &apos;addr2&apos;: addr2, &apos;full_addr&apos;: tag_area_addr[2] &#125; dpshop.insert_one(dpshop_msg) crawly_addr2_ok.insert_one(&#123;&apos;url&apos;: addr2_url&#125;)def get_all_msg_from(addr2_url): for page in range(1, PAGE_NUM_MAX+1): result_url = &apos;&#123;&#125;p&#123;&#125;&apos;.format(addr2_url, page) status_code, response = requests_url(result_url) if status_code == &apos;link_bad&apos;: print(&apos;请求失败，请在crawly_addr2_url_bad中查看请求失败url&apos;) break elif status_code == 404: # addr2_bad = &#123;&apos;url&apos;: result_url, &apos;status&apos;: 404&#125; print(&apos;&#123;&#125;没有相关商户&apos;.format(result_url)) break else: get_msg_from(response, addr2_url)def requests_url(result_url, linktime=LINKTIME): s = requests.Session() headers = random.choice(USER_AGENT) s.headers.update(&#123;&apos;User-Agent&apos;: headers&#125;) proxies = &#123;&apos;http&apos;:random.choice(PROXY)&#125; try: r = s.get(result_url, proxies=proxies, timeout=TIMEOUT) time.sleep(1) return (r.status_code, r) except(requests.exceptions.ProxyError, requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError): if linktime &gt; 0: print(&apos;请求失败，现在重新链接&apos;) linktime -= 1 requests_url(result_url, linktime) else: status_code = &apos;link_bad&apos; response = None return (status_code, response)if __name__ == &apos;__main__&apos;: addr2_url = &apos;http://www.dianping.com/search/category/219/10/g217r27028p3&apos; requests_url函数用于请求网页，并返回状态码和response。 get_msg_from函数用于解析源代码，定位元素，爬取并存储所有我们需要的商户信息。 get_all_msg_from函数实现了多页码爬取，当遇到网页状态码为404时，代表此时没有相关商户，最后一页已经被爬取，自动跳出for循环。结束某个addr2_url的爬取。 run.py代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# coding=utf-8from parsing.cate_parsing import GetTagAddrfrom parsing.shop_parsing import get_all_msg_from, crawly_addr2_okfrom concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutorif __name__ == &apos;__main__&apos;: start_url = &apos;http://www.dianping.com/search/category/219/10/g0r0&apos; tag_addr_task = GetTagAddr() # 爬取tag1_url tag_addr_task.get_tag1_from(start_url) print(&apos;tag1_url爬取完成&apos;) # 爬取tag2_url tag1_wait = set(i[&apos;url&apos;] for i in tag_addr_task.tag1_url_db.find()) tag1_ok = set(i[&apos;url&apos;] for i in tag_addr_task.crawly_tag1_ok.find()) tag1_task = tag1_wait - tag1_ok for tag1_url in tag1_task: tag_addr_task.get_tag2_from(tag1_url) print(&apos;tag2_url爬取完成&apos;) # 爬取addr1_url tag2_wait = set(i[&apos;url&apos;] for i in tag_addr_task.tag2_url_db.find()) tag2_ok = set(i[&apos;url&apos;] for i in tag_addr_task.crawly_tag2_ok.find()) tag2_task = tag2_wait - tag2_ok for tag2_url in tag2_task: tag_addr_task.get_addr1_from(tag2_url) print(&apos;addr1_url爬取完成&apos;) # 爬取addr2_url addr1_wait = set(i[&apos;url&apos;] for i in tag_addr_task.addr1_url_db.find()) addr1_ok = set(i[&apos;url&apos;] for i in tag_addr_task.crawly_addr1_ok.find()) addr1_task = addr1_wait - addr1_ok with ProcessPoolExecutor(max_workers=4) as executor: executor.map(tag_addr_task.get_addr2_from, addr1_task) print(&apos;addr2_url爬取完成&apos;) # 根据addr2_url爬取商户信息 addr2_wait = set(i[&apos;url&apos;] for i in tag_addr_task.addr2_url_db.find()) addr2_ok = set(i[&apos;url&apos;] for i in crawly_addr2_ok.find()) addr2_task = addr2_wait - addr2_ok with ThreadPoolExecutor(max_workers=8) as executor: for url in addr2_task: v = executor.submit(get_all_msg_from, url) executor.shutdown(wait=True) # executor.map(get_all_msg_from, addr2_task, chunksize=50) print(&apos;addr2_url_reslut_url爬取完成&apos;) 爬取addr2_url采用多进程爬取，多进程通过concurrent.futures.ProcessPoolExecutor实现。 爬取dpshop_msg采用了多线程爬取，多线程通过congurrent.futures.ThreadPoolExecutor实现。","tags":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://richardrw.github.io/tags/Python爬虫/"},{"name":"多进程","slug":"多进程","permalink":"https://richardrw.github.io/tags/多进程/"},{"name":"大众点评","slug":"大众点评","permalink":"https://richardrw.github.io/tags/大众点评/"}]},{"title":"从美食的角度看东莞（数据来源：大众点评）","date":"2017-10-20T13:35:45.000Z","path":"2017/10/20/从美食的角度看东莞（数据来源：大众点评）/","text":"从美食的角度看东莞（数据来源：大众点评）先从为什么要做这个项目说起，事情的缘由是这样的，小编当时跟领导到别的城市外出出差一个星期，作为一个平时很少外出的人，别说是别的城市了，就连东莞这个地方我都还没走遍过，尤其是那些重要商区、美食店，平时跟朋友出去玩，都很尴尬不知道要吃什么好。现在跟领导外出别的城市，感觉自己是个刚出大山的农村小伙子，对外面的世界所知甚少。作为领导的助手，自然就要安排好这一星期的就餐地点。然而这就很难为我了，我连东莞有什么地方有好吃的都不知道，现在居然要我在别的城市安排一个星期的就餐作息表？这就很尴尬了。于是我每天都苦于到大众点评、美团等APP上搜索附近美食，但是还是不知道那些餐店的真实情况怎样，环境如何，味道如何。于是此时我就想，如果能一下子就知道某个城市或者某个区中最受欢迎的店有哪些，哪个镇或者哪个区最繁华，那该多好。于是小编回来后就开始构思，接着就撸起袖子加油干，爬取了大众点评上1.5w多条数据，并做了个东莞美食商户数量热力图，从美食的角度看东莞。 东莞各镇街美食商户数量分布热力图 （因为图片大小问题，莞城、洪梅和大岭山的标签没有显示出来，要解决这个问题，可以找张大点的图制作SVG） 东莞各镇街美食商户数量分布热力图-动态 东莞各镇街美食商户数量柱状图 可以看出，东城区商户数量最多，其次是南城区，从热力图来看，也可以看出东莞哪个镇街最繁华，也可以初步判断出哪些镇街经济情况比较好。因为一般经济越好的地区，其商业越繁华越发达。为了验证这个猜想，小编查了下东莞2016年各镇街经济实力排名情况 东莞各镇街2017年经济实力排名情况 可以看出，经济实力与地区商户数量基本成正相关。这里说一个特例吧，那就是松山湖。本地人可能知道原因，那就是因为松山湖建立历史比较年轻，区域布局比较先进，目前仅有万科（好像是）这个大型商场，其他就以大学、高新技术产业区以及青山绿水为主，没有一脑子就开发许多商业区，所以就出现了这个经济实力与地区美食商户数量不匹配的情况。接下来看看各星级商户占比情况如何 东莞不同星级商户占比饼状图 准四星用户占73.98%，看来东莞的饮食服务业还是可以的（毕竟是广东啊哈哈）再看看东莞各菜系商户数量情况如何 东莞各菜系商户数量柱状图 小吃快餐最多，其次是面包甜点。小吃快餐最多的原因小编猜测可能有三： 大多数公司中的员工中午都在公司叫外卖，外卖以小吃快餐为主，需求较大，由此催生出一批小吃快餐店，以满足市场需求。 开小吃快餐店的成本比较低，像沙县小吃什么的快餐店，随便会做个番茄炒蛋饭青瓜肉片饭就能开个快餐店了（哈哈），比面包甜点、西餐的开店成本低。 大多数小吃快餐店都选择加入大众点评平台，以提高销售量，增加利润。 至于面包甜点有3155家，这让小编感到意外，没想到东莞居然有这么多面包店。好了，暂时就分析到这里，小编最爱吃的就是面包了，赶紧去看看里面有哪些面包店的，一定要去尝尝。","tags":[{"name":"数据分析","slug":"数据分析","permalink":"https://richardrw.github.io/tags/数据分析/"},{"name":"美食","slug":"美食","permalink":"https://richardrw.github.io/tags/美食/"},{"name":"东莞","slug":"东莞","permalink":"https://richardrw.github.io/tags/东莞/"}]},{"title":"年轻人是否到北上广深发展的博弈论分析","date":"2017-09-25T14:05:11.000Z","path":"2017/09/25/年轻人是否应该到北上广深发展的博弈论分析/","text":"一、思考背景有人说，当你在一个岗位上工作时间超过1年的时候，你就会不自觉地思考，思考诸如你当前工作的意义是什么、这个岗位是否真的适合你等这些“终极问题”。博主现在已经毕业一年零三个月，实际工作时间已有一年零九个月，在这时间点上，大脑变的不自主地思考起一些关于人生的是非对错问题。引发博主思考这个问题的背景主要有三： 曾为大学毕业生，也曾思考过到北上广深发展还是留守本地，驻地生根的问题。 身边有人说，到北上广深发展，只能当炮灰。在沉重的生活成本下，即使工资比二三线城市高，但是实际生活质量却不比二三线城市好，甚至更差。去了只能压榨自己，使自己成为一线城市的“蜡烛”，照亮了别人（成就了上层人士），燃烧了自己（折旧了自己）。 身边也有人说，到北上广深发展，机会更大。留在本地（二三线城市），固然稳定，生活压力也没那么大，但是一辈子都不会有什么变数，一生只能按现在的状态生活下去，极难遇到让自己人生变得更加美好的变数（机遇）。到底谁说的对，谁说的错，是该往北上广深发展，还是驻地生根。不同的人在做这个决定的时候，他考量的是什么，决策依据是什么，决策背后的理论根据又是什么。此时慢慢地、慢慢地，博主想通过博弈论的角度，看能不能分析出什么，想知道，思考的结果又能不能为博主指明前往更美好生活的方向。 写着写着发现，这题目太过严肃认真了，提不起兴趣来写，姑且就先来吹吹水吧。想必大家如果留意生活想象的话，应该不难发现这些现象：在足球比赛中，说说国足吧，一开始总是让人觉得放不开来打，等到落后比分的时候才奋力直追放开来打。在帆船比赛中，落后的选手总是不会老老实实地跟着领航者的路线，而是另谋航线以求超越。在LOL等电子竞技赛中，劣势的一方总是希望通过大龙来抢夺来争取一线赢机。为什么人们在处于劣势环境的情况下，总是追求那些很不稳定的方法呢？例如在篮球足球比赛中，落后一方总是采取多冒险的策略，去搞小动作去犯规。下面我们就来用数学先分析一下。我们假设在一场篮球比赛中，比赛的结果由比赛双方的能力和运气一起决定，你的取胜条件需满足： 你的能力 + 你的运气 &gt; 对手的能力 + 对手的运气 或者 你的运气 - 对手的运气 &gt; 你的能力 - 对手的能力 L &gt; S 在一场比赛中，你的能力、对手的能力基本是已经确定的，因为你不会像《龙珠》里的赛亚人那样，打着打着就变身为超级赛亚人提升战斗力，因此我们不妨将 “你的能力 - 对手的能力” 的差值S视为一确定的系数。那么剩下来，影响比赛结果的就是 “你的运气 - 对手的运气“ 的差值L能否大于S 。 假设对手的能力比你强，你处于劣势，此时S&gt;0，为正值。你要获胜，就必须使得“你的运气 - 对手的运气”的差值L大于S，即当且仅当L&gt;S，你才能获胜。那么我们要如何使得L&gt;S呢？运气这种东西，是我们能够控制的吗？ 我们不妨从数学的角度来看“你的运气 - 对手的运气”的差值L。因为你的运气和对手的运气都是不确定的，必然，“你的运气 - 对手的运气”的差值L也是不确定的，即L的值存在概率性，因此不妨假设L的概率分布是正态曲线（如下图中的实线曲线）。横轴x的任意点，代表L可能的取值，其到曲线上的高y值代表L取某值时对应的概率，因此曲线在两点间覆盖的面积等于L取值位于这两点间的概率。 L取值概率分布图 由图可见，你取胜的概率为图中网格的阴影面积，即对于所有L可能的取值，满足L&gt;S的取值的概率之和。到这里，我们已经知道“你的运气 - 对手的运气”的数学上的意义了。那么回到我们之前的问题：运气这种东西，是我们能够控制的吗？ 答案是可以的。或许从感性理解上，这会很不可思议，但是从数学的角度看，改变运气，就是让你改变“你的运气”的概率分布，使得“你的运气 - 对手的运气”大于S变得更加可能。那么我们需要怎么做呢？还是先从数学角度看。让“你的运气 - 对手的运气”的值大于S变得更加可能，也就是让你增大图中的网格阴影面积。 问：怎么增大？答：让正态曲线更加平坦即可。（如变成上图中的阴线曲线） 曲线变得更平坦后，由图可见，L&gt;S的面积增加了斜线阴影部分，也就是说L&gt;S的概率更大了。在这种情况下，你获胜的概率也就提升了。 曲线变得更平坦，意味着L的取值更具不确定性。在实际生活中，你一般只需采取更冒险、更激进的策略就能达到让“你的运气”的概率分布曲线变得更加平台的效果。就如篮球比赛中，对方实力比你强，你处于落后状态，这时，如果你陈规蹈矩，按部就班，那么你是很难有反超的机会的，因为你只能依靠进攻得分，而那些博犯规罚球得分等“非正常”得分你就很少有机会碰到，因为你打得很稳。相反，如果你采取冒险、更加激进的策略，你活得博犯规罚球得分的机会就会变大，得分机会变大，也就意味着你反超的机会变大。 因此，如果你面对一个比你强大的对手，而你又处于劣势状态，那么你就需要采取一些冒险的策略来打破这种“对手比你厉害，你处于劣势“的稳定状态，从而提高你的胜率。 回到标题中的问题，答案可以从上述中得出总结，只不过在这个比赛中，对手可能不是别人，而可能是你自己，或者整个大环境。你此时需要衡量一下自己的处境，自己能力对于大环境来说，是强是弱，自己的处境是劣势还是优势，在根据综合判断，看是否需要采取一些冒险的策略来打破平衡、打破稳定，提高自己的胜率。","tags":[{"name":"博弈论","slug":"博弈论","permalink":"https://richardrw.github.io/tags/博弈论/"},{"name":"稳定性","slug":"稳定性","permalink":"https://richardrw.github.io/tags/稳定性/"},{"name":"风险","slug":"风险","permalink":"https://richardrw.github.io/tags/风险/"},{"name":"均衡","slug":"均衡","permalink":"https://richardrw.github.io/tags/均衡/"},{"name":"北上广深","slug":"北上广深","permalink":"https://richardrw.github.io/tags/北上广深/"}]},{"title":"sublime如何添加python3版本以及中文乱码问题","date":"2017-09-23T16:05:05.000Z","path":"2017/09/24/sublime如何添加python3版本以及中文乱码问题/","text":"一、当同时安装了python2和python3时，如何让sublime text同时支持？ 在sublime text中选择Toos—&gt;Build System—&gt;New Build System，此时会创建一个新文件，内容如下： 123&#123; &quot;shell_cmd&quot;: &quot;make&quot;&#125; 将原有内容删除，把以下内容复制进去： 123456&#123; &quot;cmd&quot;: [&quot;/Library/Frameworks/Python.framework/Versions/3.6/bin/python3&quot;, &quot;-u&quot;, &quot;$file&quot;], &quot;file_regex&quot;: &quot;^[ ]*File \\&quot;(...*?)\\&quot;, line ([0-9]*)&quot;, &quot;selector&quot;: &quot;source.python&quot;, &quot;env&quot;: &#123;&quot;LANG&quot;: &quot;en_US.UTF-8&quot;&#125;&#125; 注意： /Library/Frameworks/Python.framework/Versions/3.6/bin/python3为你安装python3的路径 查看你python2或python3的路径方法。在终端／cmd下执行 which python获取python2路径，执行which python3获取python3路径，复制替换&quot;cmd&quot;中python的路径即可。 &quot;env&quot;: {&quot;LANG&quot;: &quot;en_US.UTF-8&quot;的作用是为了正常地显示中文 将文件保存为Python3.sublime-build，路径为sublime安装目录下的Packages文件夹 二、使用ConvertToUTF8解决中文乱码 使用Ctrl+Shift+P打开Package Control，输入install package按回车，再搜索ConvertToUTF8来安装插件 安装完后再次使用Ctrl+Shift+P打开Package Control，这次输入ConvertToUTF8，回车，再选择UTF-8编码即可。这样就会以utf-8的编码格式编辑文件。","tags":[{"name":"sublime","slug":"sublime","permalink":"https://richardrw.github.io/tags/sublime/"},{"name":"python","slug":"python","permalink":"https://richardrw.github.io/tags/python/"},{"name":"utf-8","slug":"utf-8","permalink":"https://richardrw.github.io/tags/utf-8/"}]},{"title":"test_my_site","date":"2017-09-16T07:23:04.000Z","path":"2017/09/16/test-my-site/","text":"","tags":[]},{"title":"Hello World","date":"2017-09-16T07:08:10.000Z","path":"2017/09/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]