[{"title":"一个夭折的网站项目","date":"2018-03-04T03:18:42.000Z","path":"2018/03/04/一个夭折的网站项目/","text":"原本预期读完《Flask Web开发》一书后，打算结合之前的大众点评美食爬虫项目做一个网站，预期达到的效果是这样的： 能动态显示图表数据 有博客文章功能，可以根据.md文件生成静态文章 可以推荐各种类美食的Top10（根据某个维度进行排序） 采用material风格设计页面 实际情况 使用materialize做网页前端 使用pyecharts动态展示图表数据 使用flask-flatpage作为静态文章的核心 发现的问题随着项目的推进，越发觉这个网站项目有点“三不像”的味道，即动态显示数据，又想做成一个静态博客，网站主旨很不明确，容易让人分不清这个网站到底是要干啥的，是动态的展示数据分析，还是做美食推荐，还是做静态博客。所以问题就出在这里了，因为没有一个明确的主旨，没有一个明确的展示目的，使得我越做这个项目越难下手，越不想做，越不清楚自己就到底想要干嘛。 吸取教训经过这次失败的教训，才发现原来完整地把一个网站做出来也并非易事，需要考虑方方面面的内容，如网站的主旨、网站的功能等等。通过这次教训，在我往后的项目中，在开始之前，一定要多方面考虑，多渠道地去看别人的网站设计，多看别人的网站源码，了解人家是怎么设计网站的，在开发网站时是怎么思考的。希望在下次的开发中能做的比这次更好。 失败例子的展示图片示例1图片示例2图片示例3图片示例4图片示例5图片示例6","tags":[]},{"title":"面向对象-类-方法","date":"2018-01-20T07:06:31.000Z","path":"2018/01/20/面向对象-类-方法/","text":"1234567891011121314151617181920212223242526272829303132333435class Mori(object): name = &quot;我是类的公有属性&quot; # 公有方法，可以在类的内部调用，也可以在类的外部通过实例对象调用 def fun1(self): print(self.name) print(&quot;我是公有方法&quot;) self.__fun2() # 在类的内部调用私有方法 # 私有方法， 只能在类的内部调用 def fun2(self): print(&quot;我是私有方法“) # 类方法，可以在类的内部和外部调用，也可以通过类名直接调用 @classmethod def classFun(self): print(&quot;我是类方法&quot;) # 静态方法，可以在类的内部和外部调用，也可以通过类名直接调用 @staticmethod def staticFun(): &apos;&apos;&apos;注意，这里因为静态方法定义时不需要形参self，因此如果访问类的成员属性，必须通过类名调用(className.varName或className.__varName) &apos;&apos;&apos; print(Mori.name) print(&quot;我是静态方法&quot;)if __name__ == &apos;__main&apos;__: myClass = Mori() myClass.fun1() # 在类的外部通过实例对象调用公有方法 myClass.__fun2() # 不能执行，因为私有方法不能在类的外部调用 Mori,fun1() # 不能执行，因为公有方法不能被类名直接调用 myClass.classFun() # 类方法可以通过实例对象被调用 Mori.classFun() # 类方法也可以通过类名被直接调用 myClass.staticFun() # 静态方法可以通过实例对象被调用 Mori.staticFun() # 静态方法也可以通过类名被直接调用 总结： 类由成员变量（属性）和成员函数（方法）组成。1.1 成员变量有：公有属性（也叫类属性）和私有属性。1.2 公有属性（类属性）：既可以在类的内部被访问（通过self.varName)，也可以在类的外部被访问（通过instance.varName)，也可以通过类名被直接访问（通过className.varName)。1.3 私有属性： 只能在类的内部被访问（在类中通过self.__varName访问），在类的外部均不能访问（instance.__varName和className.__varName都不能访问）。1.4 获取或更改私有属性，一般通过在类的内部定义方法来达到获取和更改私有属性的作用。1.5 在函数中定义的一般变量是局部变量。 成员函数有：；公有方法、私有方法、类方法和静态方法。2.1 公有方法：可以在类的内部被调用，也可以在类的外部通过实例对象调用，但不能通过类名直接调用。2.2 私有方法：只能在类的内部被调用，在类的外部通过实例对象或类名均不能调用。2.3 类方法：与公有方法类似，但是可以通过类名被直接调用。2.4 静态方法：与类方法类似，也可以通过类名被直接调用。 类方法与静态方法的区别：3.1 定义方法时形参不同。定义类方法时需要self作为形参；但是定义静态方法时不需要self作为形参。（在这环境下，因为静态方法不需要传类实例作为参数，因此在调用成员变量和成员函数时不能通过如self.varName、self.funName这种形式调用，而需要通过类名调用）3.2 加载资源的方式不同。类方法是动态加载资源，需要调用某个资源时才加载；而静态方法是运行时一次性加载所有资源（这也是为什么定义静态方法时不需要self作为形参的原因）。（拓展：因此类方法占用内存小而且速度慢，而静态方法占用内存大而且速度快）3.3 调用成员属性、成员函数的方式不同。类方法通过self.varName的方式调用成员属性；而静态函数则通过className.varName的形式调用成员属性。","tags":[{"name":"Python","slug":"Python","permalink":"https://richardrw.github.io/tags/Python/"},{"name":"类","slug":"类","permalink":"https://richardrw.github.io/tags/类/"},{"name":"面向对象","slug":"面向对象","permalink":"https://richardrw.github.io/tags/面向对象/"}]},{"title":"面向对象-类-属性","date":"2018-01-20T07:05:04.000Z","path":"2018/01/20/面向对象-类-属性/","text":"12345678910111213141516171819202122232425262728293031323334var = ‘global’ # 全局变量 class Ren(object): name = &quot;人&quot; # 公有属性／类属性 high = &quot;一人高&quot; # 公有属性／类属性 wight = &quot;一人重&quot; # 公有属性／类属性 __money = &quot;我有十块钱&quot; # 私有属性 var1 = &quot;我是类属性、公有属性var1&quot; __var2 = &quot;我是类的私有属性__var2&quot; # 公有方法 def run(self): print(self.name) # 在类的内部可以调用公有属性 print(&quot;跑步&quot;) def say(self): lie = &quot;我很欣赏你&quot; # 局部变量 print(self.__money) # 在类的内部可以调用私有属性 print(lie) # 调用局部变量 def fun(self): ‘’‘对象的公有属性、私有属性只有在类实例化成对象时才有 ’‘’ self.var2 = “我是对象的公有属性var2” # 只能通过对象访问，不能通过类名直接访问 self.__var3 = &quot;我是对象的私有属性var3&quot; # 只能通过类内部访问，不能通过类外部访问 var4 = &quot;我是fun函数的局部变量var4&quot; if __name__ == &apos;__main__&apos;: zhangsan = Ren() print(zhangsan.name) # 在类的外部可以调用公有属性 print(Ren.name) # 公有属性也可以通过类名直接被调用（所以公有属性也叫类属性） print(zhangsan.__money) # 不能执行，因为私有属性不能被类的外部访问 print(Ren.__money) # 也不能执行，因为私有属性不能被类的外部访问，只有通过特殊的方法在调试时可以调用 zhangsan.say() # 可以执行，通过say()函数在类的内部调用__money，私有属性只能被类的内部访问 总结： 类由成员变量（属性）和成员函数（方法）组成。1.1 成员变量有：共有公有属性（也叫类属性）和私有属性。1.2 公有属性（类属性）：既可以在类的内部被访问（通过self.varName)，也可以在类的外部被访问（通过instance.varName)，也可以通过类名被直接访问（通过className.varName)。1.3 私有属性： 只能在类的内部被访问（在类中通过self.__varName访问），在类的外部均不能访问（instance.__varName和className.__varName都不能访问）。1.4 获取或更改私有属性，一般通过在类的内部定义方法来达到获取和更改私有属性的作用。1.5 在函数中定义的一般变量是局部变量。","tags":[{"name":"Python","slug":"Python","permalink":"https://richardrw.github.io/tags/Python/"},{"name":"类","slug":"类","permalink":"https://richardrw.github.io/tags/类/"},{"name":"面向对象","slug":"面向对象","permalink":"https://richardrw.github.io/tags/面向对象/"}]},{"title":"2017年结语","date":"2017-12-31T04:05:16.000Z","path":"2017/12/31/2017年结语/","text":"《Flask Web开发——基于Python的Web应用开发实战》已经赶在今年结束之前看完了，笔记也做到了第十四章，后面的章节就不做了，因为最后一部分与开发的关系不大。根据当时的笔记记录，我是从2017年11月13日开始看《Flask Web开发》的，到今天已经是一个半月了。当初在读的时候发现进度有点慢，因为同一章的内容我至少要过三遍。一遍是第一次阅读，一遍是敲代码实现书中案例，一遍是做笔记。三遍下来平均每章要三天才能过完（因为平时只有晚上才有时间），当时也想过不写笔记了，但是想起自己当初想要弄一个《把Flask Web开发读薄系列》，于是就坚持了下来。通过这一个半月以来的学习，对阅读书籍、阅读代码的方式还是有些收获的。 看代码要先有“大局观”看代码时尽量把自己的头抬起来，使自己的眼睛焦点不在一个个单词上。要先有大局观，把整段代码映入眼帘中，浏览个大概，初步判断该段代码要想实现一个什么样的功能，然后再把视野缩小到一个或多个函数段或特定的几行，看看大概的实现逻辑时怎么样的，最后把视野放到几行或一行上，看看调用了什么方法。中间把视野放到函数段这一步可以根据代码量的多少来决定是否循环这一步，直到视野一步一步地缩小到一定小的范围。切记，看一段代码，绝不能像阅读文章那样一行一行地从左往右一个词一个词地去看，因为这样会使你纠结于方法的作用（如果中途碰到了你不懂的方法，你很容易纠结在此，这样也就很难读下去了），总之阅读代码一定要先有“大局观”。 学会异常查找和处理运行代码，总避免不了出现异常。要处理异常，要先学会看异常信息，根据抛出来的异常信息可以先看看最后的信息是什么，是什么错误；然后从最初的地方开始寻找，找出哪个文件先出错了，错误的信息是什么；接着再往下找，找到一下个出错的文件，如果没有，就看看往下的异常信息说了什么，结合最后抛出的异常信息文本，一步一步找到问题所在。 阅读要有耐心不知大家是否有这个现象：一本书，大概前1/4和后1/4会读的很顺很快，中间的1/2往往是最耗时间最耗精力的。很多时候如果没有足够的耐心，当阅读往1/4多一点的时候就会发现进度比之前慢了，已看完的页数的增加速度比之前慢了一大截，由此很容易出现急躁的心情，进而就很难再看下去了。对于这种情况，我的做法很简单：在开始阅读之前告诉自己，这本书我将采用“二八法则”，用20%的时间去阅读前后部分，用80%的时间取阅读中间部分。这样一来就等同于做了阅读时间安排计划以及给了自己心理暗示，到中间阅读进度变缓时前后的“进度差”不会就给心理造成太大的伤害，因为我之前已经初步预估了时间做了安排，这一部分我将花费更多的时间，完全符合预期和计划，可以接受，这样我就可以耐心的继续往下阅读，避免了急躁的心情了。 最后我想分享一些关于人生的想法。这些想法是前天迎春长跑后取朋友的店里完娃娃机得出来的。 一蹴而就是不大现实的，成功是一步步得来的为什么这么说？先来说说故事吧。那天我玩娃娃机的时候，我发现，要想一次就能把娃娃夹出来是不大现实的，你要一步一步地把你想要的那只娃娃一次一次地靠近洞口，当娃娃离洞口比较近时，你的容错率也就变大了，因为你除了一步把娃娃夹到洞口外，还可以即使夹不住也能依靠掉下来的惯性滚到洞口，这样你成功夹到娃娃的概率就大很多。相反，同行的一些朋友，在一台娃娃机夹了4-5次还是失败，就认为这台机器不行，于是换了台机器重新开始，再遇到4-5次夹不到，又换。如此一来，我想成功的概率是最低的，每一台机器你都要重新适应它的“力度”，重新校准自己的操作，这很浪费自我资源（游戏币）。你要懂得一步一步来，就好像打桌球，很多情况下一杆进洞是不大可能的，此时你就要学会“做局”，每一杆打出去，都要达到即使不进洞，也比上次更靠近洞口，那么下一次你成功的机会就更大了。 同理，我想现实世界也是一样的情况，很多时候我们都不能一蹴而就，一步登天，一次就成功，在这种情况下要学会坚持目标，认定“那只你想要的娃娃”，把自己比作娃娃机里的娃娃，让自己一步一步地往“洞口”靠近，如此操作，你成功的概率也就会越来越大。 失败是占多数的，成功是少数的就如娃娃机那样，在你成功夹起娃娃前的那些操作，都是失败的。通过这个例子，我们要看到两点：一是生活中我们大多数情况下都是失败的，不用对自己太苛刻，要学会接纳不成功的自己，放过自己。二是要让失败有点价值。虽然说在夹起娃娃之前的那些操作都是失败的，但它们都失败的有价值，因为从是否能夹到娃娃角度看，这些失败是肯定的，因为它们都夹不出娃娃来；但从是否能“做局”让下次成功概率更大，这些失败很多都是否定的，因为大多数情况下它们都能让你“做局”成功，让你更靠近洞口。所以，尽管人生大多数都是失败的，我们是否应该由着它失败呢？不是的，我们要让失败们都有一些价值，只要能让我们更靠近”洞口“的失败，都不算太失败。 2017年过完今天就结束了，在这一年里，我阅读了哪些书籍？ 《当我谈跑步时 我谈些什么》 《你只是看起来很努力》 《写作这回事——创作生涯回忆录》 《我们仨》 《穷查理宝典》 《Head First Python》 《Python网络数据采集》 《Flask Web开发》 《数据之美》 《HTML、CSS菜鸟教程（网络）》 2017年过去了，我学到了什么？ Git HTML、CSS基本概念 Python爬虫 Flask Web开发 咋一看，2017年收获还是挺充实的。2018年里，要保持阅读习惯，多阅读多学习，对周围事物抱有好奇心和新鲜感，树立终身学习态度。 —— 窗台上的听风者 Richrad 2017年12月31日","tags":[{"name":"2017","slug":"2017","permalink":"https://richardrw.github.io/tags/2017/"},{"name":"总结","slug":"总结","permalink":"https://richardrw.github.io/tags/总结/"}]},{"title":"把《Flask Web开发》读薄系列之第十四章 应用编程接口","date":"2017-12-30T15:32:41.000Z","path":"2017/12/30/把《Flask Web开发》读薄系列之第十四章 应用编程接口/","text":"14.1 REST简介14.1.1 资源就是一切资源是REST架构方式的核心概念。在博客程序中，用户、文章、评论等都是资源。 每个资源都要使用唯一的URL表示。如某一篇文章URL：/api/posts/1234。 某一类资源的集合也要有个URL。如文章集合URL：api/posts/。 API还可以为某一类资源的逻辑子集合定义集合URL。如某一篇文章的所有评论URL：/api/posts/1234/comments/。 注意：请求的URL末端没有/，路由没有/，则不重定向；请求的URL末端没有/，路由有/，则重定向转向末端带/的URL。 14.1.2 请求方法在资源URL上发送请求，使用请求方法表示期望执行的操作。 表14-1 REST架构API中使用的HTTP请求方法 请求方法 目标 说明 状态码 GET 单个资源的URL 获取目标资源 200 GET 资源集合的URL 获取资源的集合（如果服务器实现了分页，就是一页中的资源） 200 POST 资源集合的URL 创建新资源，并将其加入目标集合。服务器为新资源指派URL， 并在响应的Location首部中返回 201 PUT 单个资源的URL 修改一个现有资源。如果客户端能为资源指派URL，还可用来创建新资源 200 DELETE 单个资源的URL 删除一个资源 200 DELETE 资源集合的URL 删除目标集合中的所有资源 200 14.1.3 请求和响应主体请求和响应中Content-Type首部用于指明主体中资源的编码方式。常用的编码方式是JavaScript对象表示法（JSON）和可拓展标记语言（XML）。 14.1.4 版本Web服务的容错能力要比一般的Web程序大，而且还要保证旧版客户端能继续使用（因为有些客服端如手机客户端，没有进行升级，但也要保证其能正常使用）。处理方法是使用版本区分Web服务所处理的URL。例如首次发布的博客Web服务可以通过/api/v1.0/posts/提供文章集合。 14.2 使用Flask提供REST Web服务使用Flask创建REST Web服务很简单，使用route()修饰器及其methods可选参数即可。处理JSON数据也同样简单，通过request.json这个字典获取即可。返回包含JSON的响应只用使用Flask提供的jsonify()辅助函数从Python字典中生成JSON即可。 14.2.1 创建API蓝本API蓝本结构如下： 12345678910|-flasky |-app/ |-api_1_0 # 可选 |-__init__.py |-users.py |-posts.py |-comments.py |-authentication.py |-errors.py |-decorators.py 1. 在app/api/__init__.py中构造API蓝本：12345from flask import Blueprintapi = Blueprint(&apos;api&apos;, __name__)from app.api import authentication, posts, users, comments, errors 2. 在app/__init__.py中注册API蓝本：1234567# ...def create_app(config_name): # ... from app.api import api as api_blueprint app.register_blueprint(api_blueprint, url_prefix=&apos;/api/v1.0&apos;) # ... 14.2.5 资源和JSON的序列化转换3. 在app/models.py中定义把文章、用户转换成JSON格式的序列化字典的方法：123456789101112131415161718192021222324252627class Post(db.Model): # ... def to_json(self): json_psot = &#123; &apos;url&apos;: url_for(&apos;api.get_post&apos;, id=self.id), &apos;body&apos;: self.body, &apos;body_html&apos;: self.body_html, &apos;timestamp&apos;: self.timestamp, &apos;author_url&apos;: url_for(&apos;api.get_user&apos;, id=self.author_id), &apos;comments_url&apos;: url_for(&apos;api.get_post_commnets&apos;, id=self.id), &apos;comment_count&apos;: self.comments.count() &#125; return json_psotclass User(UserMixin, db.Model): # ... def to_json(self): json_user = &#123; &apos;url&apos;: url_for(&apos;api.get_user&apos;, id=self.id), &apos;username&apos;: self.username, &apos;member_since&apos;: self.member_since, &apos;last_seen&apos;: self.last_seen, &apos;posts_url&apos;: url_for(&apos;api.get_user_posts&apos;, id=self.id), &apos;followed_posts_url&apos;: url_for(&apos;api.get_user_followed_posts&apos;, id=self.id), &apos;post_count&apos;: self.posts.count() &#125; return json_user 4. 在app/models.py中定义从JSON格式数据创建博客文章的方法：1234567891011from app.api.exceptions import ValidationError# ...class Post(db.Model): # ... @staticmethod def from_json(json_post): body = json_post.get(&apos;body&apos;) if body is None or body == &apos;&apos;: raise ValidationError(&apos;post does not have a body&apos;) # 抛出异常 return Post(body=body) 5. 在app/exceptions.py中定义ValidationError类：12class ValidationError(ValueError): pass 为了避免在视图函数中编写捕获异常的代码，我们可创建一个全局异常处理程序： 6. 在app/api/errors.py中定义API中ValidationError异常的处理程序：1234# 定义API中ValidationError错误处理程序@api.errorhandler(ValidationError)def validation_error(e): return bad_request(e.args[0]) bad_request方法在第11步中定义。 14.2.6 实现资源端点 &amp; 14.2.7 分页大型资源集合GET请求往往是最简单的，因为它们只返回信息，无需修改信息。 7. 在app/api/posts.py中定义分页博客文章资源的GET请求：1234567891011121314151617181920212223242526272829303132333435from flask import jsonify, request, g, url_for, current_appfrom app import dbfrom app.models import Post, Permissionfrom app.api import apifrom app.api.decorators import permission_requiredfrom app.api.errors import forbidden# 获取分页文章集合@api.route(&apos;/posts/&apos;)def get_posts(): page = request.args.get(&apos;page&apos;, 1, type=int) pagination = Post.query.paginate(page, per_page=current_app.config[&apos;FLASKY_POSTS_PER_PAGE&apos;], error_out=False) posts = pagination.items prev = None if pagination.has_prev: prev = url_for(&apos;api.get_posts&apos;, page=page-1, _external=True) next = None if pagination.has_next: next = url_for(&apos;api.get_posts&apos;, page=page+1, _external=True) return jsonify(&#123; &apos;posts&apos;: [post.to_json() for post in posts], &apos;perv&apos;: prev, &apos;next&apos;: next, &apos;count&apos;: pagination.total &#125;)# 获取某一篇文章@api.route(&apos;/posts/&lt;int:id&gt;&apos;)def get_post(id): post = Post.query.get_or_404(id) return jsonify(post.to_json()) 8. 在app/api/posts.py中定义博客文章资源的POST请求：12345678910# ...@api.route(&apos;/posts/&apos;, methods=[&apos;POST&apos;])@permission_required(Permission.WRITE_ARTICLES)def new_post(): post = Post.from_json(request.json) post.author = g.current_user db.session.add(post) db.session.commit() return jsonify(post.to_json()), 201, &#123;&apos;Location&apos;: url_for(&apos;api.get_post&apos;, id=post.id)&#125; 9. 在app/api/posts.py中定义博客文章资源的PUT请求：12345678910111213# ...@api.route(&apos;/posts/&lt;int:id&gt;&apos;, methods=[&apos;PUT&apos;])@permission_required(Permission.WRITE_ARTICLES)def edit_post(id): post = Post.query.get_or_404(id) if g.current_user != post.author and \\ not g.current_user.can(Permission.ADMINISTER): return forbidden(&apos;Insufficient permissions&apos;) post.body = request.json.get(&apos;body&apos;, post.body) db.session.add(post) db.session.commit() return jsonify(post.to_json()) 从第6-8步中用到了permission_required修饰器，下面看看permission_required修饰器如何定义： 10. 在app/api/decoratiors.py中定义permission_required修饰器：1234567891011121314from functools import wrapsfrom flask import gfrom app.api.errors import forbiddendef permission_required(permission): def decorator(func): @wraps(func) def decorated_function(*args, **kwargs): if not g.current_user.can(permission): return forbidden(&apos;Insufficient permissions&apos;) return func(*args, **kwargs) return decorated_function return decorator 从第6-9步中都用到了app.api.errors.forbidden方法，下面看看app/api/errors.py文件如何定义： 11. 在app/api/errors.py中定义400、401、403状态码的错误处理程序：123456789101112131415161718192021222324from flask import jsonifyfrom app.exceptions import ValidationErrorfrom app.api import api# 无效请求def bad_request(message): response = jsonify(&#123;&apos;error&apos;: &apos;bad request&apos;, &apos;message&apos;: message&#125;) response.status_code = 400 return response# 未登录def unauthorized(message): response = jsonify(&#123;&apos;error&apos;: &apos;unauthorizde&apos;, &apos;message&apos;: message&#125;) response.status_code = 401 return response# 禁止访问def forbidden(message): response = jsonify(&#123;&apos;error&apos;: &apos;forbidden&apos;, &apos;message&apos;: message&#125;) response.status_code = 403 return response 14.2.2 错误处理为统一错误处理程序的响应格式，需要修改app/main/errors.py，使其内容协商。 为所有客户端生成适当响应的一种方法是，在错误处理程序中，根据客户端请求的格式改写响应，这种技术称为内容协商。 12. 在app/main/errors.py中使用HTTP内容协商处理错误：123456789101112131415161718192021222324252627282930313233from flask import render_template, request, jsonifyfrom . import main@main.app_errorhandler(403)def forbidden(e): # 判断请求的首部Accept字段（Werkzeug将其解码为requset.accept_mimetypes）接受哪种响应格式（json或xml） if request.accept_mimetypes.accept_json and \\ not request.accept_mimetypes.accept_html: response = jsonify(&#123;&apos;error&apos;: &apos;forbidden&apos;&#125;) response.status_code = 403 return response return render_template(&apos;403.html&apos;), 403@main.app_errorhandler(404)def page_not_found(e): if request.accept_mimetypes.accept_json and \\ not request.accept_mimetypes.accept_html: response = jsonify(&#123;&apos;error&apos;: &apos;not found&apos;&#125;) response.status_code = 404 return response return render_template(&apos;404.html&apos;), 404@main.app_errorhandler(500)def internal_server_error(e): if request.accept_mimetypes.accept_json and \\ not request.accept_mimetypes.accept_html: response = jsonify(&#123;&apos;error&apos;: &apos;internal server error&apos;&#125;) response.status_code = 500 return response return render_template(&apos;500.html&apos;), 500 该例的错误处理程序会检查Accept请求首部（Werkzeug将其解码为requset.accept_mimetypes），根据首部的值决定客户端期望接受的响应格式（JSON或XML）。浏览器一般不限制响应的格式，所以只为只接受JSON而不接受HTML格式的客户端生成JSON格式响应。 表14-2 API返回的常见HTTP状态码 状态码 名称 说明 200 OK（成功） 请求成功完成 201 Created（已创建） 请求成功完成并创建了一个新资源 400 Bad request（坏请求） 请求不可用或不一致 401 Unauthorized（未授权） 请求未包含认证信息 403 Forbidden（禁止） 请求中发送的认证密令无权访问目标 404 Notfound（未找到） URL对应的资源不存在 405 Method not allowed（不允许使用的方法 指定资源不支持请求使用的方法 500 Internal server error（内部服务器错误） 处理请求的过程中发生意外错误 14.2.3 使用Flask-HTTPAuth认证用户 &amp; 14.2.4 基于令牌的认证和普通Web程序一样，Web服务也需要保护信息，确认未经授权的用户无法访问。为此，RIA必须询问用户的登录密令，并将其传给服务器验证。 REST Web服务的特征之一就是无状态，即服务器在两次请求之间不能“记住”客户端的任何信息，客户端发出的请求必须包含所有信息，因此所有请求都必须包含用户密令。 默认情况下，Flask会把会话保存在客户端的cookie中，因此服务器没有保存任何用户相关信息，都转交给客户端保存了。这种实现方式看起来遵守REST架构的无状态要求，但在REST Web服务中使用cookie有点不现实，因为Web浏览器之外的客户端很难提供对cookie的支持。 又因为REST架构基于HTTP协议，所以发送密令的最佳方式是使用HTTP认证，基本认证和摘要认证都可以。在HTTP认证中，用户密令包含在请求的Authorization首部中。 每次请求时，客户端都要发送认证密令，为了避免总是发送敏感信息（认证密令），我们可以提供一种基于令牌的认证方案：客户端（1）先把登录密令发送给一个特殊的URL，从而生成认证令牌；（2）客户端获得令牌后，就可以用令牌代替密令认证请求。 13. 在app/api/authentication.py中初始化Flask-HTTPAuth，并支持令牌验证回调：123456789101112131415161718192021222324252627from flask import g, jsonifyfrom flask_httpauth import HTTPBasicAuthfrom app.models import Userfrom app.api import apifrom app.api.errors import unauthorized, forbiddenauth = HTTPBasicAuth()@auth.verify_passworddef verify_password(email_or_token, password): # （1） if email_or_token == &apos;&apos;: return False # （2） if password == &apos;&apos;: g.current_user = User.verify_auth_token(email_or_token) g.token_used = True return g.current_user is not None # （3） user = User.query.filter_by(email=email_or_token).first() if not user: return False g.current_user = user g.token_used = False return user.verify_password(password) # 调用User模型中的verify_password方法 Flask-HTTPAuth提供了一个便利的包（HTTPBasicAuth().verify_password），可以把协议的细节隐藏在修饰器中，类似于Flask-Login提供的login_required修饰器。 由于这种用户认证方法只在API蓝本中使用，所以Flask-HTTPAuth只在蓝本包中初始化，而不像其他扩展那样在程序包中初始化。 验证回调函数把通过认证的用户保存在Flask的全局对象g中，如此一来，视图函数就能进行访问。 该例中，第一个参数是电子邮件或认证令牌。（1）如果这个参数为空，则返回False；（2）如果password参数为空，就假定email_or_token参数是认证令牌，按照令牌的方式进行认证；（3）如果两个参数都不为空，就假定使用了电子邮件和密码进行认证。 为了让视图函数能区分这两种认证方法（电子邮件+密码、认证令牌），我们添加了g.token_used变量。 14. 在app/api/authentication.py中定义生成认证令牌的路由：123456789# ...# 定义用于获取密令的路由@api.route(&apos;/tokens/&apos;, methods=[&apos;POST&apos;])def get_token(): if g.current_user.is_anonymous or g.token_used: return unauthorized(&apos;Invalid credentials&apos;) return jsonify(&#123;&apos;token&apos;: g.current_user.generate_auth_token(expiration=3600), &apos;expiration&apos;: 3600&#125;) 15. 在app/api/authentication.py中定义Flask-HTTPAuth错误处理程序：12345# ...@auth.error_handlerdef auth_error(): return unauthorized(&apos;Invalid credentials&apos;) 16. 在app/api/authentication.py中使得API蓝本所有路由在每次请求前都进行认证：1234567# ...@api.before_request@auth.login_requireddef before_request(): if not g.current_user.is_anonymous and \\ not g.current_user.confirmed: # 判断该用户是否已经确认账户 return forbidden(&apos;Unconfirmed account&apos;) 在第13步中使用到了User.verify_auth_token方法和第14步中使用到了User.generate_auth_token方法，其定义如下： 17. 在app/models.py中定义基于令牌的认证：123456789101112131415class User(UserMixin, db.Model): # ... def generate_auth_token(self, exporation): s = Serializer(current_app.confir[&apos;SECRET_KEY&apos;], expires_in=exporation) return s.dumps(&#123;&apos;id&apos;: self.id&#125;).decode(&apos;utf-8&apos;) @staticmethod def verify_auth_token(token): s = Serializer(current_app.config[&apos;SECRET_KEY&apos;]) try: data = s.loads(token) except: return None return User.query.get(data[&apos;id&apos;]) 14.2.8 使用HTTPie测试Web服务1. 安装HTTPie：1(venv) $ pip install httpie 2. GET请求可按照如下方式发起：123456789101112131415(venv) $ http --json --auth &lt;email&gt;:&lt;password&gt; GET http://127.0.0.1:5000/api/v1.0/postsHTTP/1.0 200 OKContent-Length: 7018Content-Type: application/jsonDate: Sun, 22 Dec 2013 08:11:24 GMTServer: Werkzeug/0.9.4 python/3.6&#123; &quot;posts&quot;: [ ... ], &quot;prev&quot;: null, &quot;next&quot;: &quot;http://127.0.0.1:5000/api/v1.0/posts/?page=2&quot;, &quot;count&quot;: 150&#125; 如果API允许匿名用户访问的话，可以这个发起请求：1(venv) $ http --json --auth : GET http://127.0.0.1:5000/api/v1.0/posts/ 3. 发送POST请求创建一篇新博客文章：1234(venv) $ http --auth &lt;email&gt;:&lt;password&gt; --json POST http://127.0.0.1:5000/api/v1.0/posts/ &quot;body=I&apos;m adding a post from the *command line*.&quot;HTTP/1.0 201 CREATEDContent-Length :360# ... 4. 要想使用认证令牌，可向/api/v1.0/token发送请求：1234567891011(venv) $ http --auth &lt;email&gt;:&lt;password&gt; --json GET http://127.0.0.1:5000/api/v1.0/tokenHTTP/1.0 200 OKContent-Lenght: 162Content-Type: application/jsonDate: Sat, 04 Jan 2017 08:38:47 GMTServer: Werkzeug/0.9.4 Python/3.3.3&#123; &quot;expiration&quot;: 3600, &quot;token&quot;: &quot;eqJpYXQiOjex..............iSFMy...&quot;&#125; 5. 在接下来的1小时内，可以用这个令牌访问API，请求时要和空密码一起发送：1(venv) $ http --json --auth eyJpYXQi.....ISFMy...: GET http://127.0.0.1:5000/api/v1.0/posts/ 令牌过期后，请求会返回401错误，表示需要重新获取令牌。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第十三章 用户评论","date":"2017-12-30T15:31:14.000Z","path":"2017/12/30/把《Flask Web开发》读薄系列之第十三章 用户评论/","text":"13.1 评论在数据库中的表示从psots表到comments表是一对多关系，从users表到comments表也是一对多关系。 1. 在app/models.py中定义Comment模型：123456789101112131415161718192021# ...class Comment(db.Model): __tablename__ = &apos;comments&apos; id = db.Column(db.Integer, primary_key=True) body = db.Column(db.Text) body_html = db.Column(db.Text) timestamp = db.Column(db.DateTime, index=True, default=datetime.utcnow) disabled = db.Column(db.Boolean) # 协管员通过该字段查禁不当评论 author_id = db.Column(db.Integer, db.ForeignKey(&apos;users.id&apos;)) post_is = db.Column(db.Integer, db.ForeignKey(&apos;posts.id&apos;)) @staticmethod def on_changed_body(target, value, oldvalue, initiator): allowed_tags = [&apos;a&apos;, &apos;abbr&apos;, &apos;acronym&apos;, &apos;b&apos;, &apos;code&apos;, &apos;em&apos;, &apos;i&apos;, &apos;strong&apos;] # 将Markdown源文本转换为合乎需要的HTNL文本 target.body_html = bleach.linkify(bleach.clean( markdown(value, output_format=&apos;html&apos;), tags=allowed_tags, strip=True))db.event.listen(Comment.body, &apos;set&apos;, Comment.on_changed_body) 2. 在app/models.py中定义users表和posts表与comennts表的一对多关系：12345678910# ...class User(UserMixin, db.Model): # ... comments = db.relationship(&apos;Comment&apos;, backref=&apos;author&apos;, lazy=&apos;dynamic&apos;) class Post(db.Model): # ... comments = db.relationship(&apos;Comment&apos;, backref=&apos;post&apos;, layz=&apos;dynamic&apos;) 13.2 显示评论框和提交评论1. 在app/main/forms.py中定义评论表单：12345# ...class CommentForm(FlaskForm): body = StringField(&apos;Enter your comment&apos;, validators=[DataRequired()]) submit = SubmitField(&apos;Submit&apos;) 2. 在app/main/views.py中定义在文章页显示评论的路由：12345678910111213141516171819202122@main.route(&apos;/post/&lt;int:id&gt;&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def post(id): post = Post.query.get_or_404(id) form = CommentForm() if form.validate_on_submit(): comment = Comment(body=form.body.data, post=post, author=current_user._get_current_object()) db.session.add(comment) db.session.commit() flash(&apos;Your comment has been published.&apos;) return redirect(url_for(&apos;main.post&apos;, id=post.id, page=-1)) page = request.args.get(&apos;page&apos;, 1, type=int) if page == -1: # 用总评论数除以每页显示数量再加1获得真正需要请求的页码，使得提交评论后能转到看到自己评论的页面 page = (post.comments.count() - 1) // current_app.config[&apos;FLASKY_COMMENTS_PER_PAGE&apos;] + 1 pagination = post.comments.order_by(Comment.timestamp.asc()).paginate( page, per_page=current_app.config[&apos;FLASKY_COMMENTS_PER_PAGE&apos;], error_out=False) comments = pagination.items return render_template(&apos;post.html&apos;, posts=[post], form=form, comments=comments, pagination=pagination) 注意： 和Post模型一样，评论的author字段不能直接设为current_user，因为这个变量是上下文代理对象，要使用current_user._get_current_object()获取真正的用户对象。 url_for()函数的page参数设为-1，用来请求最后一页，以达到提交评论后转到可以看到自己刚才发表的评论的页面。真正的页码通过(用总评论数除以每页显示数量)再加1获得。 3. 在app/templates/_post.html中添加到博客文章评论的链接：1234567# ...&lt;a href=&quot;&#123;&#123; url_for(&apos;main.post&apos;, id=post.id)&#125;&#125;#comments&quot;&gt; &lt;span class=&quot;label label-primary&quot;&gt; &#123;&#123; post.comments.count() &#125;&#125; Comments &lt;/span&gt;&lt;/a&gt; 注意：url_for()函数后面加了一个#comments后缀，这个后缀称为URL片段，其作用是用于指定加载页面后滚动条所在的初始位置。该例中，Web浏览器会寻找id为comments的元素并滚动页面。 13.3 管理评论1. 在app/templates/base.html中在顶端导航条添加管理评论的链接：12345# ...&#123;% if current_user.can(Permission.MODERATE_COMMENT) %&#125;&lt;li&gt;&lt;a href=&quot;&#123;&#123; url_for(&apos;main.moderate&apos;) &#125;&#125;&quot;&gt;Moderate&lt;/a&gt;&lt;/li&gt;&#123;% endif %&#125;# ... 2. 在app/main/views.py中定义管理评论的路由（用于显示所有评论）：12345678910111213# ...@main.route(&apos;/moderate&apos;)@login_required@permission_required(Permission.MODERATE_COMMENT)def moderate(): page = request.args.get(&apos;page&apos;, 1, type=int) pagination =Comment.query.order_by(Comment.timestamp.desc()).paginate( page, per_page=current_app.config[&apos;FLASKY_COMMENTS_PER_PAGE&apos;], error_out=False) comments = pagination.items return render_template(&apos;moderate.html&apos;, comments=comments, pagination=pagination, page=page) 3. 在app/templates/moderate.html中定义管理评论的页面模板：1234567891011121314151617&#123;% extends &quot;base.html&quot; %&#125;&#123;% import &quot;_macros.html&quot; as macros %&#125;&#123;% block title %&#125;Flasky - Comment Moderation&#123;% endblock %&#125;&#123;% block page_content %&#125;&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Comment Moderation&lt;/h1&gt;&lt;/div&gt;&#123;% set moderate = True %&#125;&#123;% include &apos;_comments.html&apos; %&#125;&#123;% if pagination %&#125;&lt;div class=&quot;pagination&quot;&gt; &#123;&#123; macros.pagination_widget(pagination, &apos;.moderate&apos;) &#125;&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% endblock %&#125; 模板中通过Jinja2提供的set指令定义了一个模板变量moderate，并将其值设为True，这个变量的作用是决定在_comments.html模板中是否渲染管理评论功能。 4. 在app/templates/_comments.html中定义渲染评论内容的模板：123456789101112131415161718192021222324252627282930313233343536&lt;ul class=&quot;comments&quot;&gt; &#123;% for comment in comments %&#125; &lt;li class=&quot;comment&quot;&gt; &lt;div class=&quot;comment-thumbnail&quot;&gt; &lt;a href=&quot;&#123;&#123; url_for(&apos;main.user&apos;, username=comment.author.username) &#125;&#125;&quot;&gt; &lt;img class=&quot;img-rounded profile-thumbnail&quot; src=&quot;&#123;&#123; comment.author.gravatar(size=40) &#125;&#125;&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;comment-content&quot;&gt; &lt;div class=&quot;comment-date&quot;&gt;&#123;&#123; moment(comment.timestamp).fromNow() &#125;&#125;&lt;/div&gt; &lt;div class=&quot;comment-author&quot;&gt;&lt;a href=&quot;&#123;&#123; url_for(&apos;main.user&apos;, username=comment.author.username) &#125;&#125;&quot;&gt;&#123;&#123; comment.author.username &#125;&#125;&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;comment-body&quot;&gt; &#123;% if comment.disabled %&#125; # 不当的评论用以下内容显示 &lt;p&gt;&lt;i&gt;This comment has been disabled by a moderator.&lt;/i&gt;&lt;/p&gt; &#123;% endif %&#125; &#123;% if moderate or not comment.disabled %&#125; &#123;% if comment.body_html %&#125; &#123;&#123; comment.body_html | safe &#125;&#125; &#123;% else %&#125; &#123;&#123; comment.body &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &lt;/div&gt; &#123;% if moderate %&#125; &lt;br&gt; &#123;% if comment.disabled %&#125; &lt;a class=&quot;btn btn-default btn-xs&quot; href=&quot;&#123;&#123; url_for(&apos;main.moderate_enable&apos;, id=comment.id, page=page) &#125;&#125;&quot;&gt;Enable&lt;/a&gt; &#123;% else %&#125; &lt;a class=&quot;btn btn-danger btn-xs&quot; href=&quot;&#123;&#123; url_for(&apos;main.moderate_disable&apos;, id=comment.id, page=page) &#125;&#125;&quot;&gt;Disable&lt;/a&gt; &#123;% endif %&#125; &#123;% endif %&#125; &lt;/div&gt; &lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; 5. 在app/main/views.py中定义显示评论、禁用评论的路由：1234567891011121314151617181920# 显示评论@main.route(&apos;/moderate/enable/&lt;int:id&gt;&apos;) # 评论的id@login_required@permission_required(Permission.MODERATE_COMMENT)def moderate_enable(id): comment = Comment.query.get_or_404(id) comment.disabled = False db.session.add(comment) return redirect(url_for(&apos;main.moderate&apos;, page=request.args.get(&apos;page&apos;, 1, type=int)))# 禁用评论@main.route(&apos;/moderate/disable/&lt;int:id&gt;&apos;) # 评论的id@login_required@permission_required(Permission.MODERATE_COMMENT)def moderate_disable(id): comment = Comment.query.get_or_404(id) comment.disabled = True db.session.add(comment) return redirect(url_for(&apos;main.moderate&apos;, page=request.args.get(&apos;page&apos;, 1, type=int))) redirect()函数中设置了page参数，如果之前的请求中指定了page参数，则会将其转入重定向中。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第十二章 关注者","date":"2017-12-30T15:30:03.000Z","path":"2017/12/30/把《Flask Web开发》读薄系列之第十二章 关注者/","text":"12.1 再论数据库关系一对多关系是最常用的关系，要实现这种关系，要在“多”这一侧加一个外键，指向“一”这一侧联接的记录。一对一关系是简化版的一对多关系，限制“多”这一侧最多只能有一个记录。 12.1.1 多对多关系一对多关系、多对一关系和一对一关系至少都有一侧是单个实体，所以记录之间的联系通过外键实现，让外键指向这个实体。而多对多关系就不能这么多，因为例如你不能在学生表中加入一个指向课程的外键（因为一个学生可以选择多个课程，一个外键不够用）。因此需要添加一张关联表，使多对多关系分解成原表和关联表之间的两个一对多关系。如： 1234567891011121314151617registrations = db.Table(&apos;registration&apos;, db.Column(&apos;student_id&apos;, db.Integer, db.ForeignKey(&apos;students.id&apos;)), db.Column(&apos;class_id&apos;, db.Integer, db.ForeignKey(&apos;classes_id&apos;))) class Student(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String) classes = db.relationship(&apos;Class&apos;, secondary=registrations, backref=db.backref(&apos;students&apos;, lazy=&apos;dynamic&apos;) lazy=&apos;dynamic&apos;)class Class(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String) 注意： 多对多关系仍使用定义一对多关系的db.relationship()方法进行定义，但在多对多关系中，必须把secondary参数设为关联表。 多对多关系可以在任何一侧定义，backref参数为处理好关系的另一侧。 关联表registrations是一个简单的表，不是模型。SQLALchemy会自动接管这个表。 现在假设学生是s，课程是c，学生s选择课程c的代码为： 12&gt;&gt;&gt;s.classes.append(c)&gt;&gt;&gt;db.session.add(s) 学生s退选课程c的代码为： 12&gt;&gt;&gt;s.classes.remove(c)&gt;&gt;&gt;db.session.add(s) 12.1.2 自引用关系多对多关系可用于实现用户之间的关注。但现在存在一个问题：在学生和课程的例子中，关联表联接的是两个明确的实体。而表示用户关注其他用户时，只用用户一个实体，没有第二个实体（另一侧不是其他表，而是在同一张表中）。 自引用关系：如果关系中的两侧都在同一个表中，那这个关系称为自引用关系。 12.1.3 高级多对多关系使用12.1.2介绍的自引用关系可在数据库中表示用户之间的关注，但存在一个限制：使用多对多关系，通常需要存储所联两个实体之间的额外信息（如关注时间等），而这种额外信息只能存储在关联表中（因为如果存在实体表中，就会出现12.1.1中所说的外键不够用类似的情况）。但是现在关联表完全由SQLALchemy接管（此时关联表只是一个简单表，不是模型）。因此我们可以把关联表定义为模型（提升关联表的地位），使其变成程序可访问的。 1. 在app/models.py中定义关联表模型：1234567class Follow(db.Models): __tablename__ = &apos;follows&apos; # 关注他人的人id follower_id = db.Column(db.Integer, db.ForeignKey(&apos;users.id&apos;), primary_key=True) # 被别人关注的人id followed_id = db.Column(db.Integer, db.ForeignKey(&apos;users.id&apos;), primary_key=True) timestamp = db.Column(db.DateTime, default=dbatetime.utcnow) 2. 在app/models.py中定义两个一对多关系从而实现多对多关系（因为是自引用关系，所以关系两侧都在同一侧定义）：1234567891011121314class User(UserMixin, db.Model): # ... # 已关注 followed = db.relationship(&apos;Follow&apos;, # 和前面的12.1.1不同，这里是关联表，而不是“另一侧实体” foreign_keys=[Follow.follower_id], # 为消除外键间的歧义，必须明确指定用哪个外键，因为关系表中有两个外键 backref=db.backref(&apos;follower&apos;, lazy=&apos;joined&apos;), # db.backref()参数并不是指定这两个关系之间的引用关系，而是回引Follow模型。follower是关注他人的人 lazy=&apos;dynamic&apos;, cascade=&apos;all, delete-orphan&apos;) # 关注user的人 followers = db.relationship(&apos;Follow&apos;, foreign_keys=[Follow.followed_id], backref=db.backref(&apos;followed&apos;, lazy=&apos;joined&apos;), # followed是被别人关注的人 lazy=&apos;dynamic&apos;, cascade=&apos;all, delete-orphan&apos;) 注意： followed和followers关系都定义为单独的一对多关系（User对Follow）。 foreign_keys参数必须指定外键以消除外键间的歧义。 db.backref()第一个参数并不是指定这两个关系（User和Follow）之间的引用关系，而是回引Follow模型。 db.backref()中lazy参数设为joined，可以实现立即从联结查询中加载相关对象。如：某个用户关注了100个用户，调用user.followed.all()后会返回一个列表，其中包含100个Follow实例，每个Follow实例的follower和followed回引属性都指向相应的用户。 cascade参数用于设置在父对象上执行的操作会对相关对象有什么影响。当设为&#39;all, delete-orphan&#39;时表示启用所有默认层叠选项，而且还有删除孤儿记录。（可理解为父对象干什么，相关的对象就干什么） 3. 在app/models.py中定义一些关注关系的辅助方法：123456789101112131415161718192021class User(UserMixin, db.Model): # ... # 实现关注他人功能 def follow(self, user): if not slef.is_following(user): f = Follow(follower=self, followed=user) db.session.add(f) # 实现取消关注功能 def unfollow(self, user): f = self.followed.filter_by(followed_id=user.id).first() if f: db.session.delete(f) # 删除Follow实例 # 实现查询是否关注了他人的功能 def is_following(self, user): return self.followed.filter_by(followed_id=user.id).first() is not None # 实现查询是否被他人关注的功能 def is_followed_by(self, user): return self.followers.filter_by(follower_id=user.id).first() is not None 在follow()函数中无需设定timestamp字段，因为在第一步中已经为其设置了默认值。 12.2 在资料页中显示关注者1. 在app/templates/user.html中添加在用户个人资料页上的关注信息：1234567891011121314151617# ...&lt;div class=&quot;profile-header&quot;&gt;&lt;p&gt; &#123;% if current_user.can(Permission.FOLLOW) and user != current_user %&#125; &#123;% if not current_user.is_following(user) %&#125; &lt;a href=&quot;&#123;&#123; url_for(&apos;main.follow&apos;, username=user.username) &#125;&#125;&quot; class=&quot;btn btn-primary&quot;&gt;Follow&lt;/a&gt; &#123;% else %&#125; &lt;a href=&quot;&#123;&#123; url_for(&apos;main.unfollow&apos;, username=user.username) &#125;&#125;&quot; class=&quot;btn btn-default&quot;&gt;Unfollow&lt;/a&gt; &#123;% endif %&#125; &#123;% endif %&#125; &lt;a href=&quot;&#123;&#123; url_for(&apos;main.followers&apos;, username=user.username) &#125;&#125;&quot;&gt;Followers: &lt;span class=&quot;badge&quot;&gt;&#123;&#123; user.followers.count() - 1 &#125;&#125;&lt;/span&gt;&lt;/a&gt; &lt;a href=&quot;&#123;&#123; url_for(&apos;main.followed_by&apos;, username=user.username) &#125;&#125;&quot;&gt;Following: &lt;span class=&quot;badge&quot;&gt;&#123;&#123; user.followed.count() - 1 &#125;&#125;&lt;/span&gt;&lt;/a&gt; &#123;% if current_user.is_authenticated and user != current_user and user.is_following(current_user) %&#125; | &lt;span class=&quot;label label-default&quot;&gt;Follows you&lt;/span&gt; &#123;% endif %&#125; &lt;/p&gt;# ... 2. 在app/main/views.py中定义关注按钮对应的路由：12345678910111213141516171819from decorators import permission_required# ...@main.route(&apos;/follow/&lt;username&gt;&apos;)@login_required@permission_required(Permission.Follow)def follow(username): user = User.query.filter_by(username=username).first() if user is None: flash(&apos;Invalid user.&apos;) return redirect(url_for(&apos;main.index&apos;)) # 判断是否已经关注了user if current_user.is_following(user): flash(&apos;You are already following this user.&apos;) return redirect(url_for(&apos;main.user&apos;, username=username)) # 调用User模型中的follow方法 current_user.follow(user) flash(&apos;You are now following &#123;&#125;&apos;.format(username)) return redirect(url_for(&apos;main.user&apos;, username=username)) 3. 在app/main/views.py中定义用于展示关注了你的人（粉丝）路由：123456789101112131415161718# ...@main.route(&apos;/followers/&lt;username&gt;&apos;)def followers(username): user = User.query.filter_by(username=username).first() if user is None: flash(&apos;Invalid user.&apos;) return redirect(url_for(&apos;main.index&apos;)) page = request.args.get(&apos;page&apos;, 1, type=int) pagination = user.followers.pagination(page, per_page=current_app.config[&apos;FLASKY_FOLLOWERS_PER_PAGE&apos;], error_out=False) # 列表表达式，pagination.items返回的是所有Follow实例，通过item.follower获取对应的用户（User实例） follows = [&#123;&apos;user&apos;: item.follower, &apos;timestamp&apos;: item.timestamp&#125; for item in pagination.items] return render_template(&apos;followers.html&apos;, user=user, title=&apos;Followers of&apos;, endpoint=&apos;main.followers&apos;, pagination=pagination, follows=follows) 4. 在app/main/views.py中定义用于展示你关注了谁的路由：123456789101112131415161718# ...@main.route(&apos;/followers/&lt;username&gt;&apos;)def followers(username): user = User.query.filter_by(username=username).first() if user is None: flash(&apos;Invalid user.&apos;) return redirect(url_for(&apos;main.index&apos;)) page = request.args.get(&apos;page&apos;, 1, type=int) pagination = user.followed.pagination(page, per_page=current_app.config[&apos;FLASKY_FOLLOWERS_PER_PAGE&apos;], error_out=False) # 列表表达式，pagination.items返回的是所有Follow实例，通过item.followed获取对应的用户（User实例） follows = [&#123;&apos;user&apos;: item.followed, &apos;timestamp&apos;: item.timestamp&#125; for item in pagination.items] return render_template(&apos;followers.html&apos;, user=user, title=&apos;Followed by&apos;, endpoint=&apos;main.followers&apos;, pagination=pagination, follows=follows) 这个路由跟第三步中定义的followers路由一样，唯一的区别是followed_by中第10行和第14行通过followed获取相关对象。 followers和followed_by都使用同一个模板followers.html。 5. 在app/templates/followers.html中添加显示已关注的人和粉丝的模板：123456789101112131415161718192021222324252627282930&#123;% extends &quot;base.html&quot; %&#125;&#123;% import &quot;_macros.html&quot; as macros %&#125;&#123;% block title %&#125;Flasky - &#123;&#123; title &#125;&#125; &#123;&#123; user.username &#125;&#125;&#123;% endblock %&#125;&#123;% block page_content %&#125;&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;&#123;&#123; title &#125;&#125; &#123;&#123; user.username &#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;table class=&quot;table table-hover followers&quot;&gt; &lt;thead&gt;&lt;tr&gt;&lt;th&gt;User&lt;/th&gt;&lt;th&gt;Since&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt; &#123;% for follow in follows %&#125; &lt;!--读取的是follows列表中的每一个字典，然后通过follow.user获取字典中&apos;user&apos;键对应的值--&gt; &#123;% if follow.user != user %&#125; &lt;tr&gt; &lt;td&gt; &lt;a href=&quot;&#123;&#123; url_for(&apos;main.user&apos;, username=follow.user.username) &#125;&#125;&quot;&gt; &lt;img class=&quot;img-rounded&quot; src=&quot;&#123;&#123; follow.user.gravatar(size=32) &#125;&#125;&quot;&gt; &#123;&#123; follow.user.username &#125;&#125; &lt;/a&gt; &lt;/td&gt; &lt;td&gt;&#123;&#123; moment(follow.timestamp).format(&apos;L&apos;) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endif %&#125; &#123;% endfor %&#125;&lt;/table&gt;&lt;div class=&quot;pagination&quot;&gt; &#123;&#123; macros.pagination_widget(pagination, endpoint, username=user.username) &#125;&#125;&lt;/div&gt;&#123;% endblock %&#125; 注意：for follow in follows获取的是follows列表中的每一个字典，然后通过follow.user来获取其对应的User实例（因为’user’键对应的值是第四步中的item.followed）。 12.3 使用数据库联结查询所关注用户的文章1. 在app/models.py中使用联结查询获取user所关注的用户发布的文章：12345678910# ...class User(UserMixin, db.Model): # ... # 获取已关注的人发布的文章 @property def followed_posts(self): return Post.query.join(Follow, Follow.followed_id == Post.author_id)\\ # 被关注的人id==作者id .filter_by(Follower_id == self.id) # 关注别人的人id==self.id 注意：followed_posts()方法定义为属性，因此调用时无需加()。 12.4 在首页显示所关注用户发布的文章1. 在app/main/views.py中定义用于显示所有博客文章或只显示所关注用户发布的文章的路由：123456789101112131415161718192021# ...@main.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]def index(): # ... show_followed = False if current_user.is_authenticated: # 从请求的cookies中获取show_followed的值，并转换为布尔值 show_followed = bool(request.cookies.get(&apos;show_followed&apos;, &apos;&apos;)) if show_followed: # 获取所关注用户发布的文章 query = current_user.followed_posts else: # 获取全部文章 query = Post.query pagination = query.order_by(Post.timestamp.des()).paginate(page, per_page=current_app.config[&apos;FLASKY_POSTS_PER_PAGE&apos;], error_out=False) psots = pagination.itmes return render_template(&apos;index.html&apos;, form=form, posts=posts, show_followed=show_followed, pagination=pagination) 决定显示所有博客文章，还是只显示所关注用户发布的文章，取决于存储在cookies中show_followed字段的值，如果其值是非空字符串，即show_followed变量为True，则只显示所关注用户发布的文章。 cookie以request.cookies字典的形式存储在请求对象中。（具体如何实现请看第二步） 2. 在app/main/views.py中为请求对象添加show_followed的cookies值：12345678910111213141516171819from flask import make_response# ...@main.route(&apos;/all&apos;)@login_requireddef show_all(): # 这个路由重定向到首页 resp = make_response(redirect(url_for(&apos;main.index&apos;))) # 在resp中添加cookie，并设适当的值 resp.set_cookie(&apos;show_followed&apos;, &apos;&apos;, max_age=30*24*60*60) return resp @main.route(&apos;/followed&apos;)@login_requireddef show_followed(): resp = make_response(redirect(url_for(&apos;main.index&apos;))) resp.set_cookie(&apos;show_followed&apos;, &apos;1&apos;, max_age=30*24*60*60) return resp 注意：set_cookie()函数的前两个参数分别是cookie名和值。可选参数max_age设置cookie的过期时间，单位为秒，如果不指定max_age参数，则浏览器关闭后cookie就会过期。 3. 在app/models.py中在创建新用户时将用户设为自己的关注者（即自己关注自己）：有时希望在查看所关注用户发布的文章中，也能看到自己的动态，此时就需要将自己设为自己的关注者（自己关注自己） 12345678# ...class User(UserMixin, db.Model): # ... def __init__(self, **kwargs): # ... self.follow(self) 4. 在app/models.py中将之前已经创建的用户设为自己的关注者：创建函数来更新数据库，这一技术经常用来更新已部署的程序。 123456789101112# ...class User(UserMixin, db.Model): # ... @staticmethod def add_self_follows(): for user in User.query.all(): if not user.is_following(user): user.follow(user) db.session.add(user) db.session.commit() 最后，注意：因为将用户设为自己的关注者，因此在渲染模板时，已关注的人的数量和粉丝的数量需要减去1（即12.2中第一步中的第11行和第12行）。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第十一章 博客文章","date":"2017-12-30T11:09:11.000Z","path":"2017/12/30/把《Flask Web开发》读薄系列之第十一章 博客文章/","text":"11.1 提交和显示博客文章1. 在app/models.py中定义文章模型：1234567891011121314# ...class Post(db.Model): __tablename__ = &apos;posts&apos; id = db.Column(db.Integer, primary_key=True) body = db.Column(db.Text) body_html = db.Column(db.Text) timestamp = db.Column(db.DateTime, index=True, default=datetime.utcnow()) author_id = db.Column(db.Integer, db.ForeignKey(&apos;users.id&apos;))class User(UserMixin, db.Model): # ... posts = db.relationship(&apos;Post&apos;, backref=&apos;author&apos;, lazy=&apos;dynamic&apos;) 说明： 为了使文章支持Markdown，用body字段存储markdown源文本，用body_html字段存储markdown源文本转换成的HTML文本。（具体如何将markdown转换成HTML，可见第10步.） 2. 在app/main/forms.py中定义文章表单：123456from flask_pagedown import PageDownField# ...class PostForm(FlaskForm): body = PageDownField(&quot;What&apos;s your mind?&quot;, validators=[DataRequired()]) submit = SubmitField(&apos;Submit&apos;) 3. 在app/main/views.py中定义处理博客文章的主页路由：123456789101112131415161718from app.models import Post# ...@main.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def index(): form = PostForm() if current_user.can(Permission.WRITE_ARTICLES) and form.validate_on_submit(): post = Post(body=form.body.data, author=current_user._get_current_object()) # 赋予当前用户对象 db.session.add(post) db.session.commit() # 当设置了请求结束后自动提交数据库变化时，该行可省略 return redirect(url_for(&apos;main.index&apos;)) page = request.args.get(&apos;page&apos;, 1, type=int) pagination = Post.query.order_by(Post.timestamp.desc()).paginate( page, per_page=current_app.config[&apos;FLASKY_POSTS_PER_PAGE&apos;], error_out=False) posts = pagination.items # 获取当前分页对象的所有记录 return render_template(&apos;index.html&apos;, form=form, posts=posts, pagination=pagination) current_user是Flask-Login提供的，其表现类似用户对象，但实际上是一个轻度包装而由包含真正用户对象的对象。数据库需要获取真正的用户对象，所以需调用_get_current_objet()方法获取。 客户端通过URL请求的页码数通过requset.args.get()方法获取，request.args.get(&#39;pag&#39;, 1, type=int)通过关键字&#39;page&#39;获取页码，如果没有指定页码，则默认请求第1页，type=int保证参数无法转换成整数时，返回默认值（即第一页）。 paginate()方法返回的是一个Pagination类对象（分页对象）。该方法第一个参数（必需要有）为页码，可选参数per_page用来指定每一页显示的记录数，如果没有指定，默认显示20个记录；另一个可选参数error_out，当其设为True时（默认值），如果请求的页码超出范围，则返回404错误；如果设为False，则返回一个空列表。常用的分页对象属性如表11-1。 表11-1 Flask-SQLAlchemy分页对象的属性 属性 说明 items 当前页面中的记录 query 分页的源查询 page 当前页码 prev_num 上一页的页码 next_num 下一页的页码 has_next 如果有下一页，则返回True has_prev 如果有上一页，则返回True pages 查询得到的总页数 per_page 每页显示的记录数量 total 查询返回的记录总数 在分页对象上还可以调用一些方法，如表11-2 表11-2 在Flask-SQLAlchemy对象上可调用的方法 方法 说明 iter_pages(left_edge=2, left_current=2, right_current=5, right_edge=2) 一个迭代器，返回一个在分页导航中显示的页数列表。这个列表的最左边显示left_edge个页码，当前页的左边显示left_current个页码，当前页的右边显示right_current个页码，最右边显示right_edge个页码。如按当前默认配置，在一个100页的列表中，当前页为第50页，则会返回一下页数：1、2、None、48、49、50、51、52、53、54、55、None、99、100。None表示页数之间的间隔。 prev() 上一页的分页对象 next() 下一页的分页对象 这样，主页中就会显示特定数量的文章，如果想看第2页中的文章，可在URL后加上查询字符串?page=2，那么视图函数就会通过request.args.get()方法获取&#39;page&#39;页码加以处理。 4. 在app/templates/_posts.html中定义用于显示博客文章的局部模板：123456789101112131415161718192021222324252627282930313233343536&lt;ul class=&quot;posts&quot;&gt; &#123;% for post in posts %&#125; &lt;li class=&quot;post&quot;&gt; &lt;div class=&quot;post-thumbnail&quot;&gt; &lt;a href=&quot;&#123;&#123; url_for(&apos;main.user&apos;, username=post.author.username) &#125;&#125;&quot;&gt; &lt;img class=&quot;img-rounded profile-thumbnail&quot; src=&quot;&#123;&#123; post.author.gravatar(size=40) &#125;&#125;&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;post-content&quot;&gt; &lt;div class=&quot;post-date&quot;&gt;&#123;&#123; moment(post.timestamp).fromNow() &#125;&#125;&lt;/div&gt; &lt;div class=&quot;post-author&quot;&gt;&lt;a href=&quot;&#123;&#123; url_for(&apos;main.user&apos;, username=post.author.username) &#125;&#125;&quot;&gt;&#123;&#123; post.author.username &#125;&#125;&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;post-body&quot;&gt; &#123;% if post.body_html %&#125; &#123;&#123; post.body_html | safe &#125;&#125; &#123;% else %&#125; &#123;&#123; post.body &#125;&#125; &#123;% endif %&#125; &lt;/div&gt; &lt;div class=&quot;post-footer&quot;&gt; &#123;% if current_user == post.author %&#125; &lt;a href=&quot;&#123;&#123;url_for(&apos;main.edit&apos;, id=post.id) &#125;&#125;&quot;&gt; &lt;span class=&quot;label label-primary&quot;&gt;Edit&lt;/span&gt; &lt;/a&gt; &#123;% elif current_user.is_administrator() %&#125; &lt;a href=&quot;&#123;&#123; url_for(&apos;main.edit&apos;, id=post.id) &#125;&#125;&quot;&gt; &lt;span class=&quot;label label-danger&quot;&gt;Edit [Admin]&lt;/span&gt; &lt;/a&gt; &#123;% endif %&#125; &lt;a href=&quot;&#123;&#123; url_for(&apos;main.post&apos;, id=post.id) &#125;&#125;&quot;&gt; &lt;span class=&quot;label label-default&quot;&gt;Permalink&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; 因为在index.html模板中以及第7步的user.html模板中都需要显示博客文章，为了避免代码重写，将用于显示博客文章的模板分离出来，再在需要的时候加以引用（通过include()指令引用，如include &#39;_post.html&#39;）。为了区分独立模板和局部模板，局部模板一般在模板名加下划线_。 if post.body_html解释见第11步。 5. 在app/templates/_macros.html中定义分页导航条模板宏（显示上一页、1、2、3…下一页）：1234567891011121314151617181920212223242526272829&#123;% macro pagination_widget(pagination, endpoint) %&#125;&lt;ul class=&quot;pagination&quot;&gt; &lt;li&#123;% if not pagination.has_prev %&#125; class=&quot;disabled&quot;&#123;% endif %&#125;&gt; &lt;a href=&quot;&#123;% if pagination.has_prev %&#125;&#123;&#123; url_for(endpoint, page=pagination.prev_num, **kwargs) &#125;&#125;&#123;% else %&#125;#&#123;% endif %&#125;&quot;&gt; &amp;laquo; &lt;/a&gt; &lt;/li&gt; &#123;% for p in pagination.iter_pages() %&#125; &#123;% if p %&#125; &#123;% if p == pagination.page %&#125; &lt;li class=&quot;active&quot;&gt; &lt;a href=&quot;&#123;&#123; url_for(endpoint, page=p, **kwargs) &#125;&#125;&quot;&gt;&#123;&#123; p &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% else %&#125; &lt;li&gt; &lt;a href=&quot;&#123;&#123; url_for(endpoint, page=p, **kwargs) &#125;&#125;&quot;&gt;&#123;&#123; p &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endif %&#125; &#123;% else %&#125; &lt;li class=&quot;disable&quot;&gt;&lt;a href=&quot;#&quot;&gt;&amp;hellip;&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;li&#123;% if not pagination.has_next %&#125; class=&quot;disabled&quot;&#123;% endif %&#125;&gt; &lt;a href=&quot;&#123;% if pagination.has_next %&#125;&#123;&#123; url_for(endpoint, page=pagination.next_num, **kwargs) &#125;&#125;&#123;% else %&#125;#&#123;% endif %&#125;&quot;&gt; &amp;raquo; &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;&#123;% endmacro %&#125; pagination_widget(pagination, endpoint)分别接受分页对象和路由端点名作为参数。 宏参数中不用加入**kwargs，分页宏会把接受到的所有关键字参数传给url_for()。这种方式也可以用在路由中，例如包含一个动态部分的资料页。 分页对象的iter_pages()方法返回一个页数列表。 分页链接通过url_for()生成。 6. 在app/templates/index.html中引用_posts.html和_macros.html：123456789101112131415161718192021222324252627&#123;% extends &quot;base.html&quot; %&#125;&#123;% import &quot;bootstrap/wtf.html&quot; as wtf %&#125;&#123;% import &quot;_macros.html&quot; as macros %&#125;&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block page_content %&#125;&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Hello, &#123;% if current_user.is_authenticated %&#125;&#123;&#123; current_user.username &#125;&#125;&#123;% else %&#125;Stranger&#123;% endif %&#125;!&lt;/h1&gt;&lt;/div&gt;&lt;div&gt; &#123;% if current_user.can(Permission.WRITE_ARTICLES) %&#125; &#123;&#123; wtf.quick_form(form) &#125;&#125; &#123;% endif %&#125;&lt;/div&gt;&#123;% include &apos;_posts.html&apos; %&#125;&#123;% if pagination %&#125;&lt;div class=&quot;pagination&quot;&gt; &#123;&#123; macros.pagination_widget(pagination, &apos;main.index&apos;) &#125;&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% endblock %&#125;&#123;% block scripts %&#125;&#123;&#123; super() &#125;&#125;&#123;&#123; pagedown.include_pagedown() &#125;&#125;&#123;% endblock %&#125; 7. 在app/main/views.py中定义在个人资料页面中显示该用户所写文章的路由：1234567891011# ...@main.route(&apos;/user/&lt;username&gt;&apos;)def user(username): user = User.query.filter_by(username=username).first_or_404() page = request.args.get(&apos;page&apos;, 1, type=int) pagination = user.posts.order_by(Post.timestamp.desc()).paginate( page, per_page=current_app.config[&apos;FLASKY_POSTS_PER_PAGE&apos;], error_out=False) posts = pagination.items return render_template(&apos;user.html&apos;, user=user, posts=posts, pagination=pagination) 用户发布的文章通过User.posts关系获取。 11.4 使用Markdown和Flask-PageDown支持富文本文章实现这个功能需要用到以下一些包： PageDown：使用javaScript实现客户端Markdown到HTML的转换程序。 Flask-PageDown：为Flask包装的PageDown，把PageDown集成到Flask—WTF表单中。 Markdown：使用Python实现的服务器端Markdown到HTML的转换程序。 Bleach：使用Python实现的HTML清理器。 8. 在app/__init__.py中初始化Flask-PageDown：123456789from flask_pagedown import PageDown# ...pagedown = PageDown()def create_app(config_name): # ... pagedown = pagedown.init_app(app) # ... 9. 在app/templates/index.html中添加Flask-PageDown模板声明：1234&#123;% block scripts %&#125;&#123;&#123; super() &#125;&#125;&#123;&#123; pagedown.include_pagedown() &#125;&#125;&#123;% endblock %&#125; 10. 在app/models.py中在Post模型中处理Markdown文本：提交表单后，POST请求只会发送纯Markdown文本，页面中显示的HTML预览会被丢掉。安全起见，我们（1）只提交Markdown源文件，（2）然后在服务器上使用Markdown将其转换为HTML文本，（3）得到HTML文本后，在使用Bleach进行清理，确保其中只包含几个允许使用的HTML标签，（4）将清理后得到的HTML文本存储到body_html字段中以提高效率（不用每次请求时都转换）。 1234567891011121314151617181920from markdown import markdownimport bleach# ...class Post(db.Model): # ... body_html = db.Column(db.Text) # ... @staticmethod def on_changed_body(target, value, oldvalue, initiator): allowed_tags = [&apos;a&apos;, &apos;abbr&apos;, &apos;acronym&apos;, &apos;b&apos;, &apos;blockquote&apos;, &apos;code&apos;, &apos;em&apos;, &apos;i&apos;, &apos;li&apos;, &apos;ol&apos;, &apos;pre&apos;, &apos;strong&apos;, &apos;ul&apos;, &apos;h1&apos;, &apos;h2&apos;, &apos;h3&apos;,&apos;p&apos;] target.body_html = bleach.linkify(bleach.clean( markdown(value, output_format=&apos;html&apos;), tags=allowed_tags, strip=True)) db.event.listen(Post.body, &apos;set&apos;, Post.on_changed_body) on_changed_body函数注册在body字段上，是SQLAlchemy&#39;set&#39;事件的监听程序，这意味着只要这个类实例的body字段设了新值，该函数就会被调用。 真正的Markdown转换成HTMl分三步完成：（1）markdown()函数把Markdown文本转换成HTML文本。（2）将得到的HTMl文本和允许使用的HTML标签列表传给clean()函数，删除所有不再白名单中的HTML标签。（3）将上一步得到的HTML文本传给linkify()函数，把纯文本中的URL链接转换成适当的&lt;a&gt;链接（这一步是很必要的，因为Markdown规范没有为自动生成链接提供官方支持）。 11. 在app/templates/_posts.html中判断是否使用文章的HTNL格式：12345678# ...&lt;div class=&quot;post-body&quot;&gt; &#123;% if post.body_html %&#125; &#123;&#123; post.body_html | sage &#125;&#125; &#123;% else %&#125; &#123;&#123; post.body &#125;&#125; &#123;% endif %&#125;&lt;/div&gt; 渲染HTNL格式时使用| safe后缀，作用时告诉Jinja2不要转移HTML元素（默认情况下，出于安全考虑，Jinja2会转移所有模板变量）。 12. 在app/main/views.py中定义文章页面路由：123456# ...@main.route(&apos;/post/&lt;int:id&gt;&apos;)def post(id): post = Post.query.get_or_404(id) return render_template(&apos;post.html&apos;, post=[post]) 注意：post.html模板中也通过引用_psots.html显示博客文章，所以传参时要传一个列表（可迭代对象），因为_psots.html中通过for循环获取每一篇文章。 13. 在app/templates/_posts.html中添加文章链接：123456789101112131415&lt;ul class=&apos;posts&quot;&gt; &#123;% for post in posts %&#125; &lt;li class=&quot;psot&quot;&gt; ... &lt;div class=&quot;post-content&quot;&gt; .... &lt;div class=&quot;post-footer&quot;&gt; &lt;a href=&quot;&#123;&#123; url_for(&apos;main.post&apos;, id=post.id) &#125;&#125;&quot;&gt; &lt;span class=&quot;label label-default&quot;&gt;Permalink&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt; 14. 在app/templates/post.html中引用_posts.html：12345678&#123;% extends &quot;base.html&quot; %&#125;&#123;% import &quot;_macros.html&quot; as macros %&#125;&#123;% block title %&#125;Flasky - Post&#123;% endblock %&#125;&#123;% block page_content %&#125;&#123;% include &quot;_posts.html&quot; %&#125;&#123;% endblock %&#125; 11.6 博客文章编辑页面15. 在app/main/views.py中定义编辑文章的路由：1234567891011121314151617# ...@main.route(&apos;/edit/&lt;int:id&gt;&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])@login_requireddef edit(id): post = Post.query.get_or_404(id) if current_user != post.author and \\ not current_user.can(Permission.ADMINISTER): abort(403) form = PostForm() if form.validate_on_submit(): post.body = form.body.data db.session.add(post) flash(&apos;The post has been updated.&apos;) return redirect(url_for(&apos;main.post&apos;, id=post.id)) form.body.data = post.body return render_template(&apos;edit_post.html&apos;, form=form) 注意：这个视图函数的作用是只允许博客文章作者编辑（管理员除外，管理员能编辑所有用户文章）。如果用户试图编辑其他用户的文章，视图函数则会返回403错误。这里使用的PostForm表单类和主页中使用的是同一个。 16. 在app/templates/edit_post.html中定义编辑博客文章的模板：123456789101112131415161718&#123;% extends &quot;base.html&quot; %&#125;&#123;% import &quot;bootstrap/wtf.html&quot; as wtf %&#125;&#123;% block title %&#125;Flasky - Edit Post&#123;% endblock %&#125;&#123;% block page_content %&#125;&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Edit Post&lt;/h1&gt;&lt;/div&gt;&lt;div&gt; &#123;&#123; wtf.quick_form(form) &#125;&#125;&lt;/div&gt;&#123;% endblock %&#125;&#123;% block scripts %&#125;&#123;&#123; super() &#125;&#125;&#123;&#123; pagedown.include_pagedown() &#125;&#125;&#123;% endblock %&#125; 17. 在app/templates/_posts.html中添加一个在文章下面指向编辑文章页面的链接：123456789101112131415161718192021222324&lt;ul class=&apos;posts&quot;&gt; &#123;% for post in posts %&#125; &lt;li class=&quot;psot&quot;&gt; ... &lt;div class=&quot;post-content&quot;&gt; .... &lt;div class=&quot;post-footer&quot;&gt; &#123;% if current_user == post.author %&#125; &lt;a href=&quot;&#123;&#123;url_for(&apos;main.edit&apos;, id=post.id) &#125;&#125;&quot;&gt; &lt;span class=&quot;label label-primary&quot;&gt;Edit&lt;/span&gt; &lt;/a&gt; &#123;% elif current_user.is_administrator() %&#125; &lt;a href=&quot;&#123;&#123; url_for(&apos;main.edit&apos;, id=post.id) &#125;&#125;&quot;&gt; &lt;span class=&quot;label label-danger&quot;&gt;Edit [Admin]&lt;/span&gt; &lt;/a&gt; &#123;% endif %&#125; &lt;a href=&quot;&#123;&#123; url_for(&apos;main.post&apos;, id=post.id) &#125;&#125;&quot;&gt; &lt;span class=&quot;label label-default&quot;&gt;Permalink&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt;","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第十章 用户资料","date":"2017-12-30T11:06:09.000Z","path":"2017/12/30/把《Flask Web开发》读薄系列之第十章 用户资料/","text":"10.1 用户资料信息（个人基本资料）1. 在app/models.py中增加用户信息字段：123456789# ...class User(UserMixin, db.Model): # ... name = db.Column(db.String(64)) # 不同于username，可理解为昵称 location = db.Column(db.String(64)) about_me = db.Column(db.Text()) member_since = db.Column(db.DateTime(), default=datetime.utcnow()) # 注册时间 last_seen = db.Column(db.DateTime(), default=datetime.utcnow()) # 最后访问时间 db.String()和db.Text()的区别是db.Text()不用指定最大长度。 db.Column()中的default参数可以接受函数名作为默认值，所以datetime.utcnow后面没有()。 2. 在app/models.py中增加刷新用户最后访问时间功能：12345678# ...class User(UserMixin, db.Model): # ... def ping(self): self.last_seen = datenow.utcnow() db.session.add(self) 3. 在app/auth/views.py中更新已登录用户的最后访问时间：用户每次访问网站后，last_seen字段都需要进行更新，在每次请求前进行更新，可以满足这个需求。 12345678910# ...@auth.before_app_requestdef before_request(): if current_user.is_authenticated: current_user.ping() if not current_user.confirmd \\ and request.endpoint[:5] != &apos;auth.&apos; \\ and request.endpoint != &apos;static&apos;: return redirect(url_for(&apos;auth.unconfirmed&apos;)) 10.2 用户资料页面1. 在app/main/views.py中定义用户资料页面路由：123456789from flask import abort# ...@main.route(&apos;/user/&lt;username&gt;&apos;)def user(username): user = User.query.filter_by(username=username).first() if user is None: abort(404) return render_template(&apos;user.html&apos;, user=user) 2. 在app/templates/user.html编写用户资料页面模板：12345678910111213141516171819202122232425262728&#123;% extends &quot;base.html&quot; %&#125;&#123;% block title %&#125;Flasky - &#123;&#123; user.username &#125;&#125;&#123;% endblock %&#125;&#123;% block page_content %&#125;&lt;div class=&quot;page-header&quot;&gt; &lt;img class=&quot;img-rounded profile-thumbnail&quot; src=&quot;&#123;&#123; user.gravatar(size=256) &#125;&#125;&quot;&gt; &lt;div class=&quot;profile-header&quot;&gt; &lt;h1&gt;&#123;&#123; user.username &#125;&#125;&lt;/h1&gt; &#123;% if user.name or user.location %&#125; &lt;p&gt; &#123;% if user.name %&#125;&#123;&#123; user.name &#125;&#125;&lt;br&gt;&#123;% endif %&#125; &#123;% if user.location %&#125; from &lt;a href=&quot;http://maps.google.com/?q=&#123;&#123; user.location &#125;&#125;&quot;&gt;&#123;&#123; user.location &#125;&#125;&lt;/a&gt;&lt;br&gt; &#123;% endif %&#125; &lt;/p&gt; &#123;% endif %&#125; &#123;% if current_user.is_administrator() %&#125; &lt;p&gt;&lt;a href=&quot;mailto:&#123;&#123; user.email &#125;&#125;&quot;&gt;&#123;&#123; user.email &#125;&#125;&lt;/a&gt;&lt;/p&gt; &#123;% endif %&#125; &#123;% if user.about_me %&#125;&lt;p&gt;&#123;&#123; user.about_me &#125;&#125;&lt;/p&gt;&#123;% endif %&#125; &lt;p&gt; Member since &#123;&#123; moment(user.member_since).format(&apos;L&apos;) &#125;&#125;. Last seen &#123;&#123; moment(user.last_seen).fromNow() &#125;&#125;. &lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; 3. 在app/templates/base.html导航条中添加一个链接访问用户自己的资料页面：1234567&#123;% if current_user.is_authenticated %&#125;&lt;li&gt; &lt;a href=&quot;&#123;&#123; url_for(&apos;main.user&apos;, username=current_user.username) &#125;&#125;&gt; Profile &lt;/a&gt;&lt;/li&gt;&#123;% endif %&#125; 10.3 用户资料编辑器用户资料编辑分两种情况：（1）用户自己进入一个页面编辑自己的资料。（2）管理员能够编辑任意用户的资料，不仅包括用户的个人信息，而且还包括普通用户不能直接访问的User模型的字段，如用户角色等。 10.3.1 普通用户级别的资料编辑器1. 在app/main/forms.py中添加普通用户用的资料编辑表单：12345class EditProfileForm(FlaskForm): name = StringField(&apos;Real name&apos;, validators=[Length(0, 64)]) location = StringField(&apos;Location&apos;, validators=[Length(0, 64)]) about_me = TextAreaField(&apos;About me&apos;) submit = SubmitField(&apos;Submit&apos;) 注意：这个表单中所有字段都是可选的， 因此长度验证函数的长度允许为零。 2. 在app/main/views.py中定义普通用户进行资料编辑的路由：12345678910111213141516171819# ...@main.route(&apos;/edit-profile&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])@login_requireddef edit_profile(): form = EditProfileForm() if form.validate_on_submit(): current_user.name = form.name.data current_user.location = form.location.data current_user.about_me = form.about_me.data db.session.add(current_user._get_current_object()) db.session.commit() flash(&apos;Your profile has been updated.&apos;) return redirect(url_for(&apos;main.user&apos;, username=current_user.username)) # 在显示表单前（渲染表单前），为表单所有字段设定初始值 form.name.data = current_user.name form.location.data = current_user.location form.about_me.data = current_user.about_me return render_template(&apos;edit_profile.html&apos;, form=form) 3. 在app/templates/user.html中添加普通用户用的编辑资料的链接：1234567# ...&#123;% if user == current_user %&#125;&lt;a class=&quot;btn btn-default&quot; href=&quot;&#123;&#123; url_for(&apos;main.edit_profile&apos;) &#125;&#125;&quot;&gt; Edit Profile&lt;/a&gt;&#123;% endif %&#125; 注意：链接外层的条件语句可以确保只有当用户查看自己的资料页面时才显示这个编辑个人资料的链接。 10.3.2 管理员级别的资料编辑器1. 在app/main/forms.py中添加管理员用的资料编辑表单：123456789101112131415161718192021222324252627282930313233# ...class EditProfileAdminForm(FlaskForm): email = StringField(&apos;Email&apos;, validators=[DataRequired(), Length(1, 64), Email()]) username = StringField(&apos;Username&apos;, validators=[DataRequired(), Length(1, 64), Regexp(&apos;^[A-Za-z][A-Za-z0-9_.]*$&apos;, 0, &apos;Username must be have only &apos; &apos;letters, numbers, dots or&apos; &apos;underscores&apos;)]) confirmed = BooleanField(&apos;Confirmed&apos;) role = SelectField(&apos;Role&apos;, coerce=int) name = StringField(&apos;Real name&apos;, validators=[Length(0, 64)]) location = StringField(&apos;Location&apos;, validators=[Length(0, 64)]) about_me = TextAreaField(&apos;About me&apos;) submit = SubmitField(&apos;Submit&apos;) def __init__(self, user, *args, **kwargs): super(EditProfileAdminForm, self).__init__(*args, **kwargs) self.role.choices = [(role.id, role.name) for role in Role.query.order_by(Role.name).all()] # 接受用户对象作为参数（成员变量） self.user = user def validate_email(self, field): if field.data != self.user.email and \\ User.query.filter_by(email=field.data).first(): raise ValidationError(&apos;Email already registered.&apos;) def validate_username(self, field): if field.data != self.user.username and \\ User.query.filter_by(username=field.data).first(): raise ValidationError(&apos;Username already in use.&apos;) SelectFiled()可以实现下拉列表，可用它来选择用户角色。 SelectFiled实例必须在其choices属性中设置可选选项，选项必须是由一个个元组组成的列表，各元组包含两个元素（选项的标识符和显示在控件中的文本字符串）。该例中，远足的标识符是角色的id，因为这个id是整数，所以添加coerce=int参数，从而把字段的值（字符串形式）转换为整数，从而保证这个字段的data属性值是整数。 email和username都定义了自定义函数：验证这两个字段时，首先检查字段的值是否发生改变，如果发生改变，就要保证新值不和其他用户的相应字段重复；如果没有发生变化，则跳过该验证。 2. 在app/main/views.py中定义管理员进行资料编辑的路由：12345678910111213141516171819202122232425262728293031from app.decorators import admin_required# ...@main.route(&apos;/edit-profile/&lt;int:id&gt;&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])@login_required@admin_requireddef edit_profile_admin(id): user = User.query.get_or_404(id) form = EditProfileAdminForm(user=user) if form.validate_on_submit(): user.email = form.email.data user.username = form.username.data user.confirmed = form.confirmed.data user.role = Role.query.get(form.role.data) user.name = form.name.data user.location = form.location.data user.about_me = form.about_me.data db.session.add(user) db.session.commit() flash(&apos;The profile has been updated.&apos;) return redirect(url_for(&apos;.user&apos;, username=user.username)) # 在显示表单前（渲染表单前），为表单所有字段设定初始值 form.email.data = user.email form.username.data = user.username form.confirmed.data = user.confirmed # 将user.role_id赋值给表单字段 form.role.data = user.role_id form.name.data = user.name form.location.data = user.location form.about_me.data = user.about_me return render_template(&apos;edit_profile.html&apos;, form=form, user=user) 该例中，要进行编辑的用户由id指定，因此可以使用Flask-SQLAlchemy提供的get_or_404()函数，如果提供的id不正确，则返回404错误。 将user.role_id赋值给form.role.data是因为步骤1中choices属性设置的元组列表使用数字标识符表示各选项。 提交表单后，角色id从form.role.data中获取，并通过Role.query.get()方法加载角色对象。 3. 在app/templates/user.html中添加管理员用的资料编辑链接：1234567# ...&#123;% if current_user.is_administrator() %&#125;&lt;a class=&quot;btn btn-danger&quot; href=&quot;&#123;&#123; url_for(&apos;main.edit_proflie_admin&apos;, id=user.id) &#125;&#125;&gt; Edit Profile [Admin]&lt;/a&gt;&#123;% endif %&#125; 10.4 用户头像（使网站支持Gravatar提供的用户头像）Gravatar可以把头像和电子邮件地址关联起来，使得你在支持Gravatar服务的网站中只需要头像URL就能显示你的头像（网站没有头像功能也能显示用户头像，只要网站支持Gravatar）。 头像URL由https://secure.gravatar.com/avatar/+电子邮件地址的MD5散列值组成。在浏览器地址栏输入该URL就会看到某电子邮件对应的头像（前提是到http://gravatar.com中注册账户并上传头像），如果没有对应的头像，则会显示一个默认图片。 头像URL的查询字符串可以包含多个参数，以此配置头像图片的特征（如像素大小等），可设参数如表10-1所示：表10-1 Gravatar查询字符串参数 参数名 说明 s 图片大小，单位是像素 r 图片级别（有没有暴力倾向等）。可选值有&#39;g&#39;、&#39;pg&#39;、&#39;r&#39;和&#39;x&#39; d 没有注册Gravatar服务的用户使用默认图片生成方式。可选值有：(1)&#39;404&#39;，返回404错误；(2)默认图片的URL；(3)图片生成器：&#39;mm&#39;、&#39;identicon&#39;、&#39;monsterid&#39;、&#39;wavatar&#39;、&#39;retro&#39;或&#39;blank&#39;之一 fd 强制使用默认头像 1. 在app/models.py中增加avatar_hash字段（用于存储邮箱地址的MD5散列值）、生成邮箱地址的MD5三散列值方法、生成头像URL方法：123456789101112131415161718192021222324252627import hashlib# ...class User(UserMixin, db.Model): # ... avatar_hash = db.Column(db.String(32)) def __init__(self, **kwargs): super(User, self).__init__(**kwargs) if self.role is None: if self.email == current_app.config[&apos;FLASKY_ADMIN&apos;]: self.role = Role.query.filter_by(name=&apos;Administrator&apos;).first() if self.role is None: self.role = Role.query.filter_by(default=True).first() if self.email is not None and self.avatar_hash is None: self.avatar_hash = self.gravatar_hash() # 定义生成邮箱地址MD5散列值的方法 def gravatar_hash(self): return hashlib.md5(self.emial.lower().encode(&apos;utf-8&apos;)).hexdigest() # 定义生成头像URL的方法 def gravatar(self, size=100, default=&apos;identicon&apos;, rating=&apos;g&apos;): url = &apos;https://secure.gravatar.com/avatar&apos; hash = self.gravatar_hash() return &apos;&#123;url&#125;/&#123;hash&#125;?s=&#123;size&#125;&amp;d=&#123;default&#125;&amp;r=&#123;rating&#125;&apos;.format( url=url, hash=hash, size=size, default=default, rating=rating) 注意：由于生成MD5值是一项CPU密集型操作，所以要在某个页面中生成大量头像，计算量会很大。考虑到电子邮件地址的MD5散列值是不变的（电子邮件地址不变前提下），因此可以将MD5值存储到User模型字段中，而不必每次都进行计算，从而得到优化。 2. 在app/templates/user.html中增加资料页面中的头像显示：123# ...&lt;img class=&quot;img-rounded profile-thumbnail&quot; src=&quot;&#123;&#123; user.gravatar(size=256) &#125;&#125;&quot;&gt; 3. 在`app/templates/base.html”中导航条上添加已登录用户的头像缩略图：为了更好地调整页面中头像图片的显示格式，可自定义CSS类，将其放在statics文件夹中。 1234567891011121314151617181920# ...&#123;% block head %&#125;&#123;&#123; super() &#125;&#125;# ...&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;&#123; url_for(&apos;static&apos;, filename=&apos;styles.css&apos;) &#125;&#125;&quot;&gt;&#123;% endblock %&#125;&#123;% blcok navbar %&#125;# ...&lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &#123;% if current_user.is_authenticated %&#125; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt; &lt;img src=&quot;&#123;&#123; current_user.gravatar(size=18) &#125;&#125;&quot;&gt; Account &lt;b class=&quot;caret&quot;&gt;&lt;/b&gt; &lt;/a&gt;# ...&#123;% endblock %&#125;","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第九章 用户角色","date":"2017-12-30T11:04:18.000Z","path":"2017/12/30/把《Flask Web开发》读薄系列之第九章 用户角色/","text":"简单的程序可能只需要两个角色（普通用户和管理员），对于这种情况，在User模型中添加一个is_administrator布尔值字段就足够了。 复杂的用户角色可以通过赋予用户某些权限的组合是一种很好的方法。 9.1 角色在数据库中的表示1. 在app/models.py中增加用户权限字段：1234567class Role(db.Model): __tablename__ = &apos;roles&apos; id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) default = db Column(db.Boolean, default=False, index=True) permission = db.Column(db.Integer) users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;, lazy=&apos;dynamic&apos;) deafult字段中的default参数如果设置为True，则该角色为默认角色，用户注册时会默认为该角色（具体实现是给defalut赋值True）。 permission字段为用户权限，其值是一个整数。各权限位值表如下：表9-1 程序的权限 操作 位值 说明 关注用户 0b00000001 (0x01) 关注其他用户 在他人的文章中发表评论 0b00000010（0x02） 在他人撰写的文章中发布评论 写文章 0b00000100（0x04） 写原创文章 管理他人发表的评论 0b00001000（0x08） 查处他人发表的不当评论 管理员权限 0b10000000（0x80） 管理网站 2. 在app/models.py中定义权限常量：123456class Permission: FOLLOW = 0x01 COMMENT = 0x02 WRTIE_ARTICLES = 0x04 MODERATE_COMMENTS = 0x08 ADMINISTER = 0x80 一般网站的用户角色以及对应拥有的权限如表9-2: 表9-2 用户角色 用户角色 权限 说明 匿名 0b00000000（0x00） 未登录的用户，在程序中只有阅读权限 用户 0b00000111（0x07） 具有关注其他用户、发表评论和发布文章的权限。这是新用户的默认角色 协管员 0b00001111（0x0f） 增加审查不当评论的权限 管理员 0b11111111（oxff） 具有所有权限，包括修改其他用户所属角色的权限 这样就可以根据权限的组合来组织角色。 3. 在app/models.py中支持创建角色：12345678910111213141516171819202122232425262728293031323334# ...class Role(db.Model): # ... @staticmethod def inset_roles(): roles = &#123; &apos;User&apos;: [Permission.FOLLOW, Permission.COMMENT, Permission.WRITE_ARTICLES], &apos;Moderator&apos;: [Permission.FOLLOW, Permission.COMMENT, Permission.WRITE_ARTICLES, Permission.MODERATE_COMMENT], &apos;Anministrator&apos;: [Permission.FOLLOW, Permission.COMMENT, Permission.WRITE_ARTICLES,Permission.MODERATE_COMMENT, Permission.ADMINISTER] &#125; default_role = &apos;User&apos; for roel in roles: # 查找Role表中是否有name=role这角色 role = Role.query.filter_by(name=role).first() # 如果没有则创建 if role is None: role = Role(name=role) # 将permissio字段的值设为0 role.reset_permission() # 添加权限 for perm in roles[role]: role.add_permission(perm) # 判断role.name是否为默认角色&apos;User&apos;，如果是则将role.default赋值为True role.default = (role.name == default_role) # 将数据库变化添加到会话中 db.session.add(role) # 提交数据库变化 db.session.commit() insert_roles()函数并不直接创建新角色对象，而是先通过for循环遍历roles，查询Role表中是否有该角色，当表中没有这个角色色才创建角色。 4. 适用shell会话把角色写入数据库：1234(venv) $ python flasky.py shell&gt;&gt;&gt; Role.insert_roles()&gt;&gt;&gt; Role.query.all()[&lt;Role u&apos;Administrator&apos;&gt;, &lt;Role u&apos;User&apos;&gt;, &lt;Role u&apos;Moderator&apos;&gt;] 9.2 赋予角色（在用户注册账户时赋予适当的角色）1. 在app/models.py中定义默认赋予的用户角色：12345678910111213# ...class User(UserMixin, db.Model): # ... def __init__(self, **kwargs): super(User, self).__init__(**kwargs) if self.role is None: # 如果email邮箱是管理员邮箱，则赋予‘管理员’角色，否则赋予‘默认’角色 if self.email == current_app.config[&apos;FLASKY_ADMIN&apos;]: self.role = Role.query.filter_by(name=&apos;Administrator&apos;).first() if self.role is None: self.role = Role.query.filter_by(dafault=True).first() User类的构造函数首先调用基类的构造函数，如果创建基类对象后还没有定义角色（即role为None），则根据电子邮件决定将其设为管理员还是默认角色。 9.3 角色验证（检查是否有指定权限）1. 在app/models.py中检查用户是否有指定的权限：123456789101112131415161718192021222324252627from flask_login import UserMixin, AnonymousUserMixin# ...class User(UserMixin, db.model): # ... def can(self, permissions): return self.role is not None and \\ # 进行位与运算 (self.role.permission &amp; permissions) == permissions def is_administrator(self): return self.can(Permission.ADMINSTER) # 定义匿名用户类class AnonymousUser(AnonymousUserMixin): def can(self, permissions): return False def is_administrator(self): return False # 实例化AnonymousUser类（即设置用户未登录时current_user的值，# 这样程序就不用先检查用户是否登录，都能调用current_user.can()# 和current_user.is_administrator()）login_manager.anonymous_user = AnonymousUser 2. 在app/decorators.py中定义用于检查用户权限的修饰器：如果想让视图函数只对具有特定权限的用户开放，可以适用自定义的修饰器。 123456789101112131415161718192021from functools import wrapsfrom flask imoprt abortfrom flask_login import current_userfrom app.models import Permissiondef permission_required(permission): def decorator(func): @wraps(func) def decorated_function(*args, **kwargs): # 判断用户是否具有某特定权限，如果没有则抛出403错误 if not current_user.can(permission): abort(403) return func(*args, **kwargs) return decorated_function return decorator def admin_required(func): # 相当于调用decorator(func) return permission_required(Permission.ADMINSTER)(func) 3. 在app/main/__init__.py中把Permission类加入模板上下文：在模板中可能也需要检查权限，所以Permission类为所有为定义了常量以便获取。 为了避免每次调用render_template()时多添加一个模板参数，可以使用上下文管理器，使得变量在所有模板中全局可访问。 1234567# ...from app.models import Permission@main.app_context_processordef inject_permission(): # 实例化Permission类，并将其字典化 return dict(Permission=Permission) 4. 在tests/test_user_model.py中添加角色和权限的单元测试：123456789101112131415161718192021# ...class UserModelTestCase(unittest.TestCase): # ... def test_user_role(self): u = User(email=&apos;john@example.com&apos;, password=&apos;cat&apos;) self.assertTrue(u.can(Permission.FOLLOW)) self.assertTrue(u.can(Permission.COMMENT)) self.assertTrue(u.can(Permission.WRITE)) self.assertFalse(u.can(Permission.MODERATE)) self.assertFalse(u.can(Permission.ADMIN)) def test_moderator_role(self): r = Role.query.filter_by(name=&apos;Moderator&apos;).first() u = User(email=&apos;john@example.com&apos;, password=&apos;cat&apos;, role=r) self.assertTrue(u.can(Permission.FOLLOW)) self.assertTrue(u.can(Permission.COMMENT)) self.assertTrue(u.can(Permission.WRITE)) self.assertTrue(u.can(Permission.MODERATE)) self.assertFalse(u.can(Permission.ADMIN)) 注意：还是那句话，修改数据库模型之后，记得先执行python flasky.py db migrate -m &quot;blablabla&quot;生成数据库迁移脚本，再执行python flasky.py db upgrade更新数据库。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第八章 用户认证","date":"2017-12-30T11:00:49.000Z","path":"2017/12/30/把《Flask Web开发》读薄系列之第八章 用户认证/","text":"重点说明：根据作者的经验，从第八章开始，若只把书上示例的代码敲上去，是很难重复实现书中效果的，基本上都会出错，原因有（1）书中省略了许多代码（2）由于扩展版本的升级，书中部分代码已不再适用。所以，强烈强烈强烈建议边看书边对照着Git上对应标签的版本阅读源代码，以免遇到巨坑又不知道哪里出错又无法debug。此时也提醒一下自己，要把代码实现一遍后再来做笔记，以免自己坑自己白费功夫。 8.1 Flask的认证扩展 Werkzeug：计算密码的散列值并进行核对（将密码生成散列值，并验证密码是否正确）。 Flask-Login：管理已登录用户的用户会话。 itsdangerous：生成并核对加密安全令牌（例如注册账号验证邮箱时生成验证链接时用）。 8.2 密码的安全性若想保证存储在数据库中的用户密码的安全性，那么就不能存储密码本身，而要存储密码的散列值。当需要核对验证密码是否正确时，核对输入的密码生成的散列值是否与数据库中存储的散列值一致即可。因为计算散列值的函数是可复现的：只要输入一样，结果就一样。 使用Werkzeug实现密码散列Werkzeug中的security模块可以实现散列值的计算。这一功能需要用到两个函数（generate_password_hash()和check_password_hash())，它们分别用在注册用户阶段和验证用户阶段。 generate_password_hash(password, method=pbkdf2:sha1, salt_length=8)：这个函数将原始密码作为输入，以字符串形式输出密码的散列值。method和salt_length的默认值可满足大多数需求。 check_password_hash(hash, password)：这个函数的参数分别是从数据库中读取的密码散列值，和用户输入的密码。密码正确则返回True。 1. 使app/models.py中的User模型支持密码散列：1234567891011121314151617181920from werkzeug.security import generate_password_hash, check_password_hash# ...class User(db.Models): # 为User模型增加password_hash字段 password_hash = db.Column(db.String(128)) # 当试图读取password的值时，返回错误 @property def password(self): raise AttributeError(&apos;password is not a readable attribute&apos;) # 计算密码散列值并赋值给passwo_hash @password.setter def password(self, password): self.password_hash = generate_password_hash(password) # 验证密码是否正确 def verify_password(self, password): return check_password_hash(self.password_hash, password) 注意：User模型中的password属性为只写，不能读取。当给password赋值时，会调用generate_password_hash()函数计算散列值，并赋值给password_hash字段。可见下例。 2. 在shell中测试：12345678910111213(venv) $ python manage.py shell&gt;&gt;&gt; u = User()&gt;&gt;&gt; u.password = &apos;cat&apos; # 根据密码`&apos;cat&apos;`计算散列值并赋值给password_hash字段&gt;&gt;&gt; u.password_hash&apos;pbkdf2:sha1:1000$duxMk......928bed&apos;&gt;&gt;&gt; u.verify_password(&apos;cat&apos;)True&gt;&gt;&gt; u.verify_password(&apos;dog&apos;)False&gt;&gt;&gt; u2 = User()&gt;&gt;&gt; u2.password = &apos;cat&apos;&gt;&gt;&gt; u2.password_hash&apos;pbkdf2:sha1:1000$UjvnGe......75ee89&apos; 注意：即使用户u和用户u2都使用了相同的密码，但他们的密码散列值是不一样的。 3. tests/test_user_model.py支持密码散列测试：12345678910111213141516171819202122232425import unittestfrom app.models import Userclass UserModelTestCase(unittest.TestCase): def test_password_setter(self): u = User(password = &apos;cat&apos;) self.assertTrue(u.password_hash is not None) def test_no_password_getter(self): u = User(password=&apos;cat&apos;) with self.assertRaises(AttributeError): u.password def test_password_verification(self): u = User(password=&apos;cat&apos;) self.assertTrue(u.verify_password(&apos;cat&apos;)) self.assertFalse(u.verify_password(&apos;dog&apos;) def test_password_salts_are_random(self): u = User(password=&apos;cat&apos;) u2 = User(password=&apos;dog&apos;) self.assertTrue(u.passwors_hahs != u2.password_hash) 8.3 创建认证蓝本将与用户认证系统相关的路由定义在auth蓝本中。 1. 在app/auth/__init__.py中创建蓝本：12345from flask import Blueprintauth = Blueprint(&apos;auth&apos;, __name__)from app.auth import views 2. 在app/auth/views.py中定义蓝本中的路由和视图函数：123456from flask import render_templatefrom app.auth import auth@auth.route(&apos;/login&apos;)def login(): return render_template(&apos;auth/login.html&apos;) 注意：如果配置了多个模板文件夹，render_tempalte()函数首先会搜索程序配置的模板文件夹，然后再搜索蓝本配置的模板文件夹。 3. 在app/__init__.py中注册蓝本：12345678# ...def create_app(config_name): # ... from app.auth import auth as auth_blueprint app.register_blueprint(auth_blueprint, url_prefix=&apos;/auth&apos;) return app 注意：注册蓝本时，url_prefix参数是可选参数，使用这个参数后，蓝本中定义的理由都会加上指定的前缀。如该例中，/login路由会注册成/auth/login，完整的URL就变成http://127.0.0.1:5000/auth/login。 8.4 使用Flask-Login认证用户用户登录程序后，他们的认证状态要被记录下来，这样浏览不同的页面时才能记住这个状态。 8.4.1 准备用于登录的用户模型要想使用Flask-Login扩展，程序的User模型必须实现以下几个方法：表8-1 Flask-Login要求实现的用户方法|方法 | 说明 ||———|———-||is_authenticated | 如果用户已经登录，必须返回True，否则返回False||is_active | 如果允许用户登录，必须返回True，否则返回False。如果禁用账户，可以返回False||is_anonymous | 对普通用户必须返回False||get_id() | 必须返回用户的唯一标识符，使用Unicode编码字符串| Flask-Login提供了一个UserMixin类，其中包含这些方法的默认实现，且能满足大多数需求。 1. 在app/models.py中修改User模型，支持用户登录：1234567891011from flask_login import UserMixin# ...# 继承UserMixin类class User(UserMixin, db.models): __tbalename__ = &apos;users&apos; id = db.Column(db.Integer, primary_key=True) email = db.Column(db.String(64), unique=True, index=True) username = db.Column(db.String(64), unique=True, index=True) password_hash = db.Column(db.String(128)) role_id = db.Column(db.Integer, db.ForeignKey(&apos;roles.id&apos;) 2. 在app/__init__.py工厂函数中初始化Flask-Login：1234567891011121314from flask_login import LoginManager# ...login_manager = LoginManager()login_manager.session_protection = &apos;strong&apos;login_manager.login_view = &apos;auth.login&apos;def create_app(config_name): # ... login_manager.init_app(app) # ... return app LoginManager对象的session_protection属性可以设为None、&#39;basic&#39;、&#39;strong&#39;，以提供不同安全等级防止用户会话遭篡改。设为&#39;strong&#39;时，Flask-Login会记录客户端IP地址和浏览器的用户代理信息，如果发现异动，就登出用户。 login_view属性设置登录页面的端点。 3. Flask-Login要求程序实现一个回调函数，使用指定的标识符加载用户。在app/models.py中定义加载用户的回调函数：123456from app import login_manager# ...@login_manager.user_loaderdef load_user(user_id): return User.query.get(int(user_id)) 加载用户的回调函数接收以Unicode字符串形式表示的用户标识符。如果能找到用户，则返回用户对象，否则返回None。 8.4.2 保护路由1. 可以在路由中使用Flask-Login提供的login_required修饰器，使得路由只让认证用户访问（即访问被注册的路由时要先登录用户），如：123456from flask_login import login_required@app.route(&apos;/secret&apos;)@login_requireddef secret(): return &apos;Only authenticated users are allowed!&apos; 或者见8.6.2 发送确认邮件中的第三点。 8.4.3 定义登录表单该表单包括一个用于输入电子邮件地址的文本字段、一个密码字段、一个“记住我”复选框、提交按钮。 1. 在app/auth/forms.py中定义登录表单：123456789from flask_wtf import Formfrom wtforms import StringField, PasswordField, BooleanField, SubmitFieldfrom wtforms.validators import Required, Length, Emailclass LoginForm(Form): email = StringField(&apos;Email&apos;, validators=[Required(), Length(1,64), Email()]) password = PasswordField(&apos;Password&apos;, validators=[Required()]) remember_me = BooleanField(&apos;Keep me logged in&apos;) submit = SubmitField(&apos;Log In&apos;) 接下来在模板中渲染表单即可。 2. 在app/templates/base.html导航条中使用Jinja2条件语句，根据当前用户的登录状态显示“Sign In”或“Sign Out”：1234567891011&lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &#123;% if current_user.is_authenticated %&#125; &lt;li&gt; &lt;a href=&quot;&#123;&#123; url_for(&apos;auth.logout&apos;) &#125;&#125;&quot;&gt;Sign Out&lt;/a&gt; &lt;/li&gt; &#123;% else %&#125; &lt;li&gt; &lt;a href=&quot;&#123;&#123;url_for(&apos;auth.login&apos;) &#125;&#125;&quot;&gt;Sign In&lt;/a&gt; &lt;/li&gt; &#123;% endif %&#125;&lt;/ul&gt; 重点注意：变量current_user是由Flask-Login定义的，而且在视图函数和模板中自动可用。 8.4.4 登录用户1. 在app/auth/views.py中定义登录路由：123456789101112131415161718192021from flask import render_template, redirect, request, url_for, flashfrom flask_login import login_user # 导入登录用户函数（由Flask-Login提供）from app.auth import authfrom app.models import Userfrom app.auth.froms import LoginForm@auth.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def login(): form = LoginForm() if form.validate_on_submit(): user = User.query.filter_by(email=form.email.data).first() # 判断用户是否存在、密码是否正确 if user is not None and user.verify_password(form.password.data): # login_user()函数由Flask-Login提供 # 若用户存在以及密码正确，则调用login_user()函数， # 在用户会话中把用户标记为已登录状态 login_user(user, form.remember_me.data) # 返回原先的地址或者主页index return redirect(request.args.get(&apos;next&apos;) or url_for(&apos;main.index&apos;) flash(&apos;Invalid usernane or password&apos;) return render_template(&apos;auth/login.html&apos;, form=form) 重定向的URL有两种可能：（1）是用户访问未授权的URL时会显示登录表单，Flask-Login会把原本的地址保存在request.args字典的next键中，可用get()方法获取。（2）是如果next的值为空，则重定向到主页。 2. 在app/templates/auth/login.htm中渲染登录表单：123456789101112&#123;% extends &quot;base.html&quot; %&#125;&#123;% import &quot;bootstrap/wtf.html&quot; as wtf %&#125;&#123;% block title %&#125;Flasky - Login&#123;% endblock %&#125;&#123;% block page_content %&#125;&lt;div class=&quot;page_header&quot;&gt; &lt;h1&gt;Login&lt;/h1&gt;&lt;/div&gt;&lt;div class=&quot;col-md-4&quot;&gt; &#123;% wtf.quick_form(form) &#125;&#125;&lt;/div&gt;&#123;% endblock %&#125; 8.4.5 登出用户1. 在app/auth/views.py中定义登出路由：123456789from flask_login import logout_user, login_required# ...@auth.route(&apos;/logout&apos;)@login_requireddef logout(): logout_user() flash(&apos;You have been logged out.&apos;) return redirect(url_for(&apos;main.index&apos;) Flask-Login提供的logout_user()函数：删除并重设用户会话。 8.4.6 测试登录（在shell中测试）1. 在app/templates/index.html中为已登录的用户显示一个欢迎消息：123456Hello,&#123;% if current_user.is_authenticates %&#125; &#123;&#123; current_user.username &#125;&#125;&#123;% else %&#125; Stranger&#123;% endif %&#125;! 2. 在shell中注册新用户（因为未创建用户注册功能，所以可在shell创建新用户）：1234(venv)$ python manage.py shell&gt;&gt;&gt; u = User(email=&apos;123456@qq.com&apos;, username=&apos;john&apos;, password=&apos;cat&apos;)&gt;&gt;&gt; db.session.add(u)&gt;&gt;&gt; db.session.commit() 3. 打开登录页面进行登录登录后即可显示欢迎消息。 8.5 注册新用户8.5.1 添加用户注册表单注册页面使用的表单要求用户输入电子邮件地址、用户名和密码。 1. 在app/auth/forms.py中定义用户注册表单：1234567891011121314151617181920212223from falsk_wtf import Formfrom wtforms import StringField, PasswordField, BooleanField, SubmitFieldfrom wtforms.validators import Required, Length, Email, Regexp, EqulTofrom wtforms import ValidationErrorfrom app.models import Userclass RegistrationForm(Form): email = StringField(&apos;Email&apos;, validators=[Required(), Length(1,64), Email()]) username = StringField(&apos;Username&apos;, validators=[REquired(), Length(1,64), Regexp(&apos;^[A-Za-z][A-Za-z0-9_.]*$&apos;, 0, &apos;Usernames must have only letters, numbers, dots or underscores&apos;)]) password = PasswordField(&apos;Password&apos;, validators=[Required(), EqualTo(&apos;password2&apos;, message=&apos;Password must match&apos;)]) password2 = PasswordField(&apos;Confirm password&apos;, validators=[Required()]) submit = SubmitField(&apos;Register&apos;) def validate_email(self, field): if User.query.filter_by(email=field.data).first(): raise ValidationError(&apos;Email already registered&apos;) def validate_username(self, field): if User.query.filter_by(usernanme=field.data).first(): raise ValidationError(&apos;Username already in use&apos;) Regexp()验证函数确username字段只包含字母、数字、下划线、点号。该验证函数正则后面的两个参数分别是正则的旗标和验证失败时显示的错误信息。 EqualTo()验证函数确保两个密码字段一致。这个验证函数要附属到两个密码字段中的一个，另一个则作为参数传入。 该表单还自定义了两个验证函数，以方法的形式实现。如果表单类中定义了以validate_开头且后面跟着字段名的方法，这个方法就和常规的验证函数一起调用。 2. 渲染template/auth/register.html表单：和之前渲染表单一样，使用wtf.quick_form(form)渲染。 3. 在template/auth/login.html中添加注册页面链接：1234567# ...&lt;p&gt; New User? &lt;a href=&quot;&#123;&#123; url_for(&apos;auth.register&apos;) &#125;&#125;&quot;&gt; Click here to register &lt;/a&gt;&lt;/p&gt; 8.5.2 注册新用户（定义注册新用户的路由）1. 在app/auth/views.py中定义用户注册路由：12345678910111213# ...@auth.route(&apos;/register&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def register(): form = RegistationForm() if form.validate_on_submit(): user = User(email=form.email.data, username=form.username.data, password=form.password.data) db.session.add(user) flash(&apos;You can login now.&apos;) return redirect(url_for(&apos;auth.login&apos;)) return render_template(&apos;auth/register.html&apos;, form=form) 8.6 确认账户（验证邮箱）用户验证邮箱之前，新账户先被标记成待确认状态。账户确认过程，一般会要求用户点击一个包含确认令牌的特殊URL链接。 8.6.1 使用itsdangerous生成确认令牌思路：确认邮件最简单的URL链接是http://www.example.com/auth/confirm/&lt;id&gt;这种形式，其中id是数据库分配给用户的数字id。用户点击链接后，处理这个路由的视图函数将id作为参数进行确认，然后将用户账户状态更新为已确认。 存在问题：不安全。只要用户能判断确认链接的格式，就可以随便指定URL中的id，从而验证确认随意账户。 解决方法：把URL中的id换成将相同信息安全加密后得到的令牌。 解决工具：使用itsdangerous包中的TiemdJSONWebSignatureSerializer类提供的dumps()方法和load()方法。 1. 在app/models.py中的User模型中添加验证用户功能：123456789101112131415161718192021222324252627282930from itsdangerous import TimedJSONWebSignatureSerializer as Serializerfrom falsk import current_appfrom app import dbclass User(db.models): # ... confirmed = db.Column(db.Boolean, default=False) # 使用dumps()生成加密令牌 def generate_confirmation_token(self, expiration=3600): s = Serializer(current_app.config[&apos;SECRET_KEY&apos;], expires_in=expiration) return s.dumps(&#123;&apos;confirm&apos;: self.id&#125;) # 解码加密令牌并验证原始数据是否与存储中current_app中已登录用户数据一致 def confirm(self, token) s = Serializer(current_app.config[&apos;SECRET_KEY&apos;]) try: data = s.loads(token) # 解码令牌返回原始数据 except: return False # 判断原始数据是否跟已登录用户id一致，防止恶意验证 if data.get(&apos;confirm&apos;) != self.id: return False self.confirmed = True # 更新confirmed字段 db.session.add(self) return True TimedJSONWebSignatureSerializer类生成具有国旗时间的JSON Web签名。这个类的构造函数可接受两个参数：密匙（可用Flask中的SECRET_KEY密匙）和expires_in（设置过期时间，单位秒）。 dumps()方法为指定的数据生成一个加密签名，然后再对数据和签名进行序列化，生成令牌字符串。 loads()方法的唯一参数是令牌字符串。这个方法会检验签名和过期时间，如果通过则返回原始数据，否则抛出异常。 8.6.2 发送确认邮件1. 在app/auth/views.py中使register路由支持邮件发送：123456789101112131415161718from app.email import send_email# ...@auth.route(&apos;/register&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def register(): form = RegistrationForm() if form.validate_on_submit(): # ... db.session.add(user) # 在请求结束前先提交User实例，因为提交后才能得到新用户的id， # 从而向generate_confirmation_token方法传参得到token db.session.commit() token = user.generate_confirmation_token() send_mail(user.email, &apos;Confirm Your Account&apos;, &apos;auth/email/confirm&apos;, user=user, token=token) flash(&apos;A confirmation email has been sent to you by email.&apos;) return redirect(url_for(&apos;main.index&apos;)) return render_template(&apos;auth/register.html&apos;, form=form) 重点注意：即便通过设置SQLALCHEMY_COMMIT_ON_TEARDOWN=True，程序可以在请求末尾自动提交数据库变化，但是这里也要调用db.session.commit()提交变化。因为提交数据库后才能得到新用户的id值，从而将id值传参给generate_confirmation_token()方法生成令牌。 2. 在app/template/auth/email/confirm.txt中编写确认邮件文本：1234567891011Welcome to Flasky!To confirm your account please click on the following link:&#123;&#123; url_for(&apos;auth/confirm&apos;, token=token, _external=True) &#125;&#125;Sincerely,The Flasky TeamNote: replies to this email address ate not monitored. 注意：默认情况下，url_for()生成的是相对URL，如url_for(&#39;auth.confirm&#39;, token=&#39;abc&#39;)，返回的是/auth/confirm/abc&#39;，显然，这不是能够在电子邮件中发送正确的URL。所以需要使用_external=True参数，从而生成完整的URL。 3. 在app/auth/views.py中定义确认用户的路由：123456789101112131415161718from flask_login import current_user# ...# 路由中的token将会被作为参数传入视图函数中@auth.route(&apos;/confirm/&lt;token&gt;&apos;)@login_requireddef confirm(token): # 判断user中是否已经确认过 if current_user.confirmed: return redirect(url_for(&apos;main.index&apos;)) # 判断调用confirm()方法返回的是True还是False，从而验证用户 if current_user.confirm(token): # 提交数据库变化（很重要） db.session.commit() flash(&apos;You have confirm your account. Thanks!&apos;) else: flash(&apos;The confirmation link is invalid or has expired.&apos;) return redirect(url_for(&apos;main.index&apos;) Flask-Login提供的login_required修饰器会保护这个路由：用户点击确认邮件中的链接后，要先登录，然后才能执行这个视图函数。 4. 在app/auth/views.py中在before_app_request处理程序中过滤未确认的账户：每个程序都可以决定用户在确认账户之前可以有哪些操作，如允许未确认的用户登录，并显示一些内容，但更进一步的看更多内容需要先确认账户。这一步可以使用Flask提供的before_request钩子完成。对于蓝本来说，before_request钩子只能应用到属于蓝本的请求，若想在蓝本中使用针对程序全局请求的钩子，需要使用before_app_request修饰器。 12345678910111213141516# ...@auth.before_app_requestdef before_request(): if current_user.is_authenticated \\ # 判断用户是否已登录 and not current_user.confirmed \\ # 判断用户账户是否已验证 and request.endpoint[:5] != &apos;auth.&apos; \\ # 判断请求的端点是否不再认证蓝本中 and request.endpoint != &apos;static&apos;: return redirect(url_for(&apos;auth.unconfirmed&apos;)) @auth.route(&apos;/unconfirmed&apos;)def unconfirmed(): if current_user.is_anonymous or current_user.confirmed: return redirect(url_for(&apos;main.index&apos;)) return render_template(&apos;auth/unconfirmed.htm&apos;) 当满足一下三个条件时，before_app_request处理程序会拦截请求，将请求重定向到/auth/unconfirmed路由，显示一个验证账户相关信息的页面：（1）用户已登录（2）用户的账户还未验证（3）请求的端点（使用request.endpoint获取）不在认证蓝本（/auth)中。 5. 在app/auth/views.py中支持重新发送验证邮件：12345678910# ...@auth.route(&apos;/confirm&apos;)@login_requireddef resend_confirmation(): token = current_user.generate_confirmation_token() send_email(current_user.email, &apos;Confirm Your Account&apos;, &apos;auth/email/confirm&apos;, user=current_user, token=token) flash(&apos;A new confirmation email has been sent to you by email.&apos;) return redirect(url_for(&apos;main.index&apos;)) 这个路由也用login_required保护（要先登录才能执行视图函数），确保程序知道再次发送验证邮件的是哪个用户。 重点注意：凡是修改了数据库模型，为了使新模型能够应用到新程序，要使用Flask-Migrate进行数据库迁移，从而实现更新数据库的效果。 8.7 管理账户修改密码、重设密码、修改电子邮件地址，具体代码实现可查看git仓库。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第七章 大型程序的结构","date":"2017-11-25T10:17:41.000Z","path":"2017/11/25/把《Flask Web开发》读薄系列之第七章 大型程序的结构/","text":"7.1 项目结构多文件Flask程序的结构：1234567891011121314151617181920|-flasky |-app/ |-init__.py |-templates/ # 模板 |-static/ # 静态文件 |-main/ # 蓝本，名字可更改 |-__init__.py |-errors.py # 路由，视图函数 |-forms.py # 表单 |-views.py # 路由器，视图函数 |-email.py # 邮件支持 |-models.py # 数据库模型 |-migrations # 数据库迁移 |-tests/ # 单元测试 |-__init__.py |-test*.py |-venv/ |-requirements.txt # 依赖包文本 |-config.py # 配置 |-manage.py # 启动程序 7.2 配置config.py在前面的章节中，我们在hello.py中是使用字典状结构配置的（如app.config[&#39;FLASKY_ADMIN&#39;] = 12345678@qq.com），现在我们把相关配置提取出来，在config.py中使用层次结构的配置类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546import osbasedir = os.path.abspath(os.path.dirname(__file__))# 设置通用配置class Config: SECRET_KEY = os.environ.get(&apos;SECRET_KEY&apos;) or &apos;hard to guess string&apos; SQLALCHEMY_COMMIT_ON_TEARDOWN = True FLASK_MAIL-SUBJECT_PREFECT = &apos;[Flasky]&apos; FLASKY_MAIL_SENDER = &apos;Flasky Admin 123456789@qq.com&apos; FLASK_ADMIN = os.environ.get(&apos;FLASKY_ADMIN&apos;) @staticmethod # init_app()可对当前环境的配置初始化，参数是程序实例 def init_app(app): pass # 开发环境配置（继承Config基类）class DevelopmentConfig(Config): DEBUG = True MAIL_SERVER = &apos;smtp.qq.com&apos; MAIL_PORT = 465 MAIL_USE_SSL = True MAIL_USENAME = os.environ.get(&apos;MAIL_USENAME&apos;) MAIL_PASSWORD = os.environ.get(&apos;MAIL_PASSWORD&apos;) SQLALCHEMY_DATABASE_URI = os.environ,get(&apos;DEV_DATABASE_URI&apos;) or \\&apos;sqlite:///&apos; + os.path.join(basedir, &apos;data-dev.sqlite&apos;) # 测试环境配置（继承Config基类） class TestingConfig(Config): TESTING = True SQLALCHEMY_DATABASE_URI = os.environ,get(&apos;TEST_DATABASE_URI&apos;) or \\&apos;sqlite:///&apos; + os.path.join(basedir, &apos;data-test.sqlite&apos;) # 生产环境配置（继承Config基类） class ProductionConfig(Config): SQLALCHEMY_DATABASE_URI = os.environ,get(&apos;DATABASE_URI&apos;) or \\&apos;sqlite:///&apos; + os.path.join(basedir, &apos;data.sqlite&apos;) # 配置字典config = &#123; &apos;development&apos;: DevelopmentConfig, &apos;testing&apos;: TestingConfig, &apos;production&apos;: ProductionConfig, &apos;default&apos;: DevelopmentConfig &#125; 7.3 程序包（app文件夹）程序包用来保存程序的所有代码、模板和静态文件。 7.3.1 使用程序工厂函数存在问题：在单脚本中开发程序的缺点是：脚步在运行时，程序实例已经创建，已经不能修改配置，自然也无法动态修改配置。这样也不利于单元测试。 解决思路：延迟创建程序实例。解决方法：把创建过程移到可显式调用的工厂函数中。这样不仅可以给脚步流出配置程序时间，还能创建多个程序实例。 程序的工厂函数在app包的构造文件（__init__.py）中定义。app/__inti__.py如下：12345678910111213141516171819202122232425262728from flask import Flaskfrom flask_bootstrap import Bootstrapfrom flask_mail import Mailfrom flask_moment import Momentfrom flask_sqlalchemy import SQLAlchemyfrom config import configbootstrap = Bootstrap()mail = Mail()moment = Moment()db = SQLAlchemy()# 定义工厂函数，参数为程序使用的配置环境名def create_app(config_name): app = Flask(__name__) # 根据配置环境名获取对应的配置类从而获取相应的配置（类变量） app.config.from_object(config[&apos;config_name&apos;] # 使用配置类中的init_app()方法初始化配置 config[&apos;config_name&apos;].init_app(app) bootstrap.init_app(app) mail.init_app(app) moment.init_app(app) db.init_app(app) # 附加路由和自定义的错误页面 return app config.py文件中定义的配置类，可以使用app.config配置对象提供的from_object()方法直接导入程序。程序创建（app=Flask(__name__))并配置好后，就能初始化Flask拓展（在Flask拓展实例对象上调用init_app()方法，如bootstrap.init(app)） 工厂函数返回的是程序实例，不过此时工厂函数创建的程序实例还不完整，因为还没有路由和自定义的错误页面处理程序（简单来说就是缺少路由）。 7.3.2 在蓝本中实现程序功能存在问题：在单脚本程序中，程序实例存在于全局作用域中，路由可以直接使用app.route修饰器定义，但是现在程序实例时在运行时创建的（调用create_app()函数），这时定义路由已经太晚了（因为只有调用create_app()函数创建实例后才能使用app.route修饰器，而路由又要定义在create_app()函数里） 解决方法：使用蓝本。蓝本和程序类似，也可以定义路由，但不同的是：在蓝本中定义的路由会处于休眠状态，直到调用app.register_blueprint()方法把蓝本注册到程序后，路由在真正称为程序的一部分。 理解蓝本：蓝本通常作用于相同的URL前缀，如user/id、user/profile这样的地址，都是以/user开头，它们是一组用户相关的操作，那么就可以放在一个模块中。大多数项目都是把蓝本当做拆分视图用的。 使用位于全局作用域中的蓝本时，定义路由方法和单脚本程序基本一样（不同之处下面会讲到） 创建蓝本app/main/__init__.py:123456from flask import Blueprintmain = Blueprint(&apos;main&apos;, __name__)# 导入view和error模块，导入之后就能将路由和错误处理程序与蓝本关联起来from . import views, errors Blueprint()类的第一个参数是蓝本名字，第二个参数是篮本所在的包或模块（一般使用__name__即可）。 注意： 像view和error这些模块，为了避免循环导入，要在app/main/__init.py__的末尾处导入，因为在view.py和error.py中还要导入蓝本main。 app/main/error.py如下： 12345678910from flask import render_templatefrom . import main@main.app_errorhandler(404)def page_not_found(e): return render_template(&apos;404.html&apos;), 404 @main.app_errorhandler(500)def internal_server_error(e): return render_template(&apos;500.html&apos;), 500 注意：在蓝本中编写错误处理程序稍有不同，如果是使用errorhandler修饰器，那么只有蓝本中的错误才能触发处理程序。因此要想注册程序全局的错误处理程序，必须使用app_errorhandler修饰器。 app/main/view.py如下： 12345678910111213141516from datetime import datetimefrom flask import render_template, session, redirect, url_for, current_appfrom . import mainfrom .froms import NameFormfrom .. import dbfrom ..models import User@main.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def index(): form = NmaeForm() if form.validate_on_submit(): # ... return redirect(url_for(&apos;.index&apos;) return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;), know=session.get(&apos;know&apos;, Flase), current_time=datetime.utcnow()) 注意：在蓝本中编写视图函数主要有两点不同：（1）和前面的错误处理程序一样，路由修饰器由蓝本提供（体现在main.route()，而不是app.route()）。（2）url_for()函数的第一个参数。url_for()函数的第一个参数时路由的端点名，在程序中默认为视图函数的名字（所以在单脚本中可以url_for(&#39;index&#39;)），但是在蓝本中，Flask会为蓝本中的全部端点加上一个命名空间（也就是蓝本的名字），这样做是为了可以在不同的蓝本中使用相同的端点名（函数名）定义视图函数。所以该蓝本中视图函数index()注册的端点名是main.index，因此需要使用url_for(&#39;main.index&#39;)，也可以简写为url_for(&#39;.index&#39;)（前提是同一蓝本，跨蓝本的话必须使用带有命名空间的端点名）。 另外：模板中的hrfe属性中的链接，使用url_for()获取的，其中参数也是同样写端点名。 重点注意：如果在其他地方（如这里的app/main/view.py、app/email.py等）需要用到程序实例app，均需使用from flask import current_app来导入程序上下文。 2.在工厂函数create_app()中把蓝本注册到程序上，app/__init__.py如下： 12345678910# ...def create_app(config_name): # ... # 导入整个包 from .main import main as main_blueprint app.register_blueprint(main_blueprint) return app 7.4 启动脚本manage.py用于启动脚本：1234567891011121314151617181920#!/usr/bin/env pythonimport osfrom app import create_app, dbfrom app.models import User, Rolefrom flask_script import Manager, Shellfrom flask_migrate import Migrate, MigrateCommand# 获取配置名，并创建程序app = create_app(os.getenv(&apos;FLASK_CONFIG&apos;) or &apos;default&apos;)manager = Manager(app)migrate = Migrate(app, db)def make_shell_context(): return dict(app=app, db=db, User=User, Role=Role)manager.add_command(&apos;shell&apos;, Shell(make_context=make_shell_context))manager.add_command(&apos;db&apos;, MigrateCommand)if __name__ == &apos;__main__&apos;: manager.run() 在脚本中加入了#!/usr/bin/env python声明，因此在Unix系统中可以直接通过./manage.py命令运行脚步，而无需使用python manage.py命令。 7.5 需求文件requirements.txt文件：用于记录所有依赖包及其精确的版本号。可以使用如下命令自动生成这个文件：(venv) $ pip freeze &gt; requirements.txt 当要创建同一个环境时，可以使用如下命令：(venv) $ pip install -r requirements.txt 7.6 单元测试 tests/test_basics.py文件如下： 12345678910111213141516171819202122232425import unittestfrom flask import current_appfrom app import create_app, dbclass BasicsTestCase(unittest.TestCase): # 创建一个测试环境，并激活程序上下文，并创建数据库 def setUp(self): self.app = create_app(&apos;testing&apos;) self.app_context = self.app.app_context() self.app_context.push() db.create_all() # 删除数据库、程序上下文 def tearDown(self): db.session.remove() db.drop_all() self.app_context.pop() # 测试程序实例是否存在 def test_app_exists(self): self.assertFalse(current_app is None) # 测试程序的环境是否为TESTING def test_app_is_testing(self): self.assertTrue(current_app.config[&apos;TESTING&apos;]) setUp()和tearDown()方法分别在各测试前后运行。函数名字以test_开头的函数都作为测试执行。 运行单元测试。可在manage.py文件中添加一个自定义命令，用于执行测试： 123456789# ...@manager.commanddef test(): # 字符串内容会显示在帮助消息中 &quot;&quot;&quot;Run the unit tests&quot;&quot;&quot; import unittest tests = unittest.TestLoader().discover(&apos;tests&apos;) unittest.TextRunner(verbosity=2).run(tests) manager.command修饰器修饰的函数名就是命令名。因此可以使用如下命令运行测试： 12345678(venv) $ python manage.py testtest_app_exits (test_basics.BasicsTestCase) ... oktest_app_is_testing (test_basics.BasicsTestCase) ... ok--------------------------------------------------------Ran 2 tests in 0.001sOK 7.7 创建数据库首先需要在环境变量中定义所需要的数据库URI，然后再创建数据库。 不管从哪里获取数据库URI，都要在新数据库中创建数据表，如果使用Flask-Migrate跟踪迁移，可以使用如下命令创建数据表或者更新到最新版本：(venv) $ python manage.py db upgrade","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第六章 电子邮件","date":"2017-11-14T12:57:23.000Z","path":"2017/11/14/把《Flask Web开发》读薄系列之第六章 电子邮件/","text":"使用Flask-Mail提供电子邮件支持表6-1 Flask-Mail SMTP服务器的配置 配置 默认值 说明 MAIL_SERVER localhost 邮件服务器主机名或IP地址 MAIL_PORT 25 电子邮件服务器的端口 MAIL_USE_TLS False 启用传输层安全（TLS）协议 MAIL_USE_SSL False 启用安全套接层（SSL）协议 MAIL_USENAME None 邮件账户的用户名 MAIL_PASSWORD None 邮件账户的授权码 在hello.py中配置Flask-Mail使用QQ邮箱： 12345678import os# ...app.config[&apos;MAIL_SERVER&apos;] = &apos;smtp.qq.com&apos;app.config[&apos;MAIL_PORT&apos;] = 465app.config[&apos;MAIL_USE_SSL&apos;] = Trueapp.config[&apos;MAIL_USERNAME&apos;] = os.environ.get(&apos;MAIL_USERNAME&apos;)app.config[&apos;MAIL_PASSWORD&apos;] = os.environ.get(&apos;MAIL_PASSWORD&apos;) 注意：千万不要把账号密令直接写在脚本中，应该从环境变量中导入。 初始化Flask-Mail： 1234from flask_mail import Mail# ...mail = Mail(app) 在环境变量中定义MAIL_USERNAME和MAIL_PASSWORD： 12(venv) $ export MAIL_USERNAME=&apos;12345678@qq.com&apos;(venv) $ export MAIL_PASSWORD=&apos;qwertyuiop&apos; 此时可以使用echo命令打印出来检查一下：1234(venv) $ echo $MAIL_USERNAME&gt;&gt;&gt; &apos;12345678@qq.com&apos;(venv) $ echo $MAIL_PASSWORD&gt;&gt;&gt; &apos;qwertyuiop&apos; 定义环境变量后，此时在同一个终端中执行python hello.py shell命令，便能获取到想要的环境变量。 注意：如果定义好环境变量后把终端关闭再重新打开，那么此时是没有上次定义的环境变量的。所以需要在同一个终端中执行。 如何让QQ邮箱开启SMTP功能，可以参考flask-mail常见的邮箱配置问题解决 在Python shell中发送电子邮件在上一个终端中，发送电子邮件：12345678(venv) $ python hello.py shell&gt;&gt;&gt; from flask_mail import Message&gt;&gt;&gt; from hello import mail&gt;&gt;&gt; msg = Message(&apos;test subject&apos;, sender=&apos;12345678@qq.com&apos;, recipients=[&apos;87654321@qq.com&apos;])&gt;&gt;&gt; msg.body = &apos;test body&apos;&gt;&gt;&gt; msg.html = &apos;&lt;p&gt;test body&lt;/p&gt;&apos;&gt;&gt;&gt; with app.app_context():··· mail.send(msg) 注意：在Flask-Mail中的send()函数使用current_app（程序上下文），因此在shell中发送邮件，需要激活程序上下文。 在程序中集成发送电子邮件功能 定义用于发邮件的函数，使hello.py支持电子邮件： 12345678910111213from flask_mail import Message# ...# 给邮件标题添加一个前缀app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] = &apos;[Flasky]&apos;# 定义发件人app.config[&apos;FLASKY_MAIL_SENDER&apos;] = &apos;12345678@qq.com&apos;def send_email(recipients, subject, template, **kwargs): msg = Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] + subject, sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;], recipients=[recilients]) msg.body = render_template(template + &apos;.txt&apos;, **kwargs) msg.html = render_template(template + &apos;.html&apos;, **kwargs) mail.send(msg) 邮件有纯文本.txt，也有HTML文本.html，客户端显示哪个，取决于邮件客户端的设置。 拓展：为什么send()函数中需要**kwargs？**kwargs的作用是什么？答：（1）因为我们不确定模板中需要什么变量参数，在此例中，模板需要的时user这个参数，但是如果换成别的模版，它不仅需要user参数，也需要其他一些参数（如datatime等，关键取决于模板设计成什么样），此时如果我们死死地把send_email()函数写成send_email(recipient, subject, template, user)，那么就失去了灵活性，当换成其他模版时，datatime参数也就无法传入了，因此send()函数需要**kwargs。（2）**kwargs的作用是：当我们不知道需要往函数中传入多少个关键字参数或者想以字典的形式作为参数时，我们可以用**kwargs，这样我们就可以根据实际情况需要，往函数中传入特定个数的参数（数量使具体情况而定）。 结合视图函数发送电子邮件： 1234567891011121314151617181920212223242526# ...# 定义收件人为Flasky的管理员app.config[&apos;FLASKY_ADMIN&apos;] = os.environ.get(&apos;FLASKY_ADMIN&apos;)# ...@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]def index(): form = NameForm() if form.validate_on_submit(): session[&apos;name&apos;] = form.name.data # 查找数据库中是否有该用户名，如果没有，就向数据库中添加新用户， # 因为前面已经设置了SQLALCHEMY_COMMIT_ON_TEARDOWN，所以当请求结束时会自动提交事务 user = User.query.filter_by(user_name=form.name.data).first() if user is None: # 插入数据库 user = User(user_name=form.name.data) db.session.add(user) # 用于模板中判断是显示Pleased to meet you 还是 Happy to see you again session[&apos;known&apos;] = Flase # 如果收件人不为空，则发送邮件 if app.config[&apos;FLASKY_ADMIN&apos;]: send_email(app.config[&apos;FLASKY_ADMIN&apos;], &apos;New User&apos;, &apos;mail/new_user&apos;, user=user) else: session[&apos;konwn&apos;] = True return redirect(url_for(&apos;index&apos;) return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;), known=session.get(&apos;known&apos;, Flase)) 此时我们也需要定义环境变量FLASKY_ADMIN：(venv) $ export FLASKY_ADMIN=&#39;12345678@qq.com&#39; template文件夹下的模板文件mail/new_user有两个，分别为new_user.txt和new_user.html。 new_user.txt如下：1There has a new user that name is &#123;&#123; user.user_name &#125;&#125; new_user.html如下：1&lt;h1&gt;There has a new user that name is &#123;&#123; user.user_name &#125;&#125;&lt;/h1&gt; 异步发送电子邮件为了避免处理请求过程中不必要的延迟，我们可以把发送电子邮件的函数移到后台线程中处理：1234567891011121314from threading import Thread# ...def send_async_email(app, msg): with app.app_context(): mail.send(msg) def send_email(recipients, subject, template, **kwargs): msg = Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] + subject, sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;], recipients=[recilients]) msg.body = render_template(template + &apos;.txt&apos;, **kwargs) msg.html = render_template(template + &apos;.html&apos;, **kwargs) thr = Thread(target=send_async_email, args=[app, msg]) thr.start() return thr 注意：由于在不同线程中执行mail.send()函数，就如前面在Python shell中发送电子邮件章节中提到，send()函数需要程序current_app（程序上下文）中执行，因此需要在执行send()函数的线程中使用app.app_context()人工创建current_app。 当需要发送大量电子邮件时，使用专门发送电子邮件的作业（如Celery任务队列）处理更合适。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第五章 数据库","date":"2017-11-14T12:56:25.000Z","path":"2017/11/14/把《Flask Web开发》读薄系列之第五章 数据库/","text":"5.1 SQL数据库表中有个特殊的列，称为主键，其值是表中各行的唯一标识符，表中还可以有称为外键的列，引用同一个表或不同表中某行的主键，行之间的这种联系称为关系，这是SQL数据库的基础。 5.2 NoSQL数据库所有不遵循上节所述关系模型的数据库统称为NoSQL数据库。NoSQL数据库一般使用集合Collection代替表，使用文档Document代替记录（行）。 NoSQL数据库可以减少表的数量，但却增加了数据重复量，但数据重复又可以提高查询速度。 5.3 使用SQL还是NoSQL视实际情况所需。 5.4 Python数据库框架数据库包：MySQL、Postgres、SQLite、Redis、MongoDB、CouchDB数据库抽象层代码包（ORM或ODM）：SQLAlchemy、MongoEngine 一般情况下，ORM和ODM对生产率的提升远远超过“把对象业务转换成数据库业务”而带来的性能降低。 5.5 使用Flask-SQLAlchemy管理数据库在Flask-SQLAlchemy中，使用哪种数据库，要通过URL指定。常用的数据库引擎采用的数据库URL格式如下： 表5-1 Flask-SQLAlchemy数据库URL 数据库引擎 URL MySQL mysql://username:password@hostname/database Postgres postgres://username:password@hostname/database SQLite(Unix) sqlite:////absolute/path/to/database SQLite(Windows) sqlite:///c:/absolute/path/to/database hostname可以是本地主机（localhost)，也可以是原创服务器。database表示要使用的数据库名称。 程序使用的数据库URL必须保存到Flask配置对象的SQLALCHEMY_DATABASE_URI键中。配置对象中有个SQLALCHEMY_COMMIT_ON_TEARDOWN键，将其设为True时，每次请求结束后都会自动提交数据库中的变动（相当于自动commit）。 初始化及配置SQLite如下：123456789101112form flask_sqlalchemy import SQLAlchemyimport os# ...# 获取文件当前文件父路径basedir = os.path.abspath(os.path.dirname(__file__))app = Flask(__name__)app.config[&apos;SQLALCHEMY_DATABASE_URI`] = &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data.sqlite&apos;)app.config[`SQLALCHEMY_COMMIT_ON_TEARDOWN`] = Truedb = SQLAlchemy(app) db对象是SQLAlchemy类的实例，表示程序所使用的数据库。 5.6 定义模型在ORM中，模型（相当于数据库表table）一般是个Python类，类中的属性对应数据库表中的列。 在hello.py中定义Role模型和User模型：123456789101112131415class Role(db.Model): __tablename__ &apos;roles&apos; id = db.Column(db.Integer, primary_key=True) role_name = db.Column(db.String(64), unique=True) def __repr__(self): return &apos;&lt;Role &#123;&#125;&gt;&apos;.format(self.role_name) def User(db.Model): __tablename__ = &apos;users&apos; id = db.Column(db.integer, primary_key=True) user_name = db.Column(db.String(64), unique=True, index=True) def __repr__(self): return &apos;&lt;User &#123;&#125;&gt;&apos;.format(self.user_name) 类变量__tablename__定义在数据库中使用的表名，如果没有定义，Flask-SQLAlchemy会使用一个默认名字，但该名字没有遵守使用复数形式进行命名的约定。 db.Column类构造函数的第一个参数是数据库列的类型（如Integer、String等），对应模型（即Python类）的对象类型（如int、str等） 表5-2 最常用的SQLAlchemy列类型 类型名称 对应Python类型 说明 Integer int 普通整数，一般时32位 Float int 浮点数 String str 变长字符串 Text str 变成字符串，对较长或不限长度的字符串做了优化 Unicode unicode 变长Unicode字符串 UnicodeText unicode 变长Unicode字符串，对较长货不限长度的字符串做了优化 Date datetime.data 日期 Time datetime.time 时间 DateTime datetime.datetime 日期和时间 db.Column中其余的参数可对列中的数据做一些配置或设置 表5-3 最常用的SQLAlchemy列选项 选项名 说明 primary_key 如果设为True，这列是主键 unique 如果设为True，这列不允许出现重复值 index 如果设为True，为这列创建索引，提高查询效率 nullable 如果设为True，这列允许使用空值；设为False，则不允许为空 default 为这列设置默认值 注意：Flask-SQLAlchemy要求每个模型都要定义主键。 5.7 关系定义一对多关系（Role对User）：1234567class Role(db.Model): # ... users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;) class User(db.Model): # .... role_id = db.Column(db.Integer, db.ForeignKey(&apos;roles.id&apos;) # 外键：roles表中的id 添加到Role模型中的类变量users代表这个关系（Role与User的关系）的面向对象视角，它将返回与具体Role实例相关联的用户（具体User实例）组成的列表。（如Role实例role_admin返回的users为[richard, john]，其中richard和john都是User实例，即role_admin.users = [richard,john]体现了面向对象视角的一对多关系） db.relationship()的第一个参数是这个关系的另一端对应的模型。如果模型尚未定义，可使用字符串形式指定。backref参数为&#39;role&#39;表明：在User模型中添加一个属性（或称为类变量）role（可理解成在User表中添加一列名为role的列。但实际查看数据库表时是看不到的），从而定义反向关系。注意：一般情况下，db.relationship()都能自行找到关系中的外键，有在某些情况下无法决定把哪一列作为外键。如User模型中有两列或以上的列定义为Role模型的外键，那么SQLAlchemy就不知道该使用哪列了。此时，你就要为db.relationship()提供额外参数，从而确定使用哪列外键。常用配置如表5-4。 表5-4 db.relationship()常用的SQLAlchemy关系选项 选项名 说明 backref 在关系的另一端模型中添加反向作用 primaryjoin 明确指定两个模型之间使用的联结条件。只在模凌两可的关系中需要指定 lazy 指定如何加载相关记录。可选值有：select（首次访问时按需加载），immediate（源对象加载后加载），joined（加载记录，但使用联结），subquery（立即加载，但使用子查询），noload（永不加载），dynamic（不加载记录，单提供加载记录的查询） userlist 如果设为Fales，不适用列表，而使用标量值 order_by 指定关系中记录的排序方式 secondary 指定多对多关系中关系表的名字 secondaryjoin SQLAlchemy无法自行决定时，指定多对多关系中的二级联结条件 一对一关系：可以用前面介绍的一对多关系表示，但调用db.relationship()时要把userlist设为False。多对一关系：可以用一对多关系表示，只是两个表对调。或者把外键和db.relationship()都放在“多”这一侧。多对多关系：需要用到第三张表（关系表）。 5.8 数据库操作需要在Python Shell中进行操作。 5.8.1 创建表123(venv)$ python hello.py shell&gt;&gt;&gt; from hello.py import db&gt;&gt;&gt; db.create_all() 如果修改模型（如增加了一列）后要把修改的地方应用到现在的数据库中，那么更新现有数据库表的粗暴方式是先删除旧表，在重新创建表：12&gt;&gt;&gt; db.drop_all()&gt;&gt;&gt; db.create_all() 但是这种方法会把数据库中原有的数据都删除掉。在5.11 使用Flask-Migrate实现数据库迁移中会介绍更新数据库更好的方式。 5.8.2 插入行1234567&gt;&gt;&gt; from hello import Role, User&gt;&gt;&gt; role_admin = Role(role_name=&apos;admin&apos;)&gt;&gt;&gt; role_moderator = Role(role_name=&apos;moderator&apos;)&gt;&gt;&gt; role_visitor = Role(role_name=&apos;visitor&apos;)&gt;&gt;&gt; user_richard = User(user_name=&apos;richard&apos;)&gt;&gt;&gt; user_john = User(user_name=&apos;john&apos;)&gt;&gt;&gt; user_david = User(user_name=&apos;david&apos;) 现在这些对象只存在于Python中，还没有写入数据库。因此id尚未赋值，所以print(role_admin.id)的结果为None。 要把对象写入数据库要分两步： 要把对象添加到会话(db.session)中:12&gt;&gt;&gt; db.session.add(role_admin)&gt;&gt;&gt; db.session.add(user_richard) 或者简写成：1&gt;&gt;&gt; db.session.add_all([role_moderator, role_visitor, user_john, user_david]) 调用commit()提交会话1&gt;&gt;&gt; db.session.commit() 此时对象已经写入数据库，再print(role_admin.id)时，它的结果时1。 调用db.session.rollback()后，可实现事务回滚。添加到数据库会话中的所有对象都会还原为它们在数据库时的状态。 注意：如果在写入会话过程中发生了错误，那么整个会话都会实效。这样就保证了数据库的一致性。因为可以防止只更新正确部分，而发生错误的部分没有更新。 5.8.3 更新行在数据库会话上调用add()方法可以更新数据。如：123&gt;&gt;&gt; role_admin.role_name = &apos;administrator&apos;&gt;&gt;&gt; db.session.add(role_admin)&gt;&gt;&gt; db.session.commit() 5.8.4 删除行在数据库会话上调用delete()方法删除数据。如：12&gt;&gt;&gt; db.session.delete(role_moderator)&gt;&gt;&gt; db.session.commit() 注意：插入、更新、删除，只有commit()后才会真正写入数据库。 5.8.5 查询行Flask-SQLAlechemy为每个模型（注意不是具体的模型实例）都提供了query对象，在query对象上调用相应方法可进行查询。如查询所有记录：12&gt;&gt;&gt; Role.query.all()&gt;&gt;&gt;[&lt;Role &apos;admin&apos;&gt;, &lt;Role &apos;visitor&apos;&gt;] 在query对象上可使用过滤器进行更精确的查询，如：12&gt;&gt;&gt; User.query.filter_by(role=role_visitor).all()&gt;&gt;&gt; [&lt;User &apos;john&apos;&gt;, &lt;User &apos;david&apos;&gt;] 表5-5 常用的SQLAlchemy查询过滤器 过滤器 说明 filter() 把过滤器添加到原查询上，返回一个新查询 filter_by() 把等值过滤器添加到原查询上，返回一个新查询 limit() 使用指定的值限制原查询返回的结果数量，返回一个新查询 offset() 偏移原查询返回的结果，返回一个新查询 order_by() 根据指定条件对原查询结果进行排序，返回一个新查询 group_by() 根据指定条件对原查询结果进行分组，返回一个新查询 注意：在查询上应用指定过滤器后，需通过一些执行函数执行查询。 表5-6 最常用的SQLAlchemy查询执行函数 方法 说明 all() 以列表的形式返回查询的所有结果 fitst() 返回查询的第一个结果，如果没有，则返回None first_or_404() 返回查询的第一个结果，如果没有，则终止请求，返回404错误响应 get() 返回指定主键对应的行，如果没有，则返回None get_or_404() 返回指定主键对应的行，如果没有，则返回None count() 返回查询结果的数量 paginate() 返回一个Paginate对象，它包含指定范围的结果 再看一个从关系的两端查询Role和User之间一对多的关系的例子：12345&gt;&gt;&gt; users = role_visitor.users&gt;&gt;&gt; users[&lt;User &apos;john&apos;&gt;, &lt;User &apos;david&apos;&gt;]&gt;&gt;&gt; users[0].role&gt;&gt;&gt; &lt;Role &apos;visitor&apos;&gt; 执行role_visitor.users时，隐含的查询会调用all()方法返回一个列表，query对象时隐藏的，因此很难做更进一步的查询。此时可在db.relationship()中添加lazy=&#39;dynamic参数，从而禁止自动执行查询（添加后需调用all()等方法才能执行查询，当然也可在执行前调用过滤器）。 5.9 在视图函数中操作数据库新版的hello.py当输入新用户名时，会把新用户名写入数据库，并显示Pleased to meet you!信息；当输入的是旧用户名（数据库中已有的名字）时，会显示Happy to see you again! hello.py如下：1234567891011121314151617181920# ...@app.route(&apos;/&apos;,methods=[&apos;GET&apos;, &apos;POST&apos;])def index(): form = NameForm() if form.validate_on_submit(): session[&apos;name&apos;] = form.name.data # 查找数据库中是否有该用户名，如果没有，就向数据库中添加新用户， # 因为前面已经设置了SQLALCHEMY_COMMIT_ON_TEARDOWN，所以当请求结束时会自动提交事务 user = User.query.filter_by(user_name=form.name.data).first() if user is None: # 插入数据库 user = User(user_name=form.name.data) db.session.add(user) # 用于模板中判断是显示Pleased to meet you 还是 Happy to see you again session[&apos;known&apos;] = Flase else: session[&apos;konwn&apos;] = True return redirect(url_for(&apos;index&apos;) return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;), known=session.get(&apos;known&apos;, Flase)) index.html如下：12345678910111213141516&#123;% extends &quot;base.html&quot; %&#125;&#123;% import &quot;bootstarp/wtf.html&quot; as wtf %&#125;&#123;% block title %&#125;Flasky&#123;% endblock %&#125;&#123;% block page_content %&#125;&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Hello, &#123;% if name %&#125;&#123;&#123; name &#125;&#125;&#123;% else %&#125;Stranger&#123;% endif %&#125;!&lt;/h1&gt; &#123;% if known %&#125; &lt;p&gt;Happy to see you again!&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;Pleased to meet you!&lt;/p&gt; &#123;% endif %&#125;&lt;/div&gt;&#123;&#123; wtf.quick_form(form) &#125;&#125;&#123;% endblock %&#125; 5.10 集成Python shell每次启动shell会话都要将数据库模型和实例一个一个地import进去很麻烦，对此我们可以为shell命令注册一个make_context回调函数，把想import的对象导入列表。对hello.py修改如下：123456789from flask-script import Shell, Manager# ...app = Flask(__name__)manager = Manager(app)def make_shell_context(): return dict(app=app, db=db, Role=Role, User=User)manager.add_command(&apos;shell&apos;, Shell(make_context=make_shell_context)) 这样启动shell时就会将对象直接导入shell中：12345&gt;&gt;&gt; python hello.py shell&gt;&gt;&gt; app&lt;Flask &apos;app&gt;&gt;&gt;&gt; User&lt;class &apos;app.User&apos;&gt; 5.11 使用Flask-Migrate实现数据库迁移在5.8.1 创建数据库表中我们说到，更新表的方法之一是删除旧表再重新创建表，但是这会丢失原有的数据。现在介绍方法二：使用数据库迁移框架。数据库迁移框架：能够跟踪数据库模式的变化，然后增量式地把变化应用到已有数据库中。（其功能类似与Git，能够跟踪数据库模式的变化） 可从理解Git的角度理解数据库迁移框架。 5.11.1 创建迁移仓库hello.py如下：12345from flask-migrate import Migrate, MigrateCommand# ...migrate = Migrate(app, db)manager.add_command(&apos;db&apos;, MigrateCommand) Flask-Migrate提供了一个MigrateCommand类，它可以附加到Flask-Script的manager对象上，从而导出数据库迁移命令。该例中，MigrateCommand类使用db命令附加（类似于5.10中，将Shell类使用shell命令附加）。 注意：在维护数据库迁移之前，首先要使用init子命令创建迁移仓库：12345(venv)$ python hello.py db initCreating directory /home/flask/...........Please edit configuration/connection/logging setting in &apos;/home/flask/..../alembic.ini&apos; before proceeding. 这个命令会创建一个migrations的文件夹，所有迁移脚本都在里面。 5.11.2 创建迁移脚本在Alembic中，数据库迁移用迁移脚本表示。脚本中有两个函数：upgrade()函数：把迁移中的改动应用到数据库中。downgrade()函数：将改动删除。 我们可以用revision命令手动创建Alembic迁移（upgrade()和downgrade()都是空的，需使用Alembic提供的Operations对象指令实现具体操作），也可以用migrate命令自动创建Alembic迁移（会根据模型定义和数据库当前的状态之前的差异生成upgrade()和downgrade()函数的内容）。 使用migrate命令自动创建迁移脚本：123456(venv)$ python hello.py db migrate -m &quot;initial migration&quot;INFO [alembic.migration] Context impl SQLiteImpl...INFO [alembic.qutogenerate] Detected added table &apos;users&apos;....../falsky/migrations/versions/1bc...bb5_initial_migration.py...done 5.11.3 更新数据库检查并修正好迁移脚本后，可以使用db upgrade命令把迁移应用到数据库中。如：1234(venv)$ python hello.py db upgradeINFO [alembic.migration] Context impl SQLiteImpl...INFO [alembic.migration] Running upgrade None -&gt; 1bc...bb5, initial migration 对于第一个迁移来说，其作用和调用db.create_all()方法一样，但在后续的迁移中，upgrade命令能把改动应用到数据库中，而且不影响其中保存的数据。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第四章 Web表单","date":"2017-11-14T12:54:15.000Z","path":"2017/11/14/把《Flask Web开发》读薄系列之第四章 Web表单/","text":"4.1 跨站请求伪造保护跨站请求伪造(CSRF)：恶意网站吧请求发送到，被攻击者已登录的其他网站。flask-wtf需要程序设置一个密匙。然后利用这个密匙生成加密令牌，再用令牌验证请求中表单数据的真伪，从而实现CSRF保护。 设置flask-wtf：123# ...app = Flask(__name__)app.config[&apos;SECRET_KEY&apos;] = &apos;hard to guess string&apos; 注意：为了增强安全性，密匙不应该直接写入代码中，而要保存环境变量中（第七章介绍）。 4.2 定义表单类使用flask-wtf时，每个Web表单都继承自Form类。这个类定义表单中的一组字段，每组字段都用对象（字段类的实例对象，如StringField（‘hello’））表示。字段对象可以附有一个或多个验证函数。验证函数(validator)：用来验证用户提交的数据是否符合要求。 定义名为NameForm的表单类：1234567from flask-wtf import Formfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import Requiredclass NameForm(Form): name = StringField(&apos;What is your name?&apos;, validators=[Required()]) submit = SubmitField(&apos;Submit&apos;) NameForm表单中的字段定义为类变量，类变量的值为对应字段的对象。 字段构造函数（如SubmitField()）：的第一个参数是把表单渲染成HTML时使用的标号（或文本）。 validators参数：一个由验证函数组成的列表。 表4-1 WTFORMS支持的HTML标准字段 字段类型 说明 StringField 文本字段 TextAreaField 多行文本字段 PasswordField 密码文本字段 表4-2 WTFORMS验证函数 验证函数 说明 Email 验证电子邮件地址 Required 确保字段中有数据 AnyOf 确保输入值在可选值列表中 4.3 把表单渲染成HTML假设视图函数把一个NameForm实例（通过参数form）传给模板，那么在模板中可以生成一个简单的表单：12345&lt;form method=&quot;POST&quot;&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &#123;&#123; form.name.label&#125;&#125; &#123;&#123; form.name() &#125;&#125; &#123;&#123; form.submit() &#125;&#125;&lt;/form&gt; 为了改进外观，可以将HTML属性（如id、class等）传给渲染字段的函数，如：12345&lt;form method=&quot;POST&quot;&gt; &#123;&#123; form.hidden_tag() &#125;&#125; &#123;&#123; form.name.label&#125;&#125; &#123;&#123; form.name(id=&apos;my-text-field&apos;) &#125;&#125; &#123;&#123; form.submit() &#125;&#125;&lt;/form&gt; flask-bootstrap提供了一个辅助函数涌来渲染flask-wtf表单。用法如下：12&#123;% import &quot;bootstrap/wtf.html&quot; as wtf %&#125;&#123;&#123; wtf.quick_form(form) &#125;&#125; bootstrap/wtf.html文件中定义了一个用于渲染Flask-WTF表单对象的辅助函数。 wtf.qucik_form()函数的参数为Flask-WTF表单对象（表单类的实例）。 4.4 在视图函数中处理表单12345678910# ...@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]def index(): name = None form = NameForm() # 实例化表单类 if form.validate_on_submit(): name = form.name.data form.name.data = &apos;&apos; # 将form.name.data的值设置为空字符串 return render_template(&apos;index.html&apos;, form=form, name=name) methods参数告诉Flask在URL映射中把这个视图函数注册为GET和POST请求的处理程序。如果没有指定methods参数，就只把视图函数注册为GET请求的处理程序。 validate_on_submit()：提交表单后，如果数据能被全部验证函数接受，那么validate_on_submit()的返回值为True，否则返回False。 4.5 重定向和用户会话现在的hello.py存在一个问题：用户输入名字后提交表单，然后刷新页面，会出现一个警告（要求在再次提交表单前进行确认）。出现这种情况的原因是：刷新页面时，浏览器会重新发送之前已经发送过的最后一个请求。如果这个请求是一个包含表单数据的POST请求，刷新页面会再次提交表单。 解决思路：使浏览器发送的最后一个请求不是POST请求。解决方法：使用重定向作为POST请求的响应，而不是使用常规响应。 重定向：是一个特殊响应，响应的内容是URL，而不是包含HTML代码的字符串。浏览器收到这种响应时，会向重定向的URL发起GET请求（第二个请求），显示页面内容。 存在问题：这种方法会带来另一个问题，程序处理POST请求时，使用form.name.data来获取用户输入值，可是一旦这个请求结束，数据也就丢失（因为这个POST请求使用重定向作为响应）。所以程序需要保存输入值，方便重定向后的请求可以获得并使用这个值。 解决方法2 ：把数据存储在用户会话中。 使用重定向和用户会话重写hello.py：12345678910from flask import Flask, render_template, session, redirect, url_for# ...@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])def index(): form = NameForm() if form.validate_on_submit(): session[&apos;name&apos;] = form.name.data return redirect(url_for(&apos;index&apos;)) return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;)) 使用session.get()方法获取字典中键对应的值，避免未找到键的异常情况。因为对于不存在的键， get()会返回默认值None。 4.6 Flash消息请求完成后，有时需要让用户知道状态发生了变化（如使用确认消息、警告或错误提醒）。一个典型例子是，提交了一项有错误的登录表单后，服务器发回的响应重新渲染登录表单，并且在表单上面显示一个消息，提示用户名或密码错误。 设置Flash消息的hello.py：12345678910111213form flask import Flask, render_template, session, redirect, url_for, flash# ...@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]def index(): form = NameForm() if form.validate_on_submit(): old_name = session.get(&apos;name&apos;) if old_name is not None and old_name != form.name.data: flash(&apos;Looks like you have changed your name!&apos;) session[&apos;name&apos;] = form.name.data return redirect(url_for(&apos;index&apos;) return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;)) 在这个示例中，将用户提交的数据和用户会话中的数据比较，如果两个数据不一样，就会调用flash()函数，在发给客户端的下一个响应中显示一个信息。 在模板中渲染Flash消息：仅调用flash()函数并不能将消息显示出来，这个可以在模板中渲染Flash消息。如base.html：12345678910111213&#123;% block content %&#125;&lt;div class=&quot;container&quot;&gt; &#123;% for message in get_flashed_messages() %&#125; &lt;div class=&quot;alert alert-warning&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt; &amp;times; &lt;/button&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125; &#123;% block page_content %&#125; &#123;% endblock %&#125;&lt;/div&gt;&#123;% endblock %&#125; get_flashed_messages()函数用来获取并渲染Flash消息。 注意： 在模板中使用for循环是因为，每次调用falsh()函数时，都会生产一个消息，所以可能有多个消息在排队等待显示，所需需要用for循环将消息都显示出来。 get_flashed_messages()函数获取的消息在下次调用时不会再次返回（如这次获取了消息队列1，那么在下次调用时就不会再返回消息队列1，有点类似于列表的pop()方法），因此Flash消息只显示一次，然后就消失了。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第三章 模板","date":"2017-11-14T12:52:00.000Z","path":"2017/11/14/把《Flask Web开发》读薄系列之第三章 模板/","text":"使用Flask-Mail提供电子邮件支持表6-1 Flask-Mail SMTP服务器的配置 配置 默认值 说明 MAIL_SERVER localhost 电子邮件服务器的主机名或IP地址 MAIL_PORT 25 电子邮件服务器的端口 MAIL_USE_TLS False 启用传输层安全（TLS）协议 MAIL_USE_SSL False 启用安全套接层（SSL）协议 MAIL_USENAME None 邮件账户的用户名 MAIL_PASSWORD None 邮件账户的授权码 在hello.py中配置Flask-Mail使用QQ邮箱： 12345678import os #...app.config[&apos;MAIL_SERVER&apos;] = &apos;smtp.qq.com&apos;app.config[&apos;MAIL_PORT&apos;] = 465app.config[&apos;MAIL_USE_SSL&apos;] = Trueapp.config[&apos;MAIL_USERNAME&apos;] = os.environ.get(&apos;MAIL_USERNAME&apos;)app.config[&apos;MAIL_PASSWORD&apos;] = os.environ.get(&apos;MAIL_PASSWORD&apos;) 注意：千万不要把账号密令直接写在脚本中，应该从环境变量中导入。 初始化Flask-Mail： 1234from flask_mail import Mail# ...mail = Mail(app) 在环境变量中定义MAIL_USERNAME和MAIL_PASSWORD： 12(venv) $ export MAIL_USERNAME=&apos;12345678@qq.com&apos;(venv) $ export MAIL_PASSWORD=&apos;qwertyuiop&apos; 此时可以使用echo命令打印出来检查一下： 1234(venv) $ echo $MAIL_USERNAME&gt;&gt;&gt; &apos;12345678@qq.com&apos;(venv) $ echo $MAIL_PASSWORD&gt;&gt;&gt; &apos;qwertyuiop&apos; 定义环境变量后，此时在同一个终端中执行python hello.py shell命令，便能获取到想要的环境变量。 注意：如果定义好环境变量后把终端关闭再重新打开，那么此时是没有上次定义的环境变量的。所以需要在同一个终端中执行。 如何让QQ邮箱开启SMTP功能，可以参考flask-mail常见的邮箱配置问题解决 在Python shell中发送电子邮件在上一个终端中，发送电子邮件：12345678(venv) $ python hello.py shell&gt;&gt;&gt; from flask_mail import Message&gt;&gt;&gt; from hello import mail&gt;&gt;&gt; msg = Message(&apos;test subject&apos;, sender=&apos;12345678@qq.com&apos;, recipients=[&apos;87654321@qq.com&apos;])&gt;&gt;&gt; msg.body = &apos;test body&apos;&gt;&gt;&gt; msg.html = &apos;&lt;p&gt;test body&lt;/p&gt;&apos;&gt;&gt;&gt; with app.app_context():··· mail.send(msg) 注意：在Flask-Mail中的send()函数使用current_app（程序上下文），因此在shell中发送邮件，需要激活程序上下文。 在程序中集成发送电子邮件功能 定义用于发邮件的函数，使hello.py支持电子邮件： 12345678910111213from flask_mail import Message# ...# 给邮件标题添加一个前缀app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] = &apos;[Flasky]&apos;# 定义发件人app.config[&apos;FLASKY_MAIL_SENDER&apos;] = &apos;12345678@qq.com&apos;def send_email(recipients, subject, template, **kwargs): msg = Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] + subject, sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;], recipients=[recilients]) msg.body = render_template(template + &apos;.txt&apos;, **kwargs) msg.html = render_template(template + &apos;.html&apos;, **kwargs) mail.send(msg) 邮件有纯文本.txt，也有HTML文本.html，客户端显示哪个，取决于邮件客户端的设置。 拓展：为什么send()函数中需要**kwargs？**kwargs的作用是什么？答：（1）因为我们不确定模板中需要什么变量参数，在此例中，模板需要的时user这个参数，但是如果换成别的模版，它不仅需要user参数，也需要其他一些参数（如datatime等，关键取决于模板设计成什么样），此时如果我们死死地把send_email()函数写成send_email(recipient, subject, template, user)，那么就失去了灵活性，当换成其他模版时，datatime参数也就无法传入了，因此send()函数需要**kwargs。（2）**kwargs的作用是：当我们不知道需要往函数中传入多少个关键字参数或者想以字典的形式作为参数时，我们可以用**kwargs，这样我们就可以根据实际情况需要，往函数中传入特定个数的参数（数量使具体情况而定）。 结合视图函数发送电子邮件： 1234567891011121314151617181920212223242526# ...# 定义收件人为Flasky的管理员app.config[&apos;FLASKY_ADMIN&apos;] = os.environ.get(&apos;FLASKY_ADMIN&apos;)# ...@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]def index(): form = NameForm() if form.validate_on_submit(): session[&apos;name&apos;] = form.name.data # 查找数据库中是否有该用户名，如果没有，就向数据库中添加新用户， # 因为前面已经设置了SQLALCHEMY_COMMIT_ON_TEARDOWN，所以当请求结束时会自动提交事务 user = User.query.filter_by(user_name=form.name.data).first() if user is None: # 插入数据库 user = User(user_name=form.name.data) db.session.add(user) # 用于模板中判断是显示Pleased to meet you 还是 Happy to see you again session[&apos;known&apos;] = Flase # 如果收件人不为空，则发送邮件 if app.config[&apos;FLASKY_ADMIN&apos;]: send_email(app.config[&apos;FLASKY_ADMIN&apos;], &apos;New User&apos;, &apos;mail/new_user&apos;, user=user) else: session[&apos;konwn&apos;] = True return redirect(url_for(&apos;index&apos;) return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;), known=session.get(&apos;known&apos;, Flase)) 此时我们也需要定义环境变量FLASKY_ADMIN：(venv) $ export FLASKY_ADMIN=&#39;12345678@qq.com&#39; template文件夹下的模板文件mail/new_user有两个，分别为new_user.txt和new_user.html。 new_user.txt如下： 1There has a new user that name is &#123;&#123; user.user_name &#125;&#125; new_user.html如下： 1&lt;h1&gt;There has a new user that name is &#123;&#123; user.user_name &#125;&#125;&lt;/h1&gt; 异步发送电子邮件为了避免处理请求过程中不必要的延迟，我们可以把发送电子邮件的函数移到后台线程中处理： 1234567891011121314from threading import Thread# ...def send_async_email(app, msg): with app.app_context(): mail.send(msg) def send_email(recipients, subject, template, **kwargs): msg = Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] + subject, sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;], recipients=[recilients]) msg.body = render_template(template + &apos;.txt&apos;, **kwargs) msg.html = render_template(template + &apos;.html&apos;, **kwargs) thr = Thread(target=send_async_email, args=[app, msg]) thr.start() return thr 注意：由于在不同线程中执行mail.send()函数，就如前面在Python shell中发送电子邮件章节中提到，send()函数需要程序current_app（程序上下文）中执行，因此需要在执行send()函数的线程中使用app.app_context()人工创建current_app。 当需要发送大量电子邮件时，使用专门发送电子邮件的作业（如Celery任务队列）处理更合适。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第二章 程序的基本概念","date":"2017-11-14T12:45:31.000Z","path":"2017/11/14/把《Flask Web开发》读薄系列之第二章 程序的基本概念/","text":"2.1 初始化123from flask import Flaskapp = Flask(__name__) Flask实例化只有一个必须指定的参数，即程序主模块或包的名字（也即__name__）1234# 2.2 路由和视图函数1. **路由**：处理URL和函数之间的关系（URL到Python函数的映射关系）的程序。```可通过Flask实例提供的`app.route()`装饰器把函数注册为路由。 视图函数：像index()这样的函数。 2.4 一个完整的程序1234567891011121314from flask import Flaskapp = Flask(__name__)@app.route(&apos;/&apos;)def index(): return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;@app.route(&apos;/user/&lt;name&gt;&apos;) # &lt; &gt;尖括号部门是动态url部分def user(name): # Flask会将动态部分（也即&lt; &gt;部分）作为参数传入视图函数中 return &apos;&lt;h1&gt;Hello &#123;&#125;!&apos;.format(name) if __name__ == &apos;__main__&apos;: app.run(debug=True) 2.5 请求-响应2.5.1 程序与请求上下文 程序上下文： 请求上下文: 2.5.2 请求调度Flask使用app.route()装饰器或者非装饰器形式的app.add_url_rule()生成URL和视图函数之间的映射 2.5.3 请求钩子应用场景：在请求开始时，创建数据库链接或认证用户。（即在处理请求之前或之后，执行某些代码）Flask提供以下4种钩子： before_first_request：注册一个函数，在处理第一个请求之前运行 before_request：注册一个函数，在每次请求之前运行 after_request：注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行 teardown_request：注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行 2.5.4 响应视图函数返回值可以接受3个参数：响应文本，状态码，一个由header组成的字典。make_response()函数可以接受3个参数（和视图函数返回值一样），并返回一个response对象，此时我们可以在response对象上调用各种方法，进一步设置响应。如获得一个response对象，然后设置cookie：12345678910from flask import Flaskfrom flask import make_responseapp = Flask(__name__)@app.route(&apos;/&apos;)def index(): response = make_response(&apos;&lt;h1&gt;This document carries a cookie!&lt;/h1&gt;&apos;) response.set_cookie(&apos;answer&apos;, &apos;42&apos;) return response redirect()函数用于生成重定向（一种特殊的响应）。 abort函数用于生产另一种特殊响应，用于处理错误。如：12345678910111213141516from flask import Flaskfrom flask import redirectfrom flask import abortapp = Flask(__name__)@app.route(&apos;/&apos;)def index(): return redirect(&apos;http://www.example.com&apos;) @app.route(&apos;/user/&lt;id&gt;&apos;)def get_user(id): user = load_user(id) # load_user()用于读取id，不展开写 if not user: abort(404) # 如果id不存在，返回状态吗404 return &apos;&lt;h1&gt;Hello &#123;&#125;&lt;/h1&gt;&apos;.format(id) 2.6 Flask扩展可使用flask-script扩展为Flask程序添加一个命令行解析器，那么就可以自定义很多参数，如监听的host、port等。实现方式：1234567from flask.ext.script import Manager# ...manager = Manager(app)if __name__ = &apos;__main__&apos;: manager.run() 把Flask实例app作为参数传给Manager()，初始化实例。注意：Flask扩展都在flask.ext命名空间下，而Python3.5之后都直接使用from flask-xxx import xxx来导入。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之第一章 创建虚拟环境","date":"2017-11-14T12:43:30.000Z","path":"2017/11/14/把《Flask Web开发》读薄系列之第一章 创建虚拟环境/","text":"切换到目标文件夹目录 执行virtualenv venv命令，其中venv为虚拟环境名称 执行source venv/bin/activate激活虚拟环境","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"把《Flask Web开发》读薄系列之序言","date":"2017-11-14T12:20:58.000Z","path":"2017/11/14/把《Flask Web开发》读薄系列之序言/","text":"读者的疑惑《把&lt;Flask Web开发——基于Python的Web应用开发实战&gt;读薄系列》主要是对《Flask Web开发》一书的概括，或许你读起来会吐槽说“卧靠，这不就是书中的内容吗，直接把书中的内容搬过来就可以成一个系列了，真牛逼“。对此，我只能说读书笔记大概就是这样吧。你对其中的内容懂了，就会觉得很容易，觉得很没必要做这样的一种记录，完全是照搬书中内容，没有什么实质东西。但是，该系列也并不完全是书中内容，它还包括作者对一些该概念的理解、类比，以及代码实现过程中可能遇到的、应该注意的坑等。如：把第五章数据库中的5.11 使用Flask-Migrate实现数据库迁移，跟Git版本控制联系起来，结合理解。如：第六章电子邮件中通过QQ邮箱服务器发送邮件应该注意的坑，以及拓展对**kwargs的理解和实际应用情景。总的来说，该系列主要起到的作用如下： 起到思维导图作用。当你初学完或者之前学过但是没有实际应用过，那么该系列可以帮助你勾起记忆，尽快掌握Flask的一些基本知识。另外也能让你根据思维导图你查漏补缺。 加入一些类比，加强理解书中概念。如前面说到的Flask-Migrate与Git的类比。书中的一些类比能否帮助你，视人而已，因为每个人对概念的理解都不同，就像不是所有读者都了解Git一样。 拓展对Python一些概念的理解。亦如前面说到的对**kwargs的理解。 最后说两句可能是翻译的原因，书中偶尔会出现的一些句子或内容读起来很费劲，很难理解，对此，作者也尽量以平实的语言概括该系列，甚至是以提炼出“存在问题—解决思路—解决方法“或者问答的形式来概括书中内容，加深理解。如第四章4.5 重定向和用户会话，作者根据书中内容提炼出“存在问题—解决思路—解决方法”来解释为什么使用重定向和用户会话。 另外，为了更准确地表达意思，该系列中的一些章节的名字可能与原书的章节名字不同，但这并不要紧，意思对了就行。 联系作者如果你对《Flask Web开发——基于Python的Web应用开发实战》书中的内容有一些很好的个人理解（如用类比来理解）等，可以把你的理解整理好发送到作者邮箱：weichang321@gmail.com。我将会筛选一些好的内容加入到该系列中，并署上你的名字。","tags":[{"name":"Flask","slug":"Flask","permalink":"https://richardrw.github.io/tags/Flask/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://richardrw.github.io/tags/读书笔记/"}]},{"title":"构建爬取大众点评美食数据的多线程爬虫（含多进程实现）（一）","date":"2017-10-20T14:07:02.000Z","path":"2017/10/20/构建爬取大众点评美食数据的多进程爬虫（一）/","text":"构建爬取大众点评美食数据的多进程爬虫（一）一、要抓取哪些数据以东莞美食为例大众点评-美食-东莞，可以看到，在美食页面，我们想要爬取的信息有： 商户标题 星级 评论数 人均价格 各项评分 菜系 地址 二、分析页面（一）多观察页面通过点击小吃快餐，我们看到小吃快餐下一共有50个页面。再点击面包甜点，发现也只有50个页面。接下来我们看看面包甜点-东城区，发现最多也只有50个页面。如此类推，我们大概可以确定，某菜系-某区域最多只有50个页面，由此基本可以判断，这应该是大众点评做大反爬虫措施。对此，我们在稍后的爬虫设计中，不能简单地从某一菜系下爬取所有页面或者从某一区域下爬取所有页面，因为单独选定菜系或者区域，服务器最多只返回50个页面给你。 因此我们需要将菜系-区域组合起来爬取，尽可能多的爬取商户信息。 通过观察，我们发现在一个网页中，如：http://www.dianping.com/search/category/219/10/g117r434g117代表菜系，r434代表区域，因此我们可以获取所有的菜系链接，接着在菜系链接的基础上获取菜系-区域链接，这就相当于在用浏览器浏览时，先选定了某一菜系，再选定某一区域。 （二）分析页面结构这里就是要通过定位来选定我们需要的元素。如一级菜系，它所处的位置是id=&quot;classfy的div标签下的a标签中。商户标题，它所处的位置是class=&quot;tit&quot;的div标签下的第一个a标签中。通过一个个地查看，我们可以得出我们要爬取的7个商户信息的位置，方便我们后续设计爬虫时进行定位。 三、设计爬虫（一）爬虫思路 爬虫流程图 从start_url开始，爬取所有一级菜系链接，得到tag1_url，存入数据库。 从数据库中读取tag1_url，爬取所有二级菜系链接，得到tag2_url，存入数据库。 从数据库中读取tag2_url，爬取所有一级区域链接，得到addr1_url，存入数据库。 从数据库中读取addr1_url，爬取所有二级区域链接，得到addr2_url，存入数据库。 从数据库中读取addr2_url，爬取所有商户信息，得到dpshop_msg，存入数据库。1-4目的都是一样，为了获取最终要爬取的页面链接，5就是为了实际爬取上述7个商户信息，所以我们把1-4写到cate_parsing.py文件中，把5写到shop_parsing.py文件中。另外，为了应对反爬虫，我们将用于伪装的User-Agent和代理IP等一些爬虫参数写到config.py文件中。（二）构建代码config.py代码如下：1234567891011121314151617181920212223242526272829303132#coding=utf-8#伪装浏览器USER_AGENT = [ &apos;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&apos;, &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36&apos;, &apos;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11&apos;, &apos;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16&apos;, &apos;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0&apos;, &apos;Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10&apos; ]# 代理IPPROXY = [ &apos;111.13.111.184:80&apos;, &apos;49.119.164.175:80&apos;, &apos;61.136.163.245:3128&apos;, &apos;116.199.2.210:80&apos;, &apos;116.199.2.209:80&apos;, &apos;116.199.115.79:80&apos;, &apos;116.199.2.196:80&apos;, &apos;121.40.199.105:80&apos;, &apos;125.77.25.118:80&apos;, &apos;122.228.253.55:808&apos; ]TIMEOUT = 5LINKTIME = 3PAGE_NUM_MAX = 50 cate_parsing.py代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#coding=utf-8import requestsimport randomimport pymongoimport timefrom lxml import etreefrom config import USER_AGENT, PROXY, TIMEOUT, LINKTIMEclient = pymongo.MongoClient(&apos;localhost&apos;, 27017)dp = client[&apos;dp&apos;]# 爬取一级菜系、二级菜系、二级菜系下的一级地址class GetTagAddr(object): headers = random.choice(USER_AGENT) proxies = &#123;&apos;http&apos;:random.choice(PROXY)&#125; s = requests.Session() s.headers.update(&#123;&apos;User-Agent&apos;:headers&#125;) linktime = LINKTIME timeout = TIMEOUT tag1_url_db = dp[&apos;tag1_url_db&apos;] # 存储从start_url中成功爬取到的tag1_url tag2_url_db = dp[&apos;tag2_url_db&apos;] # 存储从tag1_url中成功爬取到的tag2_url crawly_tag1_ok = dp[&apos;crawly_tag1_ok&apos;] # 存储爬取成功的tag1_url addr1_url_db = dp[&apos;addr1_url_db&apos;] # 存储从tag2_url中成功爬取到的addr1_url crawly_tag2_ok = dp[&apos;crawly_tag2_ok&apos;] # 存储爬取成功的tag2_url addr2_url_db = dp[&apos;addr2_url_db&apos;] # 存储从addr1_url中成功爬取到的addr2_url crawly_addr1_ok = dp[&apos;crawly_addr1_ok&apos;] # 存储爬取成功的addr1_url def get_tag1_from(self, start_url): # 不公开爬虫细节 def get_tag2_from(self, tag1_url): # 不公开爬虫细节 def get_addr1_from(self, tag2_url): # 不公开爬虫细节 def get_addr2_from(self, addr1_url): # 不公开爬虫细节if __name__ == &apos;__main__&apos;: url = &apos;http://www.dianping.com/search/category/219/10/g0r0&apos; get_tag1_from, get_tag2_from, get_addr1_from和get_addr2_from都采用了同样的逻辑： 先请求url，获得response。 使用etree.HTML解析网页。 定位所要爬取元素的位置。 存储。 shop_parsing.py代码如下：123456789101112131415161718192021222324252627282930#coding=utf-8import requestsimport randomimport pymongoimport timefrom lxml import etreefrom config import USER_AGENT, PROXY, TIMEOUT, LINKTIME, PAGE_NUM_MAXclient = pymongo.MongoClient(&apos;localhost&apos;, 27017)dp = client[&apos;dp&apos;]addr2_url_db = dp[&apos;addr2_url_db&apos;] # 存储从addr1_url中成功爬取到的addr2_urldpshop = dp[&apos;dpshop&apos;] # 存储从addr2中成功爬取到的dpshop_msgcrawly_addr2_ok = dp[&apos;crawly_addr2_ok&apos;] # 存储爬取成功的addr2_urldef get_msg_from(response, addr2_url): # 不公开爬虫细节def get_all_msg_from(addr2_url): # 不公开爬虫细节def requests_url(result_url, linktime=LINKTIME): # 不公开爬虫细节if __name__ == &apos;__main__&apos;: addr2_url = &apos;http://www.dianping.com/search/category/219/10/g217r27028p3&apos; requests_url函数用于请求网页，并返回状态码和response。 get_msg_from函数用于解析源代码，定位元素，爬取并存储所有我们需要的商户信息。 get_all_msg_from函数实现了多页码爬取，当遇到网页状态码为404时，代表此时没有相关商户，最后一页已经被爬取，自动跳出for循环。结束某个addr2_url的爬取。 run.py代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# coding=utf-8from parsing.cate_parsing import GetTagAddrfrom parsing.shop_parsing import get_all_msg_from, crawly_addr2_okfrom concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutorif __name__ == &apos;__main__&apos;: start_url = &apos;http://www.dianping.com/search/category/219/10/g0r0&apos; tag_addr_task = GetTagAddr() # 爬取tag1_url tag_addr_task.get_tag1_from(start_url) print(&apos;tag1_url爬取完成&apos;) # 爬取tag2_url tag1_wait = set(i[&apos;url&apos;] for i in tag_addr_task.tag1_url_db.find()) tag1_ok = set(i[&apos;url&apos;] for i in tag_addr_task.crawly_tag1_ok.find()) tag1_task = tag1_wait - tag1_ok for tag1_url in tag1_task: tag_addr_task.get_tag2_from(tag1_url) print(&apos;tag2_url爬取完成&apos;) # 爬取addr1_url tag2_wait = set(i[&apos;url&apos;] for i in tag_addr_task.tag2_url_db.find()) tag2_ok = set(i[&apos;url&apos;] for i in tag_addr_task.crawly_tag2_ok.find()) tag2_task = tag2_wait - tag2_ok for tag2_url in tag2_task: tag_addr_task.get_addr1_from(tag2_url) print(&apos;addr1_url爬取完成&apos;) # 爬取addr2_url addr1_wait = set(i[&apos;url&apos;] for i in tag_addr_task.addr1_url_db.find()) addr1_ok = set(i[&apos;url&apos;] for i in tag_addr_task.crawly_addr1_ok.find()) addr1_task = addr1_wait - addr1_ok with ProcessPoolExecutor(max_workers=4) as executor: executor.map(tag_addr_task.get_addr2_from, addr1_task) print(&apos;addr2_url爬取完成&apos;) # 根据addr2_url爬取商户信息 addr2_wait = set(i[&apos;url&apos;] for i in tag_addr_task.addr2_url_db.find()) addr2_ok = set(i[&apos;url&apos;] for i in crawly_addr2_ok.find()) addr2_task = addr2_wait - addr2_ok with ThreadPoolExecutor(max_workers=8) as executor: for url in addr2_task: v = executor.submit(get_all_msg_from, url) executor.shutdown(wait=True) # executor.map(get_all_msg_from, addr2_task, chunksize=50) print(&apos;addr2_url_reslut_url爬取完成&apos;) 爬取addr2_url采用多进程爬取，多进程通过concurrent.futures.ProcessPoolExecutor实现。 爬取dpshop_msg采用了多线程爬取，多线程通过congurrent.futures.ThreadPoolExecutor实现。","tags":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://richardrw.github.io/tags/Python爬虫/"},{"name":"多进程","slug":"多进程","permalink":"https://richardrw.github.io/tags/多进程/"},{"name":"大众点评","slug":"大众点评","permalink":"https://richardrw.github.io/tags/大众点评/"}]},{"title":"从美食的角度看东莞（数据来源：大众点评）","date":"2017-10-20T13:35:45.000Z","path":"2017/10/20/从美食的角度看东莞（数据来源：大众点评）/","text":"从美食的角度看东莞（数据来源：大众点评）先从为什么要做这个项目说起，事情的缘由是这样的，小编当时跟领导到别的城市外出出差一个星期，作为一个平时很少外出的人，别说是别的城市了，就连东莞这个地方我都还没走遍过，尤其是那些重要商区、美食店，平时跟朋友出去玩，都很尴尬不知道要吃什么好。现在跟领导外出别的城市，感觉自己是个刚出大山的农村小伙子，对外面的世界所知甚少。作为领导的助手，自然就要安排好这一星期的就餐地点。然而这就很难为我了，我连东莞有什么地方有好吃的都不知道，现在居然要我在别的城市安排一个星期的就餐作息表？这就很尴尬了。于是我每天都苦于到大众点评、美团等APP上搜索附近美食，但是还是不知道那些餐店的真实情况怎样，环境如何，味道如何。于是此时我就想，如果能一下子就知道某个城市或者某个区中最受欢迎的店有哪些，哪个镇或者哪个区最繁华，那该多好。于是小编回来后就开始构思，接着就撸起袖子加油干，爬取了大众点评上1.5w多条数据，并做了个东莞美食商户数量热力图，从美食的角度看东莞。 东莞各镇街美食商户数量分布热力图 （因为图片大小问题，莞城、洪梅和大岭山的标签没有显示出来，要解决这个问题，可以找张大点的图制作SVG） 东莞各镇街美食商户数量分布热力图-动态 东莞各镇街美食商户数量柱状图 可以看出，东城区商户数量最多，其次是南城区，从热力图来看，也可以看出东莞哪个镇街最繁华，也可以初步判断出哪些镇街经济情况比较好。因为一般经济越好的地区，其商业越繁华越发达。为了验证这个猜想，小编查了下东莞2016年各镇街经济实力排名情况 东莞各镇街2017年经济实力排名情况 可以看出，经济实力与地区商户数量基本成正相关。这里说一个特例吧，那就是松山湖。本地人可能知道原因，那就是因为松山湖建立历史比较年轻，区域布局比较先进，目前仅有万科（好像是）这个大型商场，其他就以大学、高新技术产业区以及青山绿水为主，没有一脑子就开发许多商业区，所以就出现了这个经济实力与地区美食商户数量不匹配的情况。接下来看看各星级商户占比情况如何 东莞不同星级商户占比饼状图 准四星用户占73.98%，看来东莞的饮食服务业还是可以的（毕竟是广东啊哈哈）再看看东莞各菜系商户数量情况如何 东莞各菜系商户数量柱状图 小吃快餐最多，其次是面包甜点。小吃快餐最多的原因小编猜测可能有三： 大多数公司中的员工中午都在公司叫外卖，外卖以小吃快餐为主，需求较大，由此催生出一批小吃快餐店，以满足市场需求。 开小吃快餐店的成本比较低，像沙县小吃什么的快餐店，随便会做个番茄炒蛋饭青瓜肉片饭就能开个快餐店了（哈哈），比面包甜点、西餐的开店成本低。 大多数小吃快餐店都选择加入大众点评平台，以提高销售量，增加利润。 至于面包甜点有3155家，这让小编感到意外，没想到东莞居然有这么多面包店。好了，暂时就分析到这里，小编最爱吃的就是面包了，赶紧去看看里面有哪些面包店的，一定要去尝尝。","tags":[{"name":"数据分析","slug":"数据分析","permalink":"https://richardrw.github.io/tags/数据分析/"},{"name":"美食","slug":"美食","permalink":"https://richardrw.github.io/tags/美食/"},{"name":"东莞","slug":"东莞","permalink":"https://richardrw.github.io/tags/东莞/"}]},{"title":"年轻人是否到北上广深发展的博弈论分析","date":"2017-09-25T14:05:11.000Z","path":"2017/09/25/年轻人是否应该到北上广深发展的博弈论分析/","text":"一、思考背景有人说，当你在一个岗位上工作时间超过1年的时候，你就会不自觉地思考，思考诸如你当前工作的意义是什么、这个岗位是否真的适合你等这些“终极问题”。博主现在已经毕业一年零三个月，实际工作时间已有一年零九个月，在这时间点上，大脑变的不自主地思考起一些关于人生的是非对错问题。引发博主思考这个问题的背景主要有三： 曾为大学毕业生，也曾思考过到北上广深发展还是留守本地，驻地生根的问题。 身边有人说，到北上广深发展，只能当炮灰。在沉重的生活成本下，即使工资比二三线城市高，但是实际生活质量却不比二三线城市好，甚至更差。去了只能压榨自己，使自己成为一线城市的“蜡烛”，照亮了别人（成就了上层人士），燃烧了自己（折旧了自己）。 身边也有人说，到北上广深发展，机会更大。留在本地（二三线城市），固然稳定，生活压力也没那么大，但是一辈子都不会有什么变数，一生只能按现在的状态生活下去，极难遇到让自己人生变得更加美好的变数（机遇）。到底谁说的对，谁说的错，是该往北上广深发展，还是驻地生根。不同的人在做这个决定的时候，他考量的是什么，决策依据是什么，决策背后的理论根据又是什么。此时慢慢地、慢慢地，博主想通过博弈论的角度，看能不能分析出什么，想知道，思考的结果又能不能为博主指明前往更美好生活的方向。 写着写着发现，这题目太过严肃认真了，提不起兴趣来写，姑且就先来吹吹水吧。想必大家如果留意生活想象的话，应该不难发现这些现象：在足球比赛中，说说国足吧，一开始总是让人觉得放不开来打，等到落后比分的时候才奋力直追放开来打。在帆船比赛中，落后的选手总是不会老老实实地跟着领航者的路线，而是另谋航线以求超越。在LOL等电子竞技赛中，劣势的一方总是希望通过大龙来抢夺来争取一线赢机。为什么人们在处于劣势环境的情况下，总是追求那些很不稳定的方法呢？例如在篮球足球比赛中，落后一方总是采取多冒险的策略，去搞小动作去犯规。下面我们就来用数学先分析一下。我们假设在一场篮球比赛中，比赛的结果由比赛双方的能力和运气一起决定，你的取胜条件需满足： 你的能力 + 你的运气 &gt; 对手的能力 + 对手的运气 或者 你的运气 - 对手的运气 &gt; 你的能力 - 对手的能力 L &gt; S 在一场比赛中，你的能力、对手的能力基本是已经确定的，因为你不会像《龙珠》里的赛亚人那样，打着打着就变身为超级赛亚人提升战斗力，因此我们不妨将 “你的能力 - 对手的能力” 的差值S视为一确定的系数。那么剩下来，影响比赛结果的就是 “你的运气 - 对手的运气“ 的差值L能否大于S 。 假设对手的能力比你强，你处于劣势，此时S&gt;0，为正值。你要获胜，就必须使得“你的运气 - 对手的运气”的差值L大于S，即当且仅当L&gt;S，你才能获胜。那么我们要如何使得L&gt;S呢？运气这种东西，是我们能够控制的吗？ 我们不妨从数学的角度来看“你的运气 - 对手的运气”的差值L。因为你的运气和对手的运气都是不确定的，必然，“你的运气 - 对手的运气”的差值L也是不确定的，即L的值存在概率性，因此不妨假设L的概率分布是正态曲线（如下图中的实线曲线）。横轴x的任意点，代表L可能的取值，其到曲线上的高y值代表L取某值时对应的概率，因此曲线在两点间覆盖的面积等于L取值位于这两点间的概率。 L取值概率分布图 由图可见，你取胜的概率为图中网格的阴影面积，即对于所有L可能的取值，满足L&gt;S的取值的概率之和。到这里，我们已经知道“你的运气 - 对手的运气”的数学上的意义了。那么回到我们之前的问题：运气这种东西，是我们能够控制的吗？ 答案是可以的。或许从感性理解上，这会很不可思议，但是从数学的角度看，改变运气，就是让你改变“你的运气”的概率分布，使得“你的运气 - 对手的运气”大于S变得更加可能。那么我们需要怎么做呢？还是先从数学角度看。让“你的运气 - 对手的运气”的值大于S变得更加可能，也就是让你增大图中的网格阴影面积。 问：怎么增大？答：让正态曲线更加平坦即可。（如变成上图中的阴线曲线） 曲线变得更平坦后，由图可见，L&gt;S的面积增加了斜线阴影部分，也就是说L&gt;S的概率更大了。在这种情况下，你获胜的概率也就提升了。 曲线变得更平坦，意味着L的取值更具不确定性。在实际生活中，你一般只需采取更冒险、更激进的策略就能达到让“你的运气”的概率分布曲线变得更加平台的效果。就如篮球比赛中，对方实力比你强，你处于落后状态，这时，如果你陈规蹈矩，按部就班，那么你是很难有反超的机会的，因为你只能依靠进攻得分，而那些博犯规罚球得分等“非正常”得分你就很少有机会碰到，因为你打得很稳。相反，如果你采取冒险、更加激进的策略，你活得博犯规罚球得分的机会就会变大，得分机会变大，也就意味着你反超的机会变大。 因此，如果你面对一个比你强大的对手，而你又处于劣势状态，那么你就需要采取一些冒险的策略来打破这种“对手比你厉害，你处于劣势“的稳定状态，从而提高你的胜率。 回到标题中的问题，答案可以从上述中得出总结，只不过在这个比赛中，对手可能不是别人，而可能是你自己，或者整个大环境。你此时需要衡量一下自己的处境，自己能力对于大环境来说，是强是弱，自己的处境是劣势还是优势，在根据综合判断，看是否需要采取一些冒险的策略来打破平衡、打破稳定，提高自己的胜率。","tags":[{"name":"博弈论","slug":"博弈论","permalink":"https://richardrw.github.io/tags/博弈论/"},{"name":"稳定性","slug":"稳定性","permalink":"https://richardrw.github.io/tags/稳定性/"},{"name":"风险","slug":"风险","permalink":"https://richardrw.github.io/tags/风险/"},{"name":"均衡","slug":"均衡","permalink":"https://richardrw.github.io/tags/均衡/"},{"name":"北上广深","slug":"北上广深","permalink":"https://richardrw.github.io/tags/北上广深/"}]},{"title":"sublime如何添加python3版本以及中文乱码问题","date":"2017-09-23T16:05:05.000Z","path":"2017/09/24/sublime如何添加python3版本以及中文乱码问题/","text":"一、当同时安装了python2和python3时，如何让sublime text同时支持？ 在sublime text中选择Toos—&gt;Build System—&gt;New Build System，此时会创建一个新文件，内容如下： 123&#123; &quot;shell_cmd&quot;: &quot;make&quot;&#125; 将原有内容删除，把以下内容复制进去： 123456&#123; &quot;cmd&quot;: [&quot;/Library/Frameworks/Python.framework/Versions/3.6/bin/python3&quot;, &quot;-u&quot;, &quot;$file&quot;], &quot;file_regex&quot;: &quot;^[ ]*File \\&quot;(...*?)\\&quot;, line ([0-9]*)&quot;, &quot;selector&quot;: &quot;source.python&quot;, &quot;env&quot;: &#123;&quot;LANG&quot;: &quot;en_US.UTF-8&quot;&#125;&#125; 注意： /Library/Frameworks/Python.framework/Versions/3.6/bin/python3为你安装python3的路径 查看你python2或python3的路径方法。在终端／cmd下执行 which python获取python2路径，执行which python3获取python3路径，复制替换&quot;cmd&quot;中python的路径即可。 &quot;env&quot;: {&quot;LANG&quot;: &quot;en_US.UTF-8&quot;的作用是为了正常地显示中文 将文件保存为Python3.sublime-build，路径为sublime安装目录下的Packages文件夹 二、使用ConvertToUTF8解决中文乱码 使用Ctrl+Shift+P打开Package Control，输入install package按回车，再搜索ConvertToUTF8来安装插件 安装完后再次使用Ctrl+Shift+P打开Package Control，这次输入ConvertToUTF8，回车，再选择UTF-8编码即可。这样就会以utf-8的编码格式编辑文件。","tags":[{"name":"sublime","slug":"sublime","permalink":"https://richardrw.github.io/tags/sublime/"},{"name":"python","slug":"python","permalink":"https://richardrw.github.io/tags/python/"},{"name":"utf-8","slug":"utf-8","permalink":"https://richardrw.github.io/tags/utf-8/"}]},{"title":"test_my_site","date":"2017-09-16T07:23:04.000Z","path":"2017/09/16/test-my-site/","text":"","tags":[]},{"title":"Hello World","date":"2017-09-16T07:08:10.000Z","path":"2017/09/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]