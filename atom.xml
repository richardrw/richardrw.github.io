<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Richard‘s Blog</title>
  <icon>https://www.gravatar.com/avatar/a426ef5f9b38de213a4373837416fea8</icon>
  <subtitle>记录敲码过程中遇到的细节和问题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://richardrw.github.io/"/>
  <updated>2017-11-14T12:57:56.000Z</updated>
  <id>https://richardrw.github.io/</id>
  
  <author>
    <name>Richard</name>
    <email>weichang321@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>把《Flask Web开发》读薄系列之第六章 电子邮件</title>
    <link href="https://richardrw.github.io/2017/11/14/%E6%8A%8A%E3%80%8AFlask%20Web%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E8%96%84%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/"/>
    <id>https://richardrw.github.io/2017/11/14/把《Flask Web开发》读薄系列之第六章 电子邮件/</id>
    <published>2017-11-14T12:57:23.000Z</published>
    <updated>2017-11-14T12:57:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Flask-Mail提供电子邮件支持"><a href="#使用Flask-Mail提供电子邮件支持" class="headerlink" title="使用Flask-Mail提供电子邮件支持"></a>使用Flask-Mail提供电子邮件支持</h1><p>表6-1 Flask-Mail SMTP服务器的配置<br>|配置      | 默认值      | 说明       |<br>|———-|:————|:———–|<br>|MAIL_SERVER| localhost  | 电子邮件服务器的主机名或IP地址|<br>|MAIL_PORT | 25          | 电子邮件服务器的端口|<br>|MAIL_USE_TLS| False     | 启用传输层安全（TLS）协议|<br>|MAIL_USE_SSL| False     | 启用安全套接层（SSL）协议|<br>|MAIL_USENAME| None      | 邮件账户的用户名|<br>|MAIL_PASSWORD| None     | 邮件账户的授权码|</p><ol><li>在<code>hello.py</code>中配置Flask-Mail使用QQ邮箱：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line"># ...</div><div class="line"></div><div class="line">app.config[&apos;MAIL_SERVER&apos;] = &apos;smtp.qq.com&apos;</div><div class="line">app.config[&apos;MAIL_PORT&apos;] = 465</div><div class="line">app.config[&apos;MAIL_USE_SSL&apos;] = True</div><div class="line">app.config[&apos;MAIL_USERNAME&apos;] = os.environ.get(&apos;MAIL_USERNAME&apos;)</div><div class="line">app.config[&apos;MAIL_PASSWORD&apos;] = os.environ.get(&apos;MAIL_PASSWORD&apos;)</div></pre></td></tr></table></figure></li></ol><p><strong>注意</strong>：千万不要把账号密令直接写在脚本中，应该从环境变量中导入。</p><ol><li><p>初始化Flask-Mail：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from flask_mail import Mail</div><div class="line"># ...</div><div class="line"></div><div class="line">mail = Mail(app)</div></pre></td></tr></table></figure></li><li><p>在环境变量中定义<code>MAIL_USERNAME</code>和<code>MAIL_PASSWORD</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(venv) $ export MAIL_USERNAME=&apos;12345678@qq.com&apos;</div><div class="line">(venv) $ export MAIL_PASSWORD=&apos;qwertyuiop&apos;</div></pre></td></tr></table></figure></li></ol><p>此时可以使用<code>echo</code>命令打印出来检查一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(venv) $ echo $MAIL_USERNAME</div><div class="line">&gt;&gt;&gt; &apos;12345678@qq.com&apos;</div><div class="line">(venv) $ echo $MAIL_PASSWORD</div><div class="line">&gt;&gt;&gt; &apos;qwertyuiop&apos;</div></pre></td></tr></table></figure></p><p>定义环境变量后，此时在<strong>同一个终端中</strong>执行<code>python hello.py shell</code>命令，便能获取到想要的环境变量。</p><p><strong>注意</strong>：如果定义好环境变量后把终端关闭再重新打开，那么此时是没有上次定义的环境变量的。所以需要在同一个终端中执行。</p><p>如何让QQ邮箱开启SMTP功能，可以参考<a href="http://blog.csdn.net/lagelangzhi/article/details/51717433" target="_blank" rel="external">flask-mail常见的邮箱配置问题解决</a></p><h1 id="在Python-shell中发送电子邮件"><a href="#在Python-shell中发送电子邮件" class="headerlink" title="在Python shell中发送电子邮件"></a>在Python shell中发送电子邮件</h1><p>在上一个终端中，发送电子邮件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(venv) $ python hello.py shell</div><div class="line">&gt;&gt;&gt; from flask_mail import Message</div><div class="line">&gt;&gt;&gt; from hello import mail</div><div class="line">&gt;&gt;&gt; msg = Message(&apos;test subject&apos;, sender=&apos;12345678@qq.com&apos;, recipients=[&apos;87654321@qq.com&apos;])</div><div class="line">&gt;&gt;&gt; msg.body = &apos;test body&apos;</div><div class="line">&gt;&gt;&gt; msg.html = &apos;&lt;p&gt;test body&lt;/p&gt;&apos;</div><div class="line">&gt;&gt;&gt; with app.app_context():</div><div class="line">···    mail.send(msg)</div></pre></td></tr></table></figure></p><p><strong>注意</strong>：在Flask-Mail中的<code>send()</code>函数使用<code>current_app</code>（程序上下文），因此在shell中发送邮件，需要激活程序上下文。</p><h1 id="在程序中集成发送电子邮件功能"><a href="#在程序中集成发送电子邮件功能" class="headerlink" title="在程序中集成发送电子邮件功能"></a>在程序中集成发送电子邮件功能</h1><ol><li>定义用于发邮件的函数，使<code>hello.py</code>支持电子邮件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">from flask_mail import Message</div><div class="line"># ...</div><div class="line"></div><div class="line"># 给邮件标题添加一个前缀</div><div class="line">app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] = &apos;[Flasky]&apos;</div><div class="line"># 定义发件人</div><div class="line">app.config[&apos;FLASKY_MAIL_SENDER&apos;] = &apos;12345678@qq.com&apos;</div><div class="line"></div><div class="line">def send_email(recipients, subject, template, **kwargs):</div><div class="line">    msg = Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] + subject, sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;], recipients=[recilients])</div><div class="line">    msg.body = render_template(template + &apos;.txt&apos;, **kwargs)</div><div class="line">    msg.html = render_template(template + &apos;.html&apos;, **kwargs)</div><div class="line">    mail.send(msg)</div></pre></td></tr></table></figure></li></ol><p>邮件有纯文本<code>.txt</code>，也有HTML文本<code>.html</code>，客户端显示哪个，取决于邮件客户端的设置。</p><p><strong>拓展</strong>：为什么<code>send()</code>函数中需要<code>**kwargs</code>？<code>**kwargs</code>的作用是什么？<br>答：（1）因为我们不确定模板中需要什么变量参数，在此例中，模板需要的时<code>user</code>这个参数，但是如果换成别的模版，它不仅需要<code>user</code>参数，也需要其他一些参数（如datatime等，关键取决于模板设计成什么样），此时如果我们死死地把<code>send_email()</code>函数写成<code>send_email(recipient, subject, template, user)</code>，那么就失去了灵活性，当换成其他模版时，<code>datatime</code>参数也就无法传入了，因此<code>send()</code>函数需要<code>**kwargs</code>。<br>（2）<code>**kwargs</code>的作用是：当我们不知道需要往函数中传入多少个关键字参数或者想以字典的形式作为参数时，我们可以用<code>**kwargs</code>，这样我们就可以根据实际情况需要，往函数中传入特定个数的参数（数量使具体情况而定）。</p><ol><li>结合视图函数发送电子邮件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># ...</div><div class="line"># 定义收件人为Flasky的管理员</div><div class="line">app.config[&apos;FLASKY_ADMIN&apos;] = os.environ.get(&apos;FLASKY_ADMIN&apos;)</div><div class="line"># ...</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]</div><div class="line">def index():</div><div class="line">    form = NameForm()</div><div class="line">    if form.validate_on_submit():</div><div class="line">        session[&apos;name&apos;] = form.name.data</div><div class="line">        # 查找数据库中是否有该用户名，如果没有，就向数据库中添加新用户，</div><div class="line">        # 因为前面已经设置了SQLALCHEMY_COMMIT_ON_TEARDOWN，所以当请求结束时会自动提交事务</div><div class="line">        user = User.query.filter_by(user_name=form.name.data).first()</div><div class="line">        if user is None:</div><div class="line">            # 插入数据库</div><div class="line">            user = User(user_name=form.name.data)</div><div class="line">            db.session.add(user)</div><div class="line">            # 用于模板中判断是显示Pleased to meet you 还是 Happy to see you again</div><div class="line">            session[&apos;known&apos;] = Flase</div><div class="line">            # 如果收件人不为空，则发送邮件</div><div class="line">            if app.config[&apos;FLASKY_ADMIN&apos;]:</div><div class="line">                send_email(app.config[&apos;FLASKY_ADMIN&apos;], &apos;New User&apos;, &apos;mail/new_user&apos;, user=user)</div><div class="line">        else:</div><div class="line">            session[&apos;konwn&apos;] = True</div><div class="line">        return redirect(url_for(&apos;index&apos;)</div><div class="line">    return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;), known=session.get(&apos;known&apos;, Flase))</div></pre></td></tr></table></figure></li></ol><p>此时我们也需要定义环境变量<code>FLASKY_ADMIN</code>：<br><code>(venv) $ export FLASKY_ADMIN=&#39;12345678@qq.com&#39;</code></p><p><code>template</code>文件夹下的模板文件<code>mail/new_user</code>有两个，分别为<code>new_user.txt</code>和<code>new_user.html</code>。</p><p><code>new_user.txt</code>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">There has a new user that name is &#123;&#123; user.user_name &#125;&#125;</div></pre></td></tr></table></figure></p><p><code>new_user.html</code>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;h1&gt;There has a new user that name is &#123;&#123; user.user_name &#125;&#125;&lt;/h1&gt;</div></pre></td></tr></table></figure></p><h1 id="异步发送电子邮件"><a href="#异步发送电子邮件" class="headerlink" title="异步发送电子邮件"></a>异步发送电子邮件</h1><p>为了避免处理请求过程中不必要的延迟，我们可以把发送电子邮件的函数移到后台线程中处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from threading import Thread</div><div class="line"># ...</div><div class="line"></div><div class="line">def send_async_email(app, msg):</div><div class="line">    with app.app_context():</div><div class="line">        mail.send(msg)</div><div class="line">        </div><div class="line">def send_email(recipients, subject, template, **kwargs):</div><div class="line">    msg = Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] + subject, sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;], recipients=[recilients])</div><div class="line">    msg.body = render_template(template + &apos;.txt&apos;, **kwargs)</div><div class="line">    msg.html = render_template(template + &apos;.html&apos;, **kwargs)</div><div class="line">    thr = Thread(target=send_async_email, args=[app, msg])</div><div class="line">    thr.start()</div><div class="line">    return thr</div></pre></td></tr></table></figure></p><p><strong>注意</strong>：由于在不同线程中执行<code>mail.send()</code>函数，就如前面<em>在Python shell中发送电子邮件</em>章节中提到，<code>send()</code>函数需要程序<code>current_app</code>（程序上下文）中执行，因此需要在执行<code>send()</code>函数的线程中使用<code>app.app_context()</code>人工创建<code>current_app</code>。</p><p>当需要发送大量电子邮件时，使用专门发送电子邮件的作业（如<a href="http://www.celeryproject.org" target="_blank" rel="external">Celery</a>任务队列）处理更合适。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用Flask-Mail提供电子邮件支持&quot;&gt;&lt;a href=&quot;#使用Flask-Mail提供电子邮件支持&quot; class=&quot;headerlink&quot; title=&quot;使用Flask-Mail提供电子邮件支持&quot;&gt;&lt;/a&gt;使用Flask-Mail提供电子邮件支持&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>把《Flask Web开发》读薄系列之第五章 数据库</title>
    <link href="https://richardrw.github.io/2017/11/14/%E6%8A%8A%E3%80%8AFlask%20Web%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E8%96%84%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://richardrw.github.io/2017/11/14/把《Flask Web开发》读薄系列之第五章 数据库/</id>
    <published>2017-11-14T12:56:25.000Z</published>
    <updated>2017-11-14T12:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-1-SQL数据库"><a href="#5-1-SQL数据库" class="headerlink" title="5.1 SQL数据库"></a>5.1 SQL数据库</h1><p>表中有个特殊的列，称为<strong>主键</strong>，其值是表中各行的唯一标识符，表中还可以有称为<strong>外键</strong>的列，<strong>引用同一个表或不同表中某行的主键</strong>，行之间的这种联系称为<strong>关系</strong>，这是SQL数据库的基础。</p><h1 id="5-2-NoSQL数据库"><a href="#5-2-NoSQL数据库" class="headerlink" title="5.2 NoSQL数据库"></a>5.2 NoSQL数据库</h1><p>所有不遵循上节所述关系模型的数据库统称为NoSQL数据库。NoSQL数据库一般使用<strong>集合Collection</strong>代替表，使用<strong>文档Document</strong>代替记录（行）。</p><p>NoSQL数据库可以减少表的数量，但却增加了数据重复量，但数据重复又可以提高查询速度。</p><h1 id="5-3-使用SQL还是NoSQL"><a href="#5-3-使用SQL还是NoSQL" class="headerlink" title="5.3 使用SQL还是NoSQL"></a>5.3 使用SQL还是NoSQL</h1><p>视实际情况所需。</p><h1 id="5-4-Python数据库框架"><a href="#5-4-Python数据库框架" class="headerlink" title="5.4 Python数据库框架"></a>5.4 Python数据库框架</h1><p>数据库包：MySQL、Postgres、SQLite、Redis、MongoDB、CouchDB<br>数据库抽象层代码包（ORM或ODM）：SQLAlchemy、MongoEngine</p><p>一般情况下，ORM和ODM对生产率的提升远远超过“把对象业务转换成数据库业务”而带来的性能降低。</p><h1 id="5-5-使用Flask-SQLAlchemy管理数据库"><a href="#5-5-使用Flask-SQLAlchemy管理数据库" class="headerlink" title="5.5 使用Flask-SQLAlchemy管理数据库"></a>5.5 使用Flask-SQLAlchemy管理数据库</h1><p>在Flask-SQLAlchemy中，使用哪种数据库，要通过URL指定。常用的数据库引擎采用的数据库URL格式如下：</p><p>表5-1 Flask-SQLAlchemy数据库URL<br>|数据库引擎   | URL      |<br>|————-|:——–:|<br>|MySQL        | mysql://username:password@hostname/database|<br>|Postgres     | postgres://username:password@hostname/database|<br>|SQLite(Unix) | sqlite:////absolute/path/to/database|<br>|SQLite(Windows)| sqlite:///c:/absolute/path/to/database|</p><p><code>hostname</code>可以是本地主机（<code>localhost</code>)，也可以是原创服务器。<br><code>database</code>表示要使用的数据库名称。</p><p>程序使用的数据库URL必须保存到Flask配置对象的<code>SQLALCHEMY_DATABASE_URI</code>键中。<br>配置对象中有个<code>SQLALCHEMY_COMMIT_ON_TEARDOWN</code>键，将其设为<code>True</code>时，每次请求结束后都会自动提交数据库中的变动（相当于自动<code>commit</code>）。</p><p>初始化及配置SQLite如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">form flask_sqlalchemy import SQLAlchemy</div><div class="line">import os</div><div class="line"># ...</div><div class="line"></div><div class="line"># 获取文件当前文件父路径</div><div class="line">basedir = os.path.abspath(os.path.dirname(__file__))</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line">app.config[&apos;SQLALCHEMY_DATABASE_URI`] = &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data.sqlite&apos;)</div><div class="line">app.config[`SQLALCHEMY_COMMIT_ON_TEARDOWN`] = True</div><div class="line"></div><div class="line">db = SQLAlchemy(app)</div></pre></td></tr></table></figure></p><p><code>db</code>对象是SQLAlchemy类的实例，表示程序所使用的数据库。</p><h1 id="5-6-定义模型"><a href="#5-6-定义模型" class="headerlink" title="5.6 定义模型"></a>5.6 定义模型</h1><p>在ORM中，模型（相当于数据库表table）一般是个Python类，类中的属性对应数据库表中的列。</p><p>在hello.py中定义Role模型和User模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Role(db.Model):</div><div class="line">    __tablename__ &apos;roles&apos;</div><div class="line">    id = db.Column(db.Integer, primary_key=True)</div><div class="line">    role_name = db.Column(db.String(64), unique=True)</div><div class="line">    </div><div class="line">    def __repr__(self):</div><div class="line">        return &apos;&lt;Role &#123;&#125;&gt;&apos;.format(self.role_name)</div><div class="line">  </div><div class="line">def User(db.Model):</div><div class="line">    __tablename__ = &apos;users&apos;</div><div class="line">    id = db.Column(db.integer, primary_key=True)</div><div class="line">    user_name = db.Column(db.String(64), unique=True, index=True)</div><div class="line">    </div><div class="line">    def __repr__(self):</div><div class="line">        return &apos;&lt;User &#123;&#125;&gt;&apos;.format(self.user_name)</div></pre></td></tr></table></figure></p><p>类变量<code>__tablename__</code>定义在数据库中使用的<strong>表名</strong>，如果没有定义，Flask-SQLAlchemy会使用一个默认名字，但该名字没有遵守使用复数形式进行命名的约定。</p><p><code>db.Column</code>类构造函数的第一个参数是数据库列的类型（如Integer、String等），对应模型（即Python类）的对象类型（如int、str等）</p><p>表5-2 最常用的SQLAlchemy列类型<br>|类型名称   | 对应Python类型   | 说明      |<br>|:———-|:—————-:|:———:|<br>|Integer    | int              | 普通整数，一般时32位|<br>|Float      | int              | 浮点数    |<br>|String     | str              | 变长字符串|<br>|Text       | str              | 变成字符串，对较长或不限长度的字符串做了优化|<br>|Unicode    | unicode          | 变长Unicode字符串|<br>|UnicodeText| unicode          | 变长Unicode字符串，对较长货不限长度的字符串做了优化|<br>|Date       | datetime.data    | 日期      |<br>|Time       | datetime.time    | 时间      |<br>|DateTime   | datetime.datetime| 日期和时间|</p><p><code>db.Column</code>中其余的参数可对列中的数据做一些配置或设置</p><p>表5-3 最常用的SQLAlchemy列选项<br>|选项名     | 说明      |<br>|———–|:———-|<br>|primary_key| 如果设为True，这列是主键|<br>|unique     | 如果设为True，这列不允许出现重复值|<br>|index      | 如果设为True，为这列创建索引，提高查询效率|<br>|nullable   | 如果设为True，这列允许使用空值；设为False，则不允许为空|<br>|default    | 为这列设置默认值|</p><p><strong>注意</strong>：Flask-SQLAlchemy要求每个模型都要定义主键。</p><h1 id="5-7-关系"><a href="#5-7-关系" class="headerlink" title="5.7 关系"></a>5.7 关系</h1><p>定义<strong>一对多关系</strong>（Role对User）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Role(db.Model):</div><div class="line">    # ...</div><div class="line">    users = db.relationship(&apos;User&apos;, backref=&apos;role&apos;)</div><div class="line">    </div><div class="line">class User(db.Model):</div><div class="line">    # ....</div><div class="line">    role_id = db.Column(db.Integer, db.ForeignKey(&apos;roles.id&apos;)    # 外键：roles表中的id</div></pre></td></tr></table></figure></p><p>添加到Role模型中的类变量<code>users</code>代表这个关系（Role与User的关系）的面向对象视角，它将返回与具体Role实例相关联的用户（具体User实例）组成的列表。（如Role实例<code>role_admin</code>返回的users为<code>[richard, john]</code>，其中<code>richard</code>和<code>john</code>都是User实例，即<code>role_admin.users = [richard,john]</code>体现了面向对象视角的一对多关系）</p><p><code>db.relationship()</code>的第一个参数是这个关系的另一端对应的模型。如果模型尚未定义，可使用字符串形式指定。<code>backref</code>参数为<code>&#39;role&#39;</code>表明：在User模型中添加一个属性（或称为类变量）<code>role</code>（可理解成在User表中添加一列名为<code>role</code>的列。但实际查看数据库表时是看不到的），从而定义反向关系。<br><strong>注意</strong>：一般情况下，<code>db.relationship()</code>都能自行找到关系中的外键，有在某些情况下无法决定把哪一列作为外键。如User模型中有两列或以上的列定义为Role模型的外键，那么SQLAlchemy就不知道该使用哪列了。此时，你就要为<code>db.relationship()</code>提供额外参数，从而确定使用哪列外键。常用配置如表5-4。</p><p>表5-4 <code>db.relationship()</code>常用的SQLAlchemy关系选项<br>|选项名   | 说明          |<br>|———|:————–|<br>|backref  | 在关系的另一端模型中添加反向作用|<br>|primaryjoin| 明确指定两个模型之间使用的联结条件。只在模凌两可的关系中需要指定|<br>|lazy     | 指定如何加载相关记录。可选值有：select（首次访问时按需加载），immediate（源对象加载后加载），joined（加载记录，但使用联结），subquery（立即加载，但使用子查询），noload（永不加载），dynamic（不加载记录，单提供加载记录的查询）|<br>|userlist | 如果设为Fales，不适用列表，而使用标量值|<br>|order_by | 指定关系中记录的排序方式|<br>|secondary| 指定多对多关系中关系表的名字|<br>|secondaryjoin| SQLAlchemy无法自行决定时，指定多对多关系中的二级联结条件|</p><p><strong>一对一关系</strong>：可以用前面介绍的一对多关系表示，但调用<code>db.relationship()</code>时要把<code>userlist</code>设为<code>False</code>。<br><strong>多对一关系</strong>：可以用一对多关系表示，只是两个表对调。或者把<code>外键</code>和<code>db.relationship()</code>都放在“多”这一侧。<br><strong>多对多关系</strong>：需要用到第三张表（关系表）。</p><h1 id="5-8-数据库操作"><a href="#5-8-数据库操作" class="headerlink" title="5.8 数据库操作"></a>5.8 数据库操作</h1><p>需要在Python Shell中进行操作。</p><h2 id="5-8-1-创建表"><a href="#5-8-1-创建表" class="headerlink" title="5.8.1 创建表"></a>5.8.1 创建表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(venv)$ python hello.py shell</div><div class="line">&gt;&gt;&gt; from hello.py import db</div><div class="line">&gt;&gt;&gt; db.create_all()</div></pre></td></tr></table></figure><p>如果<strong>修改模型</strong>（如增加了一列）后要把修改的地方应用到现在的数据库中，那么更新现有数据库表的粗暴方式是先删除旧表，在重新创建表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; db.drop_all()</div><div class="line">&gt;&gt;&gt; db.create_all()</div></pre></td></tr></table></figure></p><p>但是这种方法会把数据库中原有的数据都删除掉。在5.11 使用Flask-Migrate实现数据库迁移中会介绍更新数据库更好的方式。</p><h2 id="5-8-2-插入行"><a href="#5-8-2-插入行" class="headerlink" title="5.8.2 插入行"></a>5.8.2 插入行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from hello import Role, User</div><div class="line">&gt;&gt;&gt; role_admin = Role(role_name=&apos;admin&apos;)</div><div class="line">&gt;&gt;&gt; role_moderator = Role(role_name=&apos;moderator&apos;)</div><div class="line">&gt;&gt;&gt; role_visitor = Role(role_name=&apos;visitor&apos;)</div><div class="line">&gt;&gt;&gt; user_richard = User(user_name=&apos;richard&apos;)</div><div class="line">&gt;&gt;&gt; user_john = User(user_name=&apos;john&apos;)</div><div class="line">&gt;&gt;&gt; user_david = User(user_name=&apos;david&apos;)</div></pre></td></tr></table></figure><p>现在这些对象只存在于Python中，还没有写入数据库。因此id尚未赋值，所以<code>print(role_admin.id)</code>的结果为<code>None</code>。</p><p>要把对象写入数据库要分两步：</p><ol><li>要把对象添加到会话(<code>db.session</code>)中:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; db.session.add(role_admin)</div><div class="line">&gt;&gt;&gt; db.session.add(user_richard)</div></pre></td></tr></table></figure></li></ol><p>或者简写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; db.session.add_all([role_moderator, role_visitor, user_john, user_david])</div></pre></td></tr></table></figure></p><ol><li>调用<code>commit()</code>提交会话<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; db.session.commit()</div></pre></td></tr></table></figure></li></ol><p>此时对象已经写入数据库，再<code>print(role_admin.id)</code>时，它的结果时<code>1</code>。</p><p>调用<code>db.session.rollback()</code>后，可实现事务回滚。<strong>添加到数据库会话中的所有对象</strong>都会还原为它们在数据库时的状态。</p><p><strong>注意</strong>：如果在写入会话过程中发生了错误，那么整个会话都会实效。这样就保证了数据库的一致性。因为可以防止只更新正确部分，而发生错误的部分没有更新。</p><h2 id="5-8-3-更新行"><a href="#5-8-3-更新行" class="headerlink" title="5.8.3 更新行"></a>5.8.3 更新行</h2><p>在数据库会话上调用<code>add()</code>方法可以更新数据。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; role_admin.role_name = &apos;administrator&apos;</div><div class="line">&gt;&gt;&gt; db.session.add(role_admin)</div><div class="line">&gt;&gt;&gt; db.session.commit()</div></pre></td></tr></table></figure></p><h2 id="5-8-4-删除行"><a href="#5-8-4-删除行" class="headerlink" title="5.8.4 删除行"></a>5.8.4 删除行</h2><p>在数据库会话上调用<code>delete()</code>方法删除数据。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; db.session.delete(role_moderator)</div><div class="line">&gt;&gt;&gt; db.session.commit()</div></pre></td></tr></table></figure></p><p><strong>注意</strong>：插入、更新、删除，只有<code>commit()</code>后才会真正写入数据库。</p><h2 id="5-8-5-查询行"><a href="#5-8-5-查询行" class="headerlink" title="5.8.5 查询行"></a>5.8.5 查询行</h2><p>Flask-SQLAlechemy为每个<strong>模型</strong>（注意不是具体的模型实例）都提供了<code>query</code>对象，在<code>query</code>对象上调用相应方法可进行查询。如查询所有记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; Role.query.all()</div><div class="line">&gt;&gt;&gt;[&lt;Role &apos;admin&apos;&gt;, &lt;Role &apos;visitor&apos;&gt;]</div></pre></td></tr></table></figure></p><p>在<code>query</code>对象上可使用过滤器进行更精确的查询，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; User.query.filter_by(role=role_visitor).all()</div><div class="line">&gt;&gt;&gt; [&lt;User &apos;john&apos;&gt;, &lt;User &apos;david&apos;&gt;]</div></pre></td></tr></table></figure></p><p>表5-5 常用的SQLAlchemy查询过滤器<br>|过滤器     | 说明        |<br>|———–|:———–|<br>|filter()   | 把过滤器添加到原查询上，返回一个新查询|<br>|filter_by()| 把等值过滤器添加到原查询上，返回一个新查询|<br>|limit()    | 使用指定的值限制原查询返回的结果数量，返回一个新查询|<br>|offset()   | 偏移原查询返回的结果，返回一个新查询|<br>|order_by() | 根据指定条件对原查询结果进行排序，返回一个新查询|<br>|group_by() | 根据指定条件对原查询结果进行分组，返回一个新查询|</p><p><strong>注意</strong>：在查询上应用指定过滤器后，需通过一些执行函数执行查询。</p><p>表5-6 最常用的SQLAlchemy查询执行函数<br>|方法       | 说明       |<br>|———–|:———–|<br>|all()      | 以列表的形式返回查询的所有结果|<br>|fitst()    | 返回查询的第一个结果，如果没有，则返回None|<br>|first_or_404()| 返回查询的第一个结果，如果没有，则终止请求，返回404错误响应|<br>|get()      | 返回指定主键对应的行，如果没有，则返回None|<br>|get_or_404()| 返回指定主键对应的行，如果没有，则返回None|<br>|count()    | 返回查询结果的数量|<br>|paginate() | 返回一个Paginate对象，它包含指定范围的结果|</p><p>再看一个从关系的两端查询Role和User之间一对多的关系的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; users = role_visitor.users</div><div class="line">&gt;&gt;&gt; users</div><div class="line">[&lt;User &apos;john&apos;&gt;, &lt;User &apos;david&apos;&gt;]</div><div class="line">&gt;&gt;&gt; users[0].role</div><div class="line">&gt;&gt;&gt; &lt;Role &apos;visitor&apos;&gt;</div></pre></td></tr></table></figure></p><p>执行<code>role_visitor.users</code>时，隐含的查询会调用<code>all()</code>方法返回一个列表，<code>query</code>对象时隐藏的，因此很难做更进一步的查询。此时可在<code>db.relationship()</code>中添加<code>lazy=&#39;dynamic</code>参数，从而禁止自动执行查询（添加后需调用<code>all()</code>等方法才能执行查询，当然也可在执行前调用过滤器）。</p><h1 id="5-9-在视图函数中操作数据库"><a href="#5-9-在视图函数中操作数据库" class="headerlink" title="5.9 在视图函数中操作数据库"></a>5.9 在视图函数中操作数据库</h1><p>新版的<code>hello.py</code>当输入新用户名时，会把新用户名写入数据库，并显示<code>Pleased to meet you!</code>信息；当输入的是旧用户名（数据库中已有的名字）时，会显示<code>Happy to see you again!</code></p><p><code>hello.py</code>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># ...</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;,methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">def index():</div><div class="line">    form = NameForm()</div><div class="line">    if form.validate_on_submit():</div><div class="line">        session[&apos;name&apos;] = form.name.data</div><div class="line">        # 查找数据库中是否有该用户名，如果没有，就向数据库中添加新用户，</div><div class="line">        # 因为前面已经设置了SQLALCHEMY_COMMIT_ON_TEARDOWN，所以当请求结束时会自动提交事务</div><div class="line">        user = User.query.filter_by(user_name=form.name.data).first()</div><div class="line">        if user is None:</div><div class="line">            # 插入数据库</div><div class="line">            user = User(user_name=form.name.data)</div><div class="line">            db.session.add(user)</div><div class="line">            # 用于模板中判断是显示Pleased to meet you 还是 Happy to see you again</div><div class="line">            session[&apos;known&apos;] = Flase</div><div class="line">        else:</div><div class="line">            session[&apos;konwn&apos;] = True</div><div class="line">        return redirect(url_for(&apos;index&apos;)</div><div class="line">    return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;), known=session.get(&apos;known&apos;, Flase))</div></pre></td></tr></table></figure></p><p><code>index.html</code>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;% extends &quot;base.html&quot; %&#125;</div><div class="line">&#123;% import &quot;bootstarp/wtf.html&quot; as wtf %&#125;</div><div class="line"></div><div class="line">&#123;% block title %&#125;Flasky&#123;% endblock %&#125;</div><div class="line"></div><div class="line">&#123;% block page_content %&#125;</div><div class="line">&lt;div class=&quot;page-header&quot;&gt;</div><div class="line">   &lt;h1&gt;Hello, &#123;% if name %&#125;&#123;&#123; name &#125;&#125;&#123;% else %&#125;Stranger&#123;% endif %&#125;!&lt;/h1&gt;</div><div class="line">   &#123;% if known %&#125;</div><div class="line">   &lt;p&gt;Happy to see you again!&lt;/p&gt;</div><div class="line">   &#123;% else %&#125;</div><div class="line">   &lt;p&gt;Pleased to meet you!&lt;/p&gt;</div><div class="line">   &#123;% endif %&#125;</div><div class="line">&lt;/div&gt;</div><div class="line">&#123;&#123; wtf.quick_form(form) &#125;&#125;</div><div class="line">&#123;% endblock %&#125;</div></pre></td></tr></table></figure></p><h1 id="5-10-集成Python-shell"><a href="#5-10-集成Python-shell" class="headerlink" title="5.10 集成Python shell"></a>5.10 集成Python shell</h1><p>每次启动shell会话都要将数据库模型和实例一个一个地import进去很麻烦，对此我们可以为shell命令注册一个<code>make_context</code>回调函数，把想import的对象导入列表。<br>对<code>hello.py</code>修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from flask-script import Shell, Manager</div><div class="line"># ...</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line">manager = Manager(app)</div><div class="line"></div><div class="line">def make_shell_context():</div><div class="line">    return dict(app=app, db=db, Role=Role, User=User)</div><div class="line">manager.add_command(&apos;shell&apos;, Shell(make_context=make_shell_context))</div></pre></td></tr></table></figure></p><p>这样启动shell时就会将对象直接导入shell中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; python hello.py shell</div><div class="line">&gt;&gt;&gt; app</div><div class="line">&lt;Flask &apos;app&gt;</div><div class="line">&gt;&gt;&gt; User</div><div class="line">&lt;class &apos;app.User&apos;&gt;</div></pre></td></tr></table></figure></p><h1 id="5-11-使用Flask-Migrate实现数据库迁移"><a href="#5-11-使用Flask-Migrate实现数据库迁移" class="headerlink" title="5.11 使用Flask-Migrate实现数据库迁移"></a>5.11 使用Flask-Migrate实现数据库迁移</h1><p>在5.8.1 创建数据库表中我们说到，更新表的方法之一是删除旧表再重新创建表，但是这会丢失原有的数据。现在介绍方法二：使用数据库迁移框架。<br><strong>数据库迁移框架</strong>：能够跟踪数据库<strong>模式</strong>的变化，然后增量式地把变化应用到已有数据库中。（其功能类似与Git，能够跟踪数据库模式的变化）</p><p>可从理解Git的角度理解数据库迁移框架。</p><h2 id="5-11-1-创建迁移仓库"><a href="#5-11-1-创建迁移仓库" class="headerlink" title="5.11.1 创建迁移仓库"></a>5.11.1 创建迁移仓库</h2><p><code>hello.py</code>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from flask-migrate import Migrate, MigrateCommand</div><div class="line"># ...</div><div class="line"></div><div class="line">migrate = Migrate(app, db)</div><div class="line">manager.add_command(&apos;db&apos;, MigrateCommand)</div></pre></td></tr></table></figure></p><p>Flask-Migrate提供了一个<code>MigrateCommand</code>类，它可以附加到Flask-Script的<code>manager</code>对象上，从而导出数据库迁移命令。该例中，MigrateCommand类使用<code>db</code>命令附加（类似于5.10中，将Shell类使用<code>shell</code>命令附加）。</p><p><strong>注意</strong>：在维护数据库迁移之前，首先要使用<code>init</code>子命令<strong>创建迁移仓库</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(venv)$ python hello.py db init</div><div class="line">Creating directory /home/flask/.....</div><div class="line">...</div><div class="line">...</div><div class="line">Please edit configuration/connection/logging setting in &apos;/home/flask/..../alembic.ini&apos; before proceeding.</div></pre></td></tr></table></figure></p><p>这个命令会创建一个<code>migrations</code>的文件夹，所有迁移脚本都在里面。</p><h2 id="5-11-2-创建迁移脚本"><a href="#5-11-2-创建迁移脚本" class="headerlink" title="5.11.2 创建迁移脚本"></a>5.11.2 创建迁移脚本</h2><p>在Alembic中，数据库迁移用<strong>迁移脚本</strong>表示。脚本中有两个函数：<br><code>upgrade()</code>函数：把迁移中的改动应用到数据库中。<br><code>downgrade()</code>函数：将改动删除。</p><p>我们可以用<code>revision</code>命令手动创建Alembic迁移（<code>upgrade()</code>和<code>downgrade()</code>都是空的，需使用Alembic提供的<code>Operations</code>对象指令实现具体操作），<br>也可以用<code>migrate</code>命令自动创建Alembic迁移（会根据<strong>模型定义</strong>和<strong>数据库当前的状态</strong>之前的差异生成<code>upgrade()</code>和<code>downgrade()</code>函数的内容）。</p><p>使用<code>migrate</code>命令自动创建迁移脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(venv)$ python hello.py db migrate -m &quot;initial migration&quot;</div><div class="line">INFO [alembic.migration] Context impl SQLiteImpl</div><div class="line">...</div><div class="line">INFO [alembic.qutogenerate] Detected added table &apos;users&apos;</div><div class="line">...</div><div class="line">.../falsky/migrations/versions/1bc...bb5_initial_migration.py...done</div></pre></td></tr></table></figure></p><h2 id="5-11-3-更新数据库"><a href="#5-11-3-更新数据库" class="headerlink" title="5.11.3 更新数据库"></a>5.11.3 更新数据库</h2><p>检查并修正好迁移脚本后，可以使用<code>db upgrade</code>命令把迁移应用到数据库中。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(venv)$ python hello.py db upgrade</div><div class="line">INFO [alembic.migration] Context impl SQLiteImpl</div><div class="line">...</div><div class="line">INFO [alembic.migration] Running upgrade None -&gt; 1bc...bb5, initial migration</div></pre></td></tr></table></figure></p><p>对于第一个迁移来说，其作用和调用<code>db.create_all()</code>方法一样，但在后续的迁移中，<code>upgrade</code>命令能把改动应用到数据库中，而且不影响其中保存的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;5-1-SQL数据库&quot;&gt;&lt;a href=&quot;#5-1-SQL数据库&quot; class=&quot;headerlink&quot; title=&quot;5.1 SQL数据库&quot;&gt;&lt;/a&gt;5.1 SQL数据库&lt;/h1&gt;&lt;p&gt;表中有个特殊的列，称为&lt;strong&gt;主键&lt;/strong&gt;，其值是表中各行
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>把《Flask Web开发》读薄系列之第四章 Web表单</title>
    <link href="https://richardrw.github.io/2017/11/14/%E6%8A%8A%E3%80%8AFlask%20Web%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E8%96%84%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0%20Web%E8%A1%A8%E5%8D%95/"/>
    <id>https://richardrw.github.io/2017/11/14/把《Flask Web开发》读薄系列之第四章 Web表单/</id>
    <published>2017-11-14T12:54:15.000Z</published>
    <updated>2017-11-14T12:55:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-1-跨站请求伪造保护"><a href="#4-1-跨站请求伪造保护" class="headerlink" title="4.1 跨站请求伪造保护"></a>4.1 跨站请求伪造保护</h1><p><strong>跨站请求伪造(CSRF)</strong>：恶意网站吧请求发送到，被攻击者已登录的其他网站。<br><code>flask-wtf</code>需要程序设置一个密匙。然后利用这个密匙生成加密令牌，再用令牌验证请求中表单数据的真伪，从而实现<strong>CSRF保护</strong>。</p><p>设置<code>flask-wtf</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># ...</div><div class="line">app = Flask(__name__)</div><div class="line">app.config[&apos;SECRET_KEY&apos;] = &apos;hard to guess string&apos;</div></pre></td></tr></table></figure></p><p><strong>注意</strong>：为了增强安全性，密匙不应该直接写入代码中，而要保存环境变量中（第七章介绍）。</p><h1 id="4-2-定义表单类"><a href="#4-2-定义表单类" class="headerlink" title="4.2 定义表单类"></a>4.2 定义表单类</h1><p>使用<code>flask-wtf</code>时，每个Web表单都继承自<code>Form</code>类。这个类定义表单中的一组字段，每组字段都用对象（字段类的实例对象，如<code>StringField（‘hello’）</code>）表示。字段对象可以附有一个或多个<strong>验证函数</strong>。<br><strong>验证函数(validator)</strong>：用来验证用户提交的数据是否符合要求。</p><p>定义名为NameForm的表单类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">from flask-wtf import Form</div><div class="line">from wtforms import StringField, SubmitField</div><div class="line">from wtforms.validators import Required</div><div class="line"></div><div class="line">class NameForm(Form):</div><div class="line">    name = StringField(&apos;What is your name?&apos;, validators=[Required()])</div><div class="line">    submit = SubmitField(&apos;Submit&apos;)</div></pre></td></tr></table></figure></p><p><code>NameForm</code>表单中的字段定义为类变量，<br>类变量的值为对应字段的对象。</p><p><strong>字段构造函数（如SubmitField()）</strong>：的第一个参数是把表单渲染成HTML时使用的标号（或文本）。</p><p><code>validators</code>参数：一个由验证函数组成的<strong>列表</strong>。</p><p><strong>表4-1 WTFORMS支持的HTML标准字段</strong><br>|字段类型   | 说明    |<br>|———–|:——-:|<br>|StringField| 文本字段|<br>|TextAreaField| 多行文本字段|<br>|PasswordField| 密码文本字段|</p><p><strong>表4-2 WTFORMS验证函数</strong><br>|验证函数   | 说明    |<br>|———–|:——-:|<br>|Email      | 验证电子邮件地址|<br>|Required   | 确保字段中有数据|<br>|AnyOf      | 确保输入值在可选值列表中|</p><h1 id="4-3-把表单渲染成HTML"><a href="#4-3-把表单渲染成HTML" class="headerlink" title="4.3 把表单渲染成HTML"></a>4.3 把表单渲染成HTML</h1><p>假设视图函数把一个<code>NameForm</code>实例（通过参数<code>form</code>）传给模板，那么在模板中可以生成一个简单的表单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form method=&quot;POST&quot;&gt;</div><div class="line">    &#123;&#123; form.hidden_tag() &#125;&#125;</div><div class="line">    &#123;&#123; form.name.label&#125;&#125; &#123;&#123; form.name() &#125;&#125;</div><div class="line">    &#123;&#123; form.submit() &#125;&#125;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p><p>为了改进外观，可以将HTML属性（如id、class等）传给渲染字段的函数，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form method=&quot;POST&quot;&gt;</div><div class="line">    &#123;&#123; form.hidden_tag() &#125;&#125;</div><div class="line">    &#123;&#123; form.name.label&#125;&#125; &#123;&#123; form.name(id=&apos;my-text-field&apos;) &#125;&#125;</div><div class="line">    &#123;&#123; form.submit() &#125;&#125;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p><p><code>flask-bootstrap</code>提供了一个辅助函数涌来渲染<code>flask-wtf</code>表单。用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;% import &quot;bootstrap/wtf.html&quot; as wtf %&#125;</div><div class="line">&#123;&#123; wtf.quick_form(form) &#125;&#125;</div></pre></td></tr></table></figure></p><p><code>bootstrap/wtf.html</code>文件中定义了一个用于渲染Flask-WTF<strong>表单对象</strong>的辅助函数。</p><p><code>wtf.qucik_form()</code>函数的参数为<strong>Flask-WTF表单对象</strong>（表单类的实例）。</p><h1 id="4-4-在视图函数中处理表单"><a href="#4-4-在视图函数中处理表单" class="headerlink" title="4.4 在视图函数中处理表单"></a>4.4 在视图函数中处理表单</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># ...</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]</div><div class="line">def index():</div><div class="line">    name = None</div><div class="line">    form = NameForm()  # 实例化表单类</div><div class="line">    if form.validate_on_submit():</div><div class="line">        name = form.name.data</div><div class="line">        form.name.data = &apos;&apos;      # 将form.name.data的值设置为空字符串</div><div class="line">    return render_template(&apos;index.html&apos;, form=form, name=name)</div></pre></td></tr></table></figure><p><code>methods</code>参数告诉Flask在URL映射中把这个视图函数注册为<code>GET</code>和<code>POST</code>请求的处理程序。如果没有指定<code>methods</code>参数，就只把视图函数注册为GET请求的处理程序。</p><p><code>validate_on_submit()</code>：提交表单后，如果数据能被全部验证函数接受，那么<code>validate_on_submit()</code>的返回值为<code>True</code>，否则返回<code>False</code>。</p><h1 id="4-5-重定向和用户会话"><a href="#4-5-重定向和用户会话" class="headerlink" title="4.5 重定向和用户会话"></a>4.5 重定向和用户会话</h1><p>现在的hello.py存在一个问题：用户输入名字后提交表单，然后刷新页面，会出现一个警告（要求在再次提交表单前进行确认）。<br>出现这种情况的<strong>原因是</strong>：刷新页面时，浏览器会重新发送<strong>之前已经发送过的最后一个请求</strong>。如果这个请求是一个包含表单数据的POST请求，刷新页面会再次提交表单。</p><p><strong>解决思路</strong>：使浏览器发送的最后一个请求不是POST请求。<br><strong>解决方法</strong>：使用重定向作为POST请求的响应，而不是使用常规响应。</p><p><strong>重定向</strong>：是一个特殊响应，响应的内容是URL，而不是包含HTML代码的字符串。浏览器收到这种响应时，会向重定向的URL发起GET请求（第二个请求），显示页面内容。</p><p><strong>存在问题</strong>：这种方法会带来另一个问题，程序处理POST请求时，使用<code>form.name.data</code>来获取用户输入值，可是一旦这个请求结束，数据也就丢失（因为这个POST请求使用重定向作为响应）。所以程序需要保存输入值，方便重定向后的请求可以获得并使用这个值。</p><p><strong>解决方法2</strong> ：把数据存储在<strong>用户会话</strong>中。</p><p>使用重定向和用户会话重写<code>hello.py</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from flask import Flask, render_template, session, redirect, url_for</div><div class="line"># ...</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">def index():</div><div class="line">    form = NameForm()</div><div class="line">    if form.validate_on_submit():</div><div class="line">        session[&apos;name&apos;] = form.name.data</div><div class="line">        return redirect(url_for(&apos;index&apos;))</div><div class="line">    return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;))</div></pre></td></tr></table></figure></p><p>使用<code>session.get()</code>方法获取字典中键对应的值，避免未找到键的异常情况。因为对于不存在的键， <code>get()</code>会返回默认值<code>None</code>。</p><h1 id="4-6-Flash消息"><a href="#4-6-Flash消息" class="headerlink" title="4.6 Flash消息"></a>4.6 Flash消息</h1><p>请求完成后，有时需要让用户知道状态发生了变化（如使用确认消息、警告或错误提醒）。一个典型例子是，提交了一项有错误的登录表单后，服务器发回的响应重新渲染登录表单，并且在表单上面显示一个消息，提示用户名或密码错误。</p><p>设置Flash消息的<code>hello.py</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">form flask import Flask, render_template, session, redirect, url_for, flash</div><div class="line"># ...</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]</div><div class="line">def index():</div><div class="line">    form = NameForm()</div><div class="line">    if form.validate_on_submit():</div><div class="line">        old_name = session.get(&apos;name&apos;)</div><div class="line">        if old_name is not None and old_name != form.name.data:</div><div class="line">            flash(&apos;Looks like you have changed your name!&apos;)</div><div class="line">        session[&apos;name&apos;] = form.name.data</div><div class="line">        return redirect(url_for(&apos;index&apos;)</div><div class="line">    return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;))</div></pre></td></tr></table></figure></p><p>在这个示例中，将用户提交的数据和用户会话中的数据比较，如果两个数据不一样，就会调用<code>flash()</code>函数，<strong>在发给客户端的下一个响应中显示一个信息</strong>。</p><p>在模板中渲染Flash消息：仅调用<code>flash()</code>函数并不能将消息显示出来，这个可以在模板中渲染Flash消息。如<code>base.html</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;% block content %&#125;</div><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">    &#123;% for message in get_flashed_messages() %&#125;</div><div class="line">    &lt;div class=&quot;alert alert-warning&quot;&gt;</div><div class="line">        &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;</div><div class="line">        &amp;times;</div><div class="line">        &lt;/button&gt;</div><div class="line">        &#123;&#123; message &#125;&#125;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &#123;% endfor %&#125;</div><div class="line">    &#123;% block page_content %&#125; &#123;% endblock %&#125;</div><div class="line">&lt;/div&gt;</div><div class="line">&#123;% endblock %&#125;</div></pre></td></tr></table></figure></p><p><code>get_flashed_messages()</code>函数用来获取并渲染Flash消息。</p><p><strong>注意</strong>：</p><ol><li>在模板中使用<code>for</code>循环是因为，每次调用<code>falsh()</code>函数时，都会生产一个消息，所以可能有多个消息在排队等待显示，所需需要用<code>for</code>循环将消息都显示出来。</li><li><code>get_flashed_messages()</code>函数获取的消息在下次调用时不会再次返回（如这次获取了消息队列1，那么在下次调用时就不会再返回消息队列1，有点类似于列表的<code>pop()</code>方法），因此Flash消息只显示一次，然后就消失了。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;4-1-跨站请求伪造保护&quot;&gt;&lt;a href=&quot;#4-1-跨站请求伪造保护&quot; class=&quot;headerlink&quot; title=&quot;4.1 跨站请求伪造保护&quot;&gt;&lt;/a&gt;4.1 跨站请求伪造保护&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;跨站请求伪造(CSRF)&lt;/strong&gt;：
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>把《Flask Web开发》读薄系列之第三章 模板</title>
    <link href="https://richardrw.github.io/2017/11/14/%E6%8A%8A%E3%80%8AFlask%20Web%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E8%96%84%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A8%A1%E6%9D%BF/"/>
    <id>https://richardrw.github.io/2017/11/14/把《Flask Web开发》读薄系列之第三章 模板/</id>
    <published>2017-11-14T12:52:00.000Z</published>
    <updated>2017-11-14T13:05:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Flask-Mail提供电子邮件支持"><a href="#使用Flask-Mail提供电子邮件支持" class="headerlink" title="使用Flask-Mail提供电子邮件支持"></a>使用Flask-Mail提供电子邮件支持</h1><p>表6-1 Flask-Mail SMTP服务器的配置<br>|配置      | 默认值      | 说明       |<br>|———-|:————|:———–|<br>|MAIL_SERVER| localhost  | 电子邮件服务器的主机名或IP地址|<br>|MAIL_PORT | 25          | 电子邮件服务器的端口|<br>|MAIL_USE_TLS| False     | 启用传输层安全（TLS）协议|<br>|MAIL_USE_SSL| False     | 启用安全套接层（SSL）协议|<br>|MAIL_USENAME| None      | 邮件账户的用户名|<br>|MAIL_PASSWORD| None     | 邮件账户的授权码|</p><ol><li>在<code>hello.py</code>中配置Flask-Mail使用QQ邮箱：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">#...</div><div class="line"></div><div class="line">app.config[&apos;MAIL_SERVER&apos;] = &apos;smtp.qq.com&apos;</div><div class="line">app.config[&apos;MAIL_PORT&apos;] = 465</div><div class="line">app.config[&apos;MAIL_USE_SSL&apos;] = True</div><div class="line">app.config[&apos;MAIL_USERNAME&apos;] = os.environ.get(&apos;MAIL_USERNAME&apos;)</div><div class="line">app.config[&apos;MAIL_PASSWORD&apos;] = os.environ.get(&apos;MAIL_PASSWORD&apos;)</div></pre></td></tr></table></figure><p><strong>注意</strong>：千万不要把账号密令直接写在脚本中，应该从环境变量中导入。</p><ol><li>初始化Flask-Mail：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from flask_mail import Mail</div><div class="line"># ...</div><div class="line"></div><div class="line">mail = Mail(app)</div></pre></td></tr></table></figure><ol><li>在环境变量中定义<code>MAIL_USERNAME</code>和<code>MAIL_PASSWORD</code>：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(venv) $ export MAIL_USERNAME=&apos;12345678@qq.com&apos;</div><div class="line">(venv) $ export MAIL_PASSWORD=&apos;qwertyuiop&apos;</div></pre></td></tr></table></figure><p>此时可以使用<code>echo</code>命令打印出来检查一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(venv) $ echo $MAIL_USERNAME</div><div class="line">&gt;&gt;&gt; &apos;12345678@qq.com&apos;</div><div class="line">(venv) $ echo $MAIL_PASSWORD</div><div class="line">&gt;&gt;&gt; &apos;qwertyuiop&apos;</div></pre></td></tr></table></figure><p>定义环境变量后，此时在<strong>同一个终端中</strong>执行<code>python hello.py shell</code>命令，便能获取到想要的环境变量。</p><p><strong>注意</strong>：如果定义好环境变量后把终端关闭再重新打开，那么此时是没有上次定义的环境变量的。所以需要在同一个终端中执行。</p><p>如何让QQ邮箱开启SMTP功能，可以参考<a href="http://blog.csdn.net/lagelangzhi/article/details/51717433" target="_blank" rel="external">flask-mail常见的邮箱配置问题解决</a></p><h1 id="在Python-shell中发送电子邮件"><a href="#在Python-shell中发送电子邮件" class="headerlink" title="在Python shell中发送电子邮件"></a>在Python shell中发送电子邮件</h1><p>在上一个终端中，发送电子邮件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(venv) $ python hello.py shell</div><div class="line">&gt;&gt;&gt; from flask_mail import Message</div><div class="line">&gt;&gt;&gt; from hello import mail</div><div class="line">&gt;&gt;&gt; msg = Message(&apos;test subject&apos;, sender=&apos;12345678@qq.com&apos;, recipients=[&apos;87654321@qq.com&apos;])</div><div class="line">&gt;&gt;&gt; msg.body = &apos;test body&apos;</div><div class="line">&gt;&gt;&gt; msg.html = &apos;&lt;p&gt;test body&lt;/p&gt;&apos;</div><div class="line">&gt;&gt;&gt; with app.app_context():</div><div class="line">···    mail.send(msg)</div></pre></td></tr></table></figure></p><p><strong>注意</strong>：在Flask-Mail中的<code>send()</code>函数使用<code>current_app</code>（程序上下文），因此在shell中发送邮件，需要激活程序上下文。</p><h1 id="在程序中集成发送电子邮件功能"><a href="#在程序中集成发送电子邮件功能" class="headerlink" title="在程序中集成发送电子邮件功能"></a>在程序中集成发送电子邮件功能</h1><ol><li>定义用于发邮件的函数，使<code>hello.py</code>支持电子邮件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">from flask_mail import Message</div><div class="line"># ...</div><div class="line"></div><div class="line"># 给邮件标题添加一个前缀</div><div class="line">app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] = &apos;[Flasky]&apos;</div><div class="line"># 定义发件人</div><div class="line">app.config[&apos;FLASKY_MAIL_SENDER&apos;] = &apos;12345678@qq.com&apos;</div><div class="line"></div><div class="line">def send_email(recipients, subject, template, **kwargs):</div><div class="line">    msg = Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] + subject, sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;], recipients=[recilients])</div><div class="line">    msg.body = render_template(template + &apos;.txt&apos;, **kwargs)</div><div class="line">    msg.html = render_template(template + &apos;.html&apos;, **kwargs)</div><div class="line">    mail.send(msg)</div></pre></td></tr></table></figure><p>邮件有纯文本<code>.txt</code>，也有HTML文本<code>.html</code>，客户端显示哪个，取决于邮件客户端的设置。</p><p><strong>拓展</strong>：为什么<code>send()</code>函数中需要<code>**kwargs</code>？<code>**kwargs</code>的作用是什么？<br>答：（1）因为我们不确定模板中需要什么变量参数，在此例中，模板需要的时<code>user</code>这个参数，但是如果换成别的模版，它不仅需要<code>user</code>参数，也需要其他一些参数（如datatime等，关键取决于模板设计成什么样），此时如果我们死死地把<code>send_email()</code>函数写成<code>send_email(recipient, subject, template, user)</code>，那么就失去了灵活性，当换成其他模版时，<code>datatime</code>参数也就无法传入了，因此<code>send()</code>函数需要<code>**kwargs</code>。<br>（2）<code>**kwargs</code>的作用是：当我们不知道需要往函数中传入多少个关键字参数或者想以字典的形式作为参数时，我们可以用<code>**kwargs</code>，这样我们就可以根据实际情况需要，往函数中传入特定个数的参数（数量使具体情况而定）。</p><ol><li>结合视图函数发送电子邮件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># ...</div><div class="line"># 定义收件人为Flasky的管理员</div><div class="line">app.config[&apos;FLASKY_ADMIN&apos;] = os.environ.get(&apos;FLASKY_ADMIN&apos;)</div><div class="line"># ...</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;]</div><div class="line">def index():</div><div class="line">    form = NameForm()</div><div class="line">    if form.validate_on_submit():</div><div class="line">        session[&apos;name&apos;] = form.name.data</div><div class="line">        # 查找数据库中是否有该用户名，如果没有，就向数据库中添加新用户，</div><div class="line">        # 因为前面已经设置了SQLALCHEMY_COMMIT_ON_TEARDOWN，所以当请求结束时会自动提交事务</div><div class="line">        user = User.query.filter_by(user_name=form.name.data).first()</div><div class="line">        if user is None:</div><div class="line">            # 插入数据库</div><div class="line">            user = User(user_name=form.name.data)</div><div class="line">            db.session.add(user)</div><div class="line">            # 用于模板中判断是显示Pleased to meet you 还是 Happy to see you again</div><div class="line">            session[&apos;known&apos;] = Flase</div><div class="line">            # 如果收件人不为空，则发送邮件</div><div class="line">            if app.config[&apos;FLASKY_ADMIN&apos;]:</div><div class="line">                send_email(app.config[&apos;FLASKY_ADMIN&apos;], &apos;New User&apos;, &apos;mail/new_user&apos;, user=user)</div><div class="line">        else:</div><div class="line">            session[&apos;konwn&apos;] = True</div><div class="line">        return redirect(url_for(&apos;index&apos;)</div><div class="line">    return render_template(&apos;index.html&apos;, form=form, name=session.get(&apos;name&apos;), known=session.get(&apos;known&apos;, Flase))</div></pre></td></tr></table></figure><p>此时我们也需要定义环境变量<code>FLASKY_ADMIN</code>：<br><code>(venv) $ export FLASKY_ADMIN=&#39;12345678@qq.com&#39;</code></p><p><code>template</code>文件夹下的模板文件<code>mail/new_user</code>有两个，分别为<code>new_user.txt</code>和<code>new_user.html</code>。</p><p><code>new_user.txt</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">There has a new user that name is &#123;&#123; user.user_name &#125;&#125;</div></pre></td></tr></table></figure><p><code>new_user.html</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;h1&gt;There has a new user that name is &#123;&#123; user.user_name &#125;&#125;&lt;/h1&gt;</div></pre></td></tr></table></figure><h1 id="异步发送电子邮件"><a href="#异步发送电子邮件" class="headerlink" title="异步发送电子邮件"></a>异步发送电子邮件</h1><p>为了避免处理请求过程中不必要的延迟，我们可以把发送电子邮件的函数移到后台线程中处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from threading import Thread</div><div class="line"># ...</div><div class="line"></div><div class="line">def send_async_email(app, msg):</div><div class="line">    with app.app_context():</div><div class="line">        mail.send(msg)</div><div class="line">        </div><div class="line">def send_email(recipients, subject, template, **kwargs):</div><div class="line">    msg = Message(app.config[&apos;FLASKY_MAIL_SUBJECT_PREFIX&apos;] + subject, sender=app.config[&apos;FLASKY_MAIL_SENDER&apos;], recipients=[recilients])</div><div class="line">    msg.body = render_template(template + &apos;.txt&apos;, **kwargs)</div><div class="line">    msg.html = render_template(template + &apos;.html&apos;, **kwargs)</div><div class="line">    thr = Thread(target=send_async_email, args=[app, msg])</div><div class="line">    thr.start()</div><div class="line">    return thr</div></pre></td></tr></table></figure><p><strong>注意</strong>：由于在不同线程中执行<code>mail.send()</code>函数，就如前面<em>在Python shell中发送电子邮件</em>章节中提到，<code>send()</code>函数需要程序<code>current_app</code>（程序上下文）中执行，因此需要在执行<code>send()</code>函数的线程中使用<code>app.app_context()</code>人工创建<code>current_app</code>。</p><p>当需要发送大量电子邮件时，使用专门发送电子邮件的作业（如<a href="http://www.celeryproject.org" target="_blank" rel="external">Celery</a>任务队列）处理更合适。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用Flask-Mail提供电子邮件支持&quot;&gt;&lt;a href=&quot;#使用Flask-Mail提供电子邮件支持&quot; class=&quot;headerlink&quot; title=&quot;使用Flask-Mail提供电子邮件支持&quot;&gt;&lt;/a&gt;使用Flask-Mail提供电子邮件支持&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>把《Flask Web开发》读薄系列之第二章 程序的基本概念</title>
    <link href="https://richardrw.github.io/2017/11/14/%E6%8A%8A%E3%80%8AFlask%20Web%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E8%96%84%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://richardrw.github.io/2017/11/14/把《Flask Web开发》读薄系列之第二章 程序的基本概念/</id>
    <published>2017-11-14T12:45:31.000Z</published>
    <updated>2017-11-14T12:53:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line"></div><div class="line">app = Flask(__name__)</div></pre></td></tr></table></figure><p>Flask实例化只有一个必须指定的参数，即程序主模块或包的名字（也即<code>__name__</code>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># 2.2 路由和视图函数</div><div class="line">1. **路由**：处理URL和函数之间的关系（URL到Python函数的映射关系）的程序。</div><div class="line">```可通过Flask实例提供的`app.route()`装饰器把函数注册为路由。</div></pre></td></tr></table></figure></p><ol><li><strong>视图函数</strong>：像<code>index()</code>这样的函数。</li></ol><h1 id="2-4-一个完整的程序"><a href="#2-4-一个完整的程序" class="headerlink" title="2.4 一个完整的程序"></a>2.4 一个完整的程序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line">    return &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;</div><div class="line"></div><div class="line">@app.route(&apos;/user/&lt;name&gt;&apos;)      # &lt; &gt;尖括号部门是动态url部分</div><div class="line">def user(name):                 # Flask会将动态部分（也即&lt; &gt;部分）作为参数传入视图函数中</div><div class="line">    return &apos;&lt;h1&gt;Hello &#123;&#125;!&apos;.format(name)</div><div class="line">    </div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    app.run(debug=True)</div></pre></td></tr></table></figure><h1 id="2-5-请求-响应"><a href="#2-5-请求-响应" class="headerlink" title="2.5 请求-响应"></a>2.5 请求-响应</h1><h2 id="2-5-1-程序与请求上下文"><a href="#2-5-1-程序与请求上下文" class="headerlink" title="2.5.1 程序与请求上下文"></a>2.5.1 程序与请求上下文</h2><ol><li><code>程序上下文</code>：</li><li><code>请求上下文</code>:</li></ol><h2 id="2-5-2-请求调度"><a href="#2-5-2-请求调度" class="headerlink" title="2.5.2 请求调度"></a>2.5.2 请求调度</h2><p>Flask使用<code>app.route()</code>装饰器或者非装饰器形式的<code>app.add_url_rule()</code>生成<strong>URL和视图函数之间的映射</strong></p><h2 id="2-5-3-请求钩子"><a href="#2-5-3-请求钩子" class="headerlink" title="2.5.3 请求钩子"></a>2.5.3 请求钩子</h2><p><strong>应用场景：</strong>在请求开始时，创建数据库链接或认证用户。（即在处理请求<strong>之前</strong>或<strong>之后</strong>，执行某些代码）<br>Flask提供以下4种钩子：</p><ol><li><code>before_first_request</code>：注册一个函数，<strong>在处理第一个请求之前运行</strong></li><li><code>before_request</code>：注册一个函数，<strong>在每次请求之前运行</strong></li><li><code>after_request</code>：注册一个函数，<strong>如果没有未处理的异常抛出，在每次请求之后运行</strong></li><li><code>teardown_request</code>：注册一个函数，<strong>即使有未处理的异常抛出，也在每次请求之后运行</strong></li></ol><h2 id="2-5-4-响应"><a href="#2-5-4-响应" class="headerlink" title="2.5.4 响应"></a>2.5.4 响应</h2><p><strong>视图函数返回值</strong>可以接受3个参数：响应文本，状态码，一个由header组成的字典。<br><code>make_response()</code>函数可以接受3个参数（和视图函数返回值一样），并返回一个<code>response</code>对象，此时我们可以在<code>response</code>对象上调用各种方法，进一步设置响应。<br>如获得一个<code>response</code>对象，然后设置<code>cookie</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line">from flask import make_response</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line">    response = make_response(&apos;&lt;h1&gt;This document carries a cookie!&lt;/h1&gt;&apos;)</div><div class="line">    response.set_cookie(&apos;answer&apos;, &apos;42&apos;)</div><div class="line">    return response</div></pre></td></tr></table></figure></p><p><code>redirect()</code>函数用于生成<strong>重定向</strong>（一种特殊的响应）。</p><p><code>abort</code>函数用于生产另一种特殊响应，用于处理错误。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line">from flask import redirect</div><div class="line">from flask import abort</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line">@app.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line">    return redirect(&apos;http://www.example.com&apos;)</div><div class="line">    </div><div class="line">@app.route(&apos;/user/&lt;id&gt;&apos;)</div><div class="line">def get_user(id):</div><div class="line">    user = load_user(id)        # load_user()用于读取id，不展开写</div><div class="line">    if not user:</div><div class="line">        abort(404)        # 如果id不存在，返回状态吗404</div><div class="line">    return &apos;&lt;h1&gt;Hello &#123;&#125;&lt;/h1&gt;&apos;.format(id)</div></pre></td></tr></table></figure></p><h1 id="2-6-Flask扩展"><a href="#2-6-Flask扩展" class="headerlink" title="2.6 Flask扩展"></a>2.6 Flask扩展</h1><p>可使用<code>flask-script</code>扩展为Flask程序添加一个命令行解析器，那么就可以自定义很多参数，如监听的host、port等。<br>实现方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">from flask.ext.script import Manager</div><div class="line"># ...</div><div class="line"></div><div class="line">manager = Manager(app)</div><div class="line"></div><div class="line">if __name__ = &apos;__main__&apos;:</div><div class="line">    manager.run()</div></pre></td></tr></table></figure></p><p>把Flask实例<code>app</code>作为参数传给<code>Manager()</code>，初始化实例。<br><strong>注意</strong>：Flask扩展都在<code>flask.ext</code>命名空间下，而Python3.5之后都直接使用<code>from flask-xxx import xxx</code>来导入。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2-1-初始化&quot;&gt;&lt;a href=&quot;#2-1-初始化&quot; class=&quot;headerlink&quot; title=&quot;2.1 初始化&quot;&gt;&lt;/a&gt;2.1 初始化&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>把《Flask Web开发》读薄系列之第一章 创建虚拟环境</title>
    <link href="https://richardrw.github.io/2017/11/14/%E6%8A%8A%E3%80%8AFlask%20Web%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E8%96%84%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>https://richardrw.github.io/2017/11/14/把《Flask Web开发》读薄系列之第一章 创建虚拟环境/</id>
    <published>2017-11-14T12:43:30.000Z</published>
    <updated>2017-11-14T12:44:59.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>切换到目标文件夹目录</li><li>执行<code>virtualenv venv</code>命令，其中<code>venv</code>为虚拟环境名称</li><li>执行<code>source venv/bin/activate</code>激活虚拟环境</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;切换到目标文件夹目录&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;virtualenv venv&lt;/code&gt;命令，其中&lt;code&gt;venv&lt;/code&gt;为虚拟环境名称&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;source venv/bin/activate&lt;/code&gt;激活虚
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>把《Flask Web开发》读薄系列之序言</title>
    <link href="https://richardrw.github.io/2017/11/14/%E6%8A%8A%E3%80%8AFlask%20Web%E5%BC%80%E5%8F%91%E3%80%8B%E8%AF%BB%E8%96%84%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BA%8F%E8%A8%80/"/>
    <id>https://richardrw.github.io/2017/11/14/把《Flask Web开发》读薄系列之序言/</id>
    <published>2017-11-14T12:20:58.000Z</published>
    <updated>2017-11-14T12:38:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读者的疑惑"><a href="#读者的疑惑" class="headerlink" title="读者的疑惑"></a>读者的疑惑</h1><p>《把<flask web开发——基于python的web应用开发实战="">读薄系列》主要是对《Flask Web开发》一书的概括，或许你读起来会吐槽说“卧靠，这不就是书中的内容吗，直接把书中的内容搬过来就可以成一个系列了，真牛逼“。对此，我只能说读书笔记大概就是这样吧。你对其中的内容懂了，就会觉得很容易，觉得很没必要做这样的一种记录，完全是照搬书中内容，没有什么实质东西。但是，该系列也并不完全是书中内容，它还包括作者对一些该概念的理解、类比，以及代码实现过程中可能遇到的、应该注意的坑等。如：把第五章数据库中的5.11 使用Flask-Migrate实现数据库迁移，跟Git版本控制联系起来，结合理解。如：第六章电子邮件中通过QQ邮箱服务器发送邮件应该注意的坑，以及拓展对<code>**kwargs</code>的理解和实际应用情景。总的来说，该系列主要起到的作用如下：</flask></p><ul><li>起到思维导图作用。当你初学完或者之前学过但是没有实际应用过，那么该系列可以帮助你勾起记忆，尽快掌握Flask的一些基本知识。另外也能让你根据思维导图你查漏补缺。</li><li>加入一些类比，加强理解书中概念。如前面说到的Flask-Migrate与Git的类比。书中的一些类比能否帮助你，视人而已，因为每个人对概念的理解都不同，就像不是所有读者都了解Git一样。</li><li>拓展对Python一些概念的理解。亦如前面说到的对<code>**kwargs</code>的理解。</li></ul><h1 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h1><p>可能是翻译的原因，书中偶尔会出现的一些句子或内容读起来很费劲，很难理解，对此，作者也尽量以平实的语言概括该系列，甚至是以提炼出“存在问题—解决思路—解决方法“或者问答的形式来概括书中内容，加深理解。如第四章4.5 重定向和用户会话，作者根据书中内容提炼出“存在问题—解决思路—解决方法”来解释为什么使用重定向和用户会话。</p><p>另外，为了更准确地表达意思，该系列中的一些章节的名字可能与原书的章节名字不同，但这并不要紧，意思对了就行。</p><p>最后还是要感谢一下@路人甲，他在小密圈对圈友发布的读书笔记奖励活动，激励大家读书长知识。（虽然该系列在发发布活动前就已经在写哈哈，但也起到了很大的激励作用，营造出了一种学习气氛）</p><h1 id="联系作者"><a href="#联系作者" class="headerlink" title="联系作者"></a>联系作者</h1><p>如果你对《Flask Web开发——基于Python的Web应用开发实战》书中的内容有一些很好的个人理解（如用类比来理解）等，可以把你的理解整理好发送到作者邮箱：weichang321@gmail.com。我将会筛选一些好的内容加入到该系列中，并署上你的名字。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;读者的疑惑&quot;&gt;&lt;a href=&quot;#读者的疑惑&quot; class=&quot;headerlink&quot; title=&quot;读者的疑惑&quot;&gt;&lt;/a&gt;读者的疑惑&lt;/h1&gt;&lt;p&gt;《把&lt;flask web开发——基于python的web应用开发实战=&quot;&quot;&gt;读薄系列》主要是对《Flask Web开
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>构建爬取大众点评美食数据的多线程爬虫（含多进程实现）（一）</title>
    <link href="https://richardrw.github.io/2017/10/20/%E6%9E%84%E5%BB%BA%E7%88%AC%E5%8F%96%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84%E7%BE%8E%E9%A3%9F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://richardrw.github.io/2017/10/20/构建爬取大众点评美食数据的多进程爬虫（一）/</id>
    <published>2017-10-20T14:07:02.000Z</published>
    <updated>2017-11-04T14:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建爬取大众点评美食数据的多进程爬虫（一）"><a href="#构建爬取大众点评美食数据的多进程爬虫（一）" class="headerlink" title="构建爬取大众点评美食数据的多进程爬虫（一）"></a>构建爬取大众点评美食数据的多进程爬虫（一）</h1><h2 id="一、要抓取哪些数据"><a href="#一、要抓取哪些数据" class="headerlink" title="一、要抓取哪些数据"></a>一、要抓取哪些数据</h2><p>以东莞美食为例<a href="http://www.dianping.com/search/category/219/10/g0r0" target="_blank" rel="external">大众点评-美食-东莞</a>，可以看到，在美食页面，我们想要爬取的信息有：</p><ol><li>商户标题</li><li>星级</li><li>评论数</li><li>人均价格</li><li>各项评分</li><li>菜系</li><li>地址</li></ol><h2 id="二、分析页面"><a href="#二、分析页面" class="headerlink" title="二、分析页面"></a>二、分析页面</h2><h3 id="（一）多观察页面"><a href="#（一）多观察页面" class="headerlink" title="（一）多观察页面"></a>（一）多观察页面</h3><p>通过点击<a href="http://www.dianping.com/search/category/219/10/g112" target="_blank" rel="external">小吃快餐</a>，我们看到小吃快餐下一共有50个页面。再点击<a href="http://www.dianping.com/search/category/219/10/g117" target="_blank" rel="external">面包甜点</a>，发现也只有50个页面。接下来我们看看<a href="http://www.dianping.com/search/category/219/10/g117r434" target="_blank" rel="external">面包甜点-东城区</a>，发现最多也只有50个页面。如此类推，我们大概可以确定，某菜系-某区域最多只有50个页面，由此基本可以判断，这应该是大众点评做大反爬虫措施。对此，我们在稍后的爬虫设计中，不能简单地从某一菜系下爬取所有页面或者从某一区域下爬取所有页面，因为单独选定菜系或者区域，服务器最多只返回50个页面给你。<strong> 因此我们需要将菜系-区域组合起来爬取，尽可能多的爬取商户信息。 </strong><br>通过观察，我们发现在一个网页中，如：<a href="http://www.dianping.com/search/category/219/10/g117r434" target="_blank" rel="external">http://www.dianping.com/search/category/219/10/g117r434</a><br><code>g117</code>代表菜系，<code>r434</code>代表区域，因此我们可以获取所有的菜系链接，接着在菜系链接的基础上获取菜系-区域链接，这就相当于在用浏览器浏览时，先选定了某一菜系，再选定某一区域。</p><h3 id="（二）分析页面结构"><a href="#（二）分析页面结构" class="headerlink" title="（二）分析页面结构"></a>（二）分析页面结构</h3><p>这里就是要通过定位来选定我们需要的元素。如一级菜系，它所处的位置是<code>id=&quot;classfy</code>的<code>div</code>标签下的<code>a</code>标签中。<br>商户标题，它所处的位置是<code>class=&quot;tit&quot;</code>的<code>div</code>标签下的第一个<code>a</code>标签中。通过一个个地查看，我们可以得出我们要爬取的7个商户信息的位置，方便我们后续设计爬虫时进行定位。</p><h2 id="三、设计爬虫"><a href="#三、设计爬虫" class="headerlink" title="三、设计爬虫"></a>三、设计爬虫</h2><h3 id="（一）爬虫思路"><a href="#（一）爬虫思路" class="headerlink" title="（一）爬虫思路"></a>（一）爬虫思路</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wx1.sinaimg.cn/large/006XG4i7gy1fkpn3b1n9rj30fc0gpdgi.jpg" alt="爬虫流程图" title="">                </div>                <div class="image-caption">爬虫流程图</div>            </figure><ol><li>从<code>start_url</code>开始，爬取所有一级菜系链接，得到<code>tag1_url</code>，存入数据库。</li><li>从数据库中读取<code>tag1_url</code>，爬取所有二级菜系链接，得到<code>tag2_url</code>，存入数据库。</li><li>从数据库中读取<code>tag2_url</code>，爬取所有一级区域链接，得到<code>addr1_url</code>，存入数据库。</li><li>从数据库中读取<code>addr1_url</code>，爬取所有二级区域链接，得到<code>addr2_url</code>，存入数据库。</li><li>从数据库中读取<code>addr2_url</code>，爬取所有商户信息，得到<code>dpshop_msg</code>，存入数据库。<br>1-4目的都是一样，为了获取最终要爬取的页面链接，5就是为了实际爬取上述7个商户信息，所以我们把1-4写到<code>cate_parsing.py</code>文件中，把5写到<code>shop_parsing.py</code>文件中。另外，为了应对反爬虫，我们将用于伪装的<code>User-Agent</code>和<code>代理IP</code>等一些爬虫参数写到<code>config.py</code>文件中。<h3 id="（二）构建代码"><a href="#（二）构建代码" class="headerlink" title="（二）构建代码"></a>（二）构建代码</h3><code>config.py</code>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">#coding=utf-8</div><div class="line"></div><div class="line"></div><div class="line">#伪装浏览器</div><div class="line">USER_AGENT = [</div><div class="line">    &apos;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&apos;,</div><div class="line">    &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36&apos;,</div><div class="line">    &apos;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11&apos;,</div><div class="line">    &apos;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16&apos;,</div><div class="line">    &apos;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0&apos;,</div><div class="line">    &apos;Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10&apos;</div><div class="line">    ]</div><div class="line"></div><div class="line"># 代理IP</div><div class="line">PROXY = [</div><div class="line">    &apos;111.13.111.184:80&apos;,</div><div class="line">    &apos;49.119.164.175:80&apos;,</div><div class="line">    &apos;61.136.163.245:3128&apos;,</div><div class="line">    &apos;116.199.2.210:80&apos;,</div><div class="line">    &apos;116.199.2.209:80&apos;,</div><div class="line">    &apos;116.199.115.79:80&apos;,</div><div class="line">    &apos;116.199.2.196:80&apos;,</div><div class="line">    &apos;121.40.199.105:80&apos;,</div><div class="line">    &apos;125.77.25.118:80&apos;,</div><div class="line">    &apos;122.228.253.55:808&apos;</div><div class="line">    ]</div><div class="line"></div><div class="line">TIMEOUT = 5</div><div class="line"></div><div class="line">LINKTIME = 3</div><div class="line"></div><div class="line">PAGE_NUM_MAX = 50</div></pre></td></tr></table></figure></li></ol><p><code>cate_parsing.py</code>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div></pre></td><td class="code"><pre><div class="line">#coding=utf-8</div><div class="line"></div><div class="line">import requests</div><div class="line">import random</div><div class="line">import pymongo</div><div class="line">import time</div><div class="line">from lxml import etree</div><div class="line">from config import USER_AGENT, PROXY, TIMEOUT, LINKTIME</div><div class="line"></div><div class="line">client = pymongo.MongoClient(&apos;localhost&apos;, 27017)</div><div class="line">dp = client[&apos;dp&apos;]</div><div class="line"></div><div class="line"></div><div class="line"># 爬取一级菜系、二级菜系、二级菜系下的一级地址</div><div class="line">class GetTagAddr(object):</div><div class="line">    headers = random.choice(USER_AGENT)</div><div class="line">    proxies = &#123;&apos;http&apos;:random.choice(PROXY)&#125;</div><div class="line">    s = requests.Session()</div><div class="line">    s.headers.update(&#123;&apos;User-Agent&apos;:headers&#125;)</div><div class="line">    linktime = LINKTIME</div><div class="line">    timeout = TIMEOUT</div><div class="line">    tag1_url_db = dp[&apos;tag1_url_db&apos;]             # 存储从start_url中成功爬取到的tag1_url</div><div class="line">    tag2_url_db = dp[&apos;tag2_url_db&apos;]                    # 存储从tag1_url中成功爬取到的tag2_url</div><div class="line">    crawly_tag1_ok = dp[&apos;crawly_tag1_ok&apos;]    # 存储爬取成功的tag1_url</div><div class="line">    addr1_url_db = dp[&apos;addr1_url_db&apos;]            # 存储从tag2_url中成功爬取到的addr1_url</div><div class="line">    crawly_tag2_ok = dp[&apos;crawly_tag2_ok&apos;]    # 存储爬取成功的tag2_url</div><div class="line">    addr2_url_db = dp[&apos;addr2_url_db&apos;]            # 存储从addr1_url中成功爬取到的addr2_url</div><div class="line">    crawly_addr1_ok = dp[&apos;crawly_addr1_ok&apos;]  # 存储爬取成功的addr1_url</div><div class="line"></div><div class="line"></div><div class="line">    def get_tag1_from(self, start_url):</div><div class="line">        try:</div><div class="line">            r = self.s.get(start_url, proxies=self.proxies, timeout=self.timeout)</div><div class="line">            tree = etree.HTML(r.text)</div><div class="line">            tag1_items = tree.xpath(&apos;//div[@id=&quot;classfy&quot;]/a&apos;)</div><div class="line">            for i in tag1_items:</div><div class="line">                tag1 = i.getchildren()[0].text</div><div class="line">                url = i.attrib[&apos;href&apos;]</div><div class="line">                tag1_url_msg = &#123;&apos;tag1&apos;: tag1, &apos;url&apos;: url, &apos;status&apos;: &apos;ok&apos;&#125;</div><div class="line">                self.tag1_url_db.insert_one(tag1_url_msg)</div><div class="line">            self.linktime = 3    # 重置linktime</div><div class="line">            time.sleep(1)</div><div class="line">        except(requests.exceptions.ProxyError, requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError):</div><div class="line">            if self.linktime &gt; 0:</div><div class="line">                print(&apos;爬取失败，现在重新链接&apos;)</div><div class="line">                self.get_tag1_from(start_url)</div><div class="line">                self.linktime -= 1</div><div class="line">            else:</div><div class="line">                print(&apos;&#123;&#125;爬取失败&apos;.format(start_url))</div><div class="line"></div><div class="line"></div><div class="line">    def get_tag2_from(self, tag1_url):</div><div class="line">        tag1_url_msg = self.tag1_url_db.find_one(&#123;&apos;url&apos;: tag1_url&#125;)</div><div class="line">        tag1 = tag1_url_msg[&apos;tag1&apos;]</div><div class="line">        try:</div><div class="line">            r = self.s.get(tag1_url, proxies=self.proxies, timeout=self.timeout)</div><div class="line">            tree = etree.HTML(r.text)</div><div class="line">            tag2_items = tree.xpath(&apos;//div[@id=&quot;classfy-sub&quot;]/a&apos;)</div><div class="line">            if len(tag2_items) == 0:</div><div class="line">                tag2 = &apos;no_sub&apos;</div><div class="line">                tag2_url_msg = &#123;&apos;tag1&apos;: tag1, &apos;tag2&apos;: tag2, &apos;url&apos;: tag1_url, &apos;status&apos;: &apos;tag1_not_sub&apos;&#125;</div><div class="line">                self.tag2_url_db.insert_one(tag2_url_msg)</div><div class="line">            else:</div><div class="line">                for i in tag2_items:</div><div class="line">                    tag2 = i.getchildren()[0].text</div><div class="line">                    url = i.attrib[&apos;href&apos;]</div><div class="line">                    tag2_url_msg = &#123;&apos;tag1&apos;: tag1, &apos;tag2&apos;: tag2, &apos;url&apos;: url, &apos;status&apos;: &apos;ok&apos;&#125;</div><div class="line">                    self.tag2_url_db.insert_one(tag2_url_msg)</div><div class="line">            self.crawly_tag1_ok.insert_one(&#123;&apos;url&apos;: tag1_url&#125;)</div><div class="line">            self.linktime = 3    # 重置linktime</div><div class="line">            time.sleep(1)</div><div class="line">        except(requests.exceptions.ProxyError, requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError):</div><div class="line">            if self.linktime &gt; 0:</div><div class="line">                print(&apos;爬取失败，现在重新链接&apos;)</div><div class="line">                self.get_tag2_from(tag1_url)</div><div class="line">                self.linktime -= 1</div><div class="line">            else:</div><div class="line">                print(&apos;&#123;&#125;爬取失败&apos;.format(tag1_url))</div><div class="line"></div><div class="line"></div><div class="line">    def get_addr1_from(self, tag2_url):</div><div class="line">        tag2_url_msg = self.tag2_url_db.find_one(&#123;&apos;url&apos;: tag2_url&#125;)</div><div class="line">        tag1 = tag2_url_msg[&apos;tag1&apos;]</div><div class="line">        tag2 = tag2_url_msg[&apos;tag2&apos;]</div><div class="line">        try:</div><div class="line">            r = self.s.get(tag2_url, proxies=self.proxies, timeout=self.timeout)</div><div class="line">            tree = etree.HTML(r.text)</div><div class="line">            addr1_items = tree.xpath(&apos;//div[@id=&quot;region-nav&quot;]/a&apos;)</div><div class="line">            for i in addr1_items:</div><div class="line">                addr1 = i.getchildren()[0].text</div><div class="line">                url = i.attrib[&apos;href&apos;]</div><div class="line">                addr1_url_msg = &#123;&apos;tag1&apos;: tag1, &apos;tag2&apos;: tag2, &apos;addr1&apos;: addr1, &apos;url&apos;: url&#125;</div><div class="line">                self.addr1_url_db.insert_one(addr1_url_msg)</div><div class="line">            self.crawly_tag2_ok.insert_one(&#123;&apos;url&apos;: tag2_url&#125;)</div><div class="line">            self.linktime = 3  # 重置linktime</div><div class="line">            time.sleep(1)</div><div class="line">        except(requests.exceptions.ProxyError, requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout,</div><div class="line">               requests.exceptions.ConnectionError):</div><div class="line">            if self.linktime &gt; 0:</div><div class="line">                print(&apos;爬取失败，现在重新链接&apos;)</div><div class="line">                self.get_addr1_from(tag2_url)</div><div class="line">                self.linktime -= 1</div><div class="line">            else:</div><div class="line">                print(&apos;&#123;&#125;爬取失败&apos;.format(tag2_url))</div><div class="line"></div><div class="line"></div><div class="line">    def get_addr2_from(self, addr1_url):</div><div class="line">        addr1_url_msg = self.addr1_url_db.find_one(&#123;&apos;url&apos;: addr1_url&#125;)</div><div class="line">        tag1 = addr1_url_msg[&apos;tag1&apos;]</div><div class="line">        tag2 = addr1_url_msg[&apos;tag2&apos;]</div><div class="line">        addr1 = addr1_url_msg[&apos;addr1&apos;]</div><div class="line">        try:</div><div class="line">            r = self.s.get(addr1_url, proxies=self.proxies, timeout=self.timeout)</div><div class="line">            tree = etree.HTML(r.text)</div><div class="line">            addr2_items = tree.xpath(&apos;//div[@id=&quot;region-nav-sub&quot;]/a&apos;)</div><div class="line">            if len(addr2_items) == 0:</div><div class="line">                addr2 = &apos;no_sub&apos;</div><div class="line">                addr2_url_msg = &#123;&apos;tag1&apos;: tag1, &apos;tag2&apos;: tag2, &apos;addr1&apos;: addr1, &apos;addr2&apos;: addr2, &apos;url&apos;: addr1_url, &apos;status&apos;: &apos;addr1_not_sub&apos;&#125;</div><div class="line">                self.addr2_url_db.insert_one(addr2_url_msg)</div><div class="line">            else:</div><div class="line">                for i in addr2_items:</div><div class="line">                    addr2 = i.getchildren()[0].text</div><div class="line">                    url = i.attrib[&apos;href&apos;]</div><div class="line">                    addr2_url_msg = &#123;&apos;tag1&apos;:tag1, &apos;tag2&apos;: tag2, &apos;addr1&apos;:addr1, &apos;addr2&apos;: addr2, &apos;url&apos;:url&#125;</div><div class="line">                    self.addr2_url_db.insert_one(addr2_url_msg)</div><div class="line">            self.crawly_addr1_ok.insert_one(&#123;&apos;url&apos;: addr1_url&#125;)</div><div class="line">            self.linktime = 3  # 重置linktime</div><div class="line">            time.sleep(1)</div><div class="line">        except(</div><div class="line">        requests.exceptions.ProxyError, requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout,</div><div class="line">        requests.exceptions.ConnectionError):</div><div class="line">            if self.linktime &gt; 0:</div><div class="line">                print(&apos;爬取失败，现在重新链接&apos;)</div><div class="line">                self.get_addr2_from(addr1_url)</div><div class="line">                self.linktime -= 1</div><div class="line">            else:</div><div class="line">                print(&apos;&#123;&#125;爬取失败&apos;.format(addr1_url))</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    url = &apos;http://www.dianping.com/search/category/219/10/g0r0&apos;</div></pre></td></tr></table></figure></p><p><code>get_tag1_from</code>, <code>get_tag2_from</code>, <code>get_addr1_from</code>和<code>get_addr2_from</code>都采用了同样的逻辑：</p><ol><li>先请求url，获得response。</li><li>使用<code>etree.HTML</code>解析网页。</li><li>定位所要爬取元素的位置。</li><li>存储。</li></ol><p><code>shop_parsing.py</code>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line">#coding=utf-8</div><div class="line"></div><div class="line">import requests</div><div class="line">import random</div><div class="line">import pymongo</div><div class="line">import time</div><div class="line">from lxml import etree</div><div class="line">from config import USER_AGENT, PROXY, TIMEOUT, LINKTIME, PAGE_NUM_MAX</div><div class="line"></div><div class="line"></div><div class="line">client = pymongo.MongoClient(&apos;localhost&apos;, 27017)</div><div class="line">dp = client[&apos;dp&apos;]</div><div class="line">addr2_url_db = dp[&apos;addr2_url_db&apos;]  # 存储从addr1_url中成功爬取到的addr2_url</div><div class="line">dpshop = dp[&apos;dpshop&apos;]  # 存储从addr2中成功爬取到的dpshop_msg</div><div class="line">crawly_addr2_ok = dp[&apos;crawly_addr2_ok&apos;]  # 存储爬取成功的addr2_url</div><div class="line"></div><div class="line"></div><div class="line"># def callback(future):</div><div class="line">#     response, addr2_url = future.result()</div><div class="line">#     get_msg_from(response, addr2_url)</div><div class="line"></div><div class="line"></div><div class="line">def get_msg_from(response, addr2_url):</div><div class="line">    addr2_url_msg = addr2_url_db.find_one(&#123;&apos;url&apos;: addr2_url&#125;)</div><div class="line">    tag1 = addr2_url_msg[&apos;tag1&apos;]</div><div class="line">    tag2 = addr2_url_msg[&apos;tag2&apos;]</div><div class="line">    addr1 = addr2_url_msg[&apos;addr1&apos;]</div><div class="line">    addr2 = addr2_url_msg[&apos;addr2&apos;]</div><div class="line">    tree = etree.HTML(response.text)</div><div class="line">    # 提取标题信息</div><div class="line">    title_items = tree.xpath(&apos;//div[@id=&quot;shop-all-list&quot;]//div[@class=&quot;tit&quot;]/a[1]&apos;)</div><div class="line"></div><div class="line">    # 提取商户星级</div><div class="line">    star_items = tree.xpath(&apos;//div[@class=&quot;comment&quot;]/span&apos;)</div><div class="line"></div><div class="line">    # 提取评论数-人均价格</div><div class="line">    review_price_items = tree.xpath(&apos;//div[@class=&quot;comment&quot;]/a&apos;)</div><div class="line">    review_price_list = []</div><div class="line">    for i in review_price_items:</div><div class="line">        # 判断评论数-价格的a标签是否存在子元素，如果存在，则在子元素中提取评论数-价格，否则评论数-价格都为“None”</div><div class="line">        if i.getchildren():</div><div class="line">            text = i.getchildren()[0].text</div><div class="line">            review_price_list.append(text)</div><div class="line">        else:</div><div class="line">            review_price_list.append(&quot;None&quot;)</div><div class="line">    review_price_list = [review_price_list[i:i + 2] for i in range(0, len(review_price_list), 2)]</div><div class="line"></div><div class="line">    # 提取各项评分</div><div class="line">    score_items = tree.xpath(&apos;//span[@class=&quot;comment-list&quot;]/span/b&apos;)</div><div class="line">    score_items = [i.text for i in score_items]</div><div class="line">    score_items = [score_items[i:i + 3] for i in range(0, len(score_items), 3)]</div><div class="line"></div><div class="line">    # 提取菜系-商区-详细地址</div><div class="line">    tag_items = tree.xpath(&apos;//div[@class=&quot;tag-addr&quot;]//span&apos;)</div><div class="line">    tag_items = [i.text for i in tag_items]</div><div class="line">    tag_items = [tag_items[i:i + 3] for i in range(0, len(tag_items), 3)]</div><div class="line"></div><div class="line">    for title_url, star, review_price, score, tag_area_addr in zip(title_items, star_items, review_price_list,</div><div class="line">                                                                   score_items, tag_items):</div><div class="line">        dpshop_msg = &#123;</div><div class="line">            &apos;title&apos;: title_url.attrib[&apos;title&apos;],</div><div class="line">            &apos;url&apos;: title_url.attrib[&apos;href&apos;],</div><div class="line">            &apos;star&apos;: star.attrib[&apos;title&apos;],</div><div class="line">            &apos;review&apos;: review_price[0],</div><div class="line">            &apos;price&apos;: review_price[1],</div><div class="line">            &apos;taste&apos;: score[0],</div><div class="line">            &apos;env&apos;: score[1],</div><div class="line">            &apos;service&apos;: score[2],</div><div class="line">            &apos;tag1&apos;: tag1,</div><div class="line">            &apos;tag2&apos;: tag2,</div><div class="line">            &apos;addr1&apos;: addr1,</div><div class="line">            &apos;addr2&apos;: addr2,</div><div class="line">            &apos;full_addr&apos;: tag_area_addr[2]</div><div class="line">        &#125;</div><div class="line">        dpshop.insert_one(dpshop_msg)</div><div class="line">    crawly_addr2_ok.insert_one(&#123;&apos;url&apos;: addr2_url&#125;)</div><div class="line"></div><div class="line"></div><div class="line">def get_all_msg_from(addr2_url):</div><div class="line">    for page in range(1, PAGE_NUM_MAX+1):</div><div class="line">        result_url = &apos;&#123;&#125;p&#123;&#125;&apos;.format(addr2_url, page)</div><div class="line">        status_code, response = requests_url(result_url)</div><div class="line">        if status_code == &apos;link_bad&apos;:</div><div class="line">            print(&apos;请求失败，请在crawly_addr2_url_bad中查看请求失败url&apos;)</div><div class="line">            break</div><div class="line">        elif status_code == 404:</div><div class="line">            # addr2_bad = &#123;&apos;url&apos;: result_url, &apos;status&apos;: 404&#125;</div><div class="line">            print(&apos;&#123;&#125;没有相关商户&apos;.format(result_url))</div><div class="line">            break</div><div class="line">        else:</div><div class="line">            get_msg_from(response, addr2_url)</div><div class="line"></div><div class="line"></div><div class="line">def requests_url(result_url, linktime=LINKTIME):</div><div class="line">    s = requests.Session()</div><div class="line">    headers = random.choice(USER_AGENT)</div><div class="line">    s.headers.update(&#123;&apos;User-Agent&apos;: headers&#125;)</div><div class="line">    proxies = &#123;&apos;http&apos;:random.choice(PROXY)&#125;</div><div class="line">    try:</div><div class="line">        r = s.get(result_url, proxies=proxies, timeout=TIMEOUT)</div><div class="line">        time.sleep(1)</div><div class="line">        return (r.status_code, r)</div><div class="line">    except(requests.exceptions.ProxyError, requests.exceptions.ConnectTimeout, requests.exceptions.ReadTimeout,</div><div class="line">           requests.exceptions.ConnectionError):</div><div class="line">        if linktime &gt; 0:</div><div class="line">            print(&apos;请求失败，现在重新链接&apos;)</div><div class="line">            linktime -= 1</div><div class="line">            requests_url(result_url, linktime)</div><div class="line">        else:</div><div class="line">            status_code = &apos;link_bad&apos;</div><div class="line">            response = None</div><div class="line">            return (status_code, response)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    addr2_url = &apos;http://www.dianping.com/search/category/219/10/g217r27028p3&apos;</div></pre></td></tr></table></figure></p><ol><li><code>requests_url</code>函数用于请求网页，并返回状态码和response。</li><li><code>get_msg_from</code>函数用于解析源代码，定位元素，爬取并存储所有我们需要的商户信息。</li><li><code>get_all_msg_from</code>函数实现了多页码爬取，当遇到网页状态码为<code>404</code>时，代表此时没有相关商户，最后一页已经被爬取，自动跳出for循环。结束某个addr2_url的爬取。</li></ol><p><code>run.py</code>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"># coding=utf-8</div><div class="line"></div><div class="line">from parsing.cate_parsing import GetTagAddr</div><div class="line">from parsing.shop_parsing import get_all_msg_from, crawly_addr2_ok</div><div class="line">from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    start_url = &apos;http://www.dianping.com/search/category/219/10/g0r0&apos;</div><div class="line">    tag_addr_task = GetTagAddr()</div><div class="line"></div><div class="line">    # 爬取tag1_url</div><div class="line">    tag_addr_task.get_tag1_from(start_url)</div><div class="line">    print(&apos;tag1_url爬取完成&apos;)</div><div class="line"></div><div class="line">    # 爬取tag2_url</div><div class="line">    tag1_wait = set(i[&apos;url&apos;] for i in tag_addr_task.tag1_url_db.find())</div><div class="line">    tag1_ok = set(i[&apos;url&apos;] for i in tag_addr_task.crawly_tag1_ok.find())</div><div class="line">    tag1_task = tag1_wait - tag1_ok</div><div class="line">    for tag1_url in tag1_task:</div><div class="line">        tag_addr_task.get_tag2_from(tag1_url)</div><div class="line">    print(&apos;tag2_url爬取完成&apos;)</div><div class="line"></div><div class="line">    # 爬取addr1_url</div><div class="line">    tag2_wait = set(i[&apos;url&apos;] for i in tag_addr_task.tag2_url_db.find())</div><div class="line">    tag2_ok = set(i[&apos;url&apos;] for i in tag_addr_task.crawly_tag2_ok.find())</div><div class="line">    tag2_task = tag2_wait - tag2_ok</div><div class="line">    for tag2_url in tag2_task:</div><div class="line">        tag_addr_task.get_addr1_from(tag2_url)</div><div class="line">    print(&apos;addr1_url爬取完成&apos;)</div><div class="line"></div><div class="line">    # 爬取addr2_url</div><div class="line">    addr1_wait = set(i[&apos;url&apos;] for i in tag_addr_task.addr1_url_db.find())</div><div class="line">    addr1_ok = set(i[&apos;url&apos;] for i in tag_addr_task.crawly_addr1_ok.find())</div><div class="line">    addr1_task = addr1_wait - addr1_ok</div><div class="line">    with ProcessPoolExecutor(max_workers=4) as executor:</div><div class="line">        executor.map(tag_addr_task.get_addr2_from, addr1_task)</div><div class="line">    print(&apos;addr2_url爬取完成&apos;)</div><div class="line"></div><div class="line">    # 根据addr2_url爬取商户信息</div><div class="line">    addr2_wait = set(i[&apos;url&apos;] for i in tag_addr_task.addr2_url_db.find())</div><div class="line">    addr2_ok = set(i[&apos;url&apos;] for i in crawly_addr2_ok.find())</div><div class="line">    addr2_task = addr2_wait - addr2_ok</div><div class="line">    with ThreadPoolExecutor(max_workers=8) as executor:</div><div class="line">        for url in addr2_task:</div><div class="line">            v = executor.submit(get_all_msg_from, url)</div><div class="line">        executor.shutdown(wait=True)</div><div class="line">            # executor.map(get_all_msg_from, addr2_task, chunksize=50)</div><div class="line">    print(&apos;addr2_url_reslut_url爬取完成&apos;)</div></pre></td></tr></table></figure></p><ol><li>爬取<code>addr2_url</code>采用多进程爬取，多进程通过<code>concurrent.futures.ProcessPoolExecutor</code>实现。</li><li>爬取<code>dpshop_msg</code>采用了多线程爬取，多线程通过<code>congurrent.futures.ThreadPoolExecutor</code>实现。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构建爬取大众点评美食数据的多进程爬虫（一）&quot;&gt;&lt;a href=&quot;#构建爬取大众点评美食数据的多进程爬虫（一）&quot; class=&quot;headerlink&quot; title=&quot;构建爬取大众点评美食数据的多进程爬虫（一）&quot;&gt;&lt;/a&gt;构建爬取大众点评美食数据的多进程爬虫（一）&lt;/
      
    
    </summary>
    
    
      <category term="Python爬虫" scheme="https://richardrw.github.io/tags/Python%E7%88%AC%E8%99%AB/"/>
    
      <category term="多进程" scheme="https://richardrw.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="大众点评" scheme="https://richardrw.github.io/tags/%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>从美食的角度看东莞（数据来源：大众点评）</title>
    <link href="https://richardrw.github.io/2017/10/20/%E4%BB%8E%E7%BE%8E%E9%A3%9F%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B%E4%B8%9C%E8%8E%9E%EF%BC%88%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90%EF%BC%9A%E5%A4%A7%E4%BC%97%E7%82%B9%E8%AF%84%EF%BC%89/"/>
    <id>https://richardrw.github.io/2017/10/20/从美食的角度看东莞（数据来源：大众点评）/</id>
    <published>2017-10-20T13:35:45.000Z</published>
    <updated>2017-10-21T02:59:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从美食的角度看东莞（数据来源：大众点评）"><a href="#从美食的角度看东莞（数据来源：大众点评）" class="headerlink" title="从美食的角度看东莞（数据来源：大众点评）"></a>从美食的角度看东莞（数据来源：大众点评）</h1><p>先从为什么要做这个项目说起，事情的缘由是这样的，小编当时跟领导到别的城市外出出差一个星期，作为一个平时很少外出的人，别说是别的城市了，就连东莞这个地方我都还没走遍过，尤其是那些重要商区、美食店，平时跟朋友出去玩，都很尴尬不知道要吃什么好。现在跟领导外出别的城市，感觉自己是个刚出大山的农村小伙子，对外面的世界所知甚少。作为领导的助手，自然就要安排好这一星期的就餐地点。然而这就很难为我了，我连东莞有什么地方有好吃的都不知道，现在居然要我在别的城市安排一个星期的就餐作息表？这就很尴尬了。于是我每天都苦于到大众点评、美团等APP上搜索附近美食，但是还是不知道那些餐店的真实情况怎样，环境如何，味道如何。于是此时我就想，如果能一下子就知道某个城市或者某个区中最受欢迎的店有哪些，哪个镇或者哪个区最繁华，那该多好。<br>于是小编回来后就开始构思，接着就撸起袖子加油干，爬取了大众点评上1.5w多条数据，并做了个东莞美食商户数量热力图，从美食的角度看东莞。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wx3.sinaimg.cn/large/006XG4i7gy1fkpnbkccanj30xc0m8myo.jpg" alt="东莞各镇街美食商户数量分布热力图" title="">                </div>                <div class="image-caption">东莞各镇街美食商户数量分布热力图</div>            </figure><br>（因为图片大小问题，莞城、洪梅和大岭山的标签没有显示出来，要解决这个问题，可以找张大点的图制作SVG）</p><p><a href="https://code.hcharts.cn/temp/MYNjyG/share" target="_blank" rel="external">东莞各镇街美食商户数量分布热力图-动态</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wx2.sinaimg.cn/large/006XG4i7gy1fkp14l3pqrj311v0dnmxs.jpg" alt="东莞各镇街美食商户数量柱状图" title="">                </div>                <div class="image-caption">东莞各镇街美食商户数量柱状图</div>            </figure><p>可以看出，东城区商户数量最多，其次是南城区，从热力图来看，也可以看出东莞哪个镇街最繁华，也可以初步判断出哪些镇街经济情况比较好。因为一般经济越好的地区，其商业越繁华越发达。为了验证这个猜想，小编查了下东莞2016年各镇街经济实力排名情况<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wx2.sinaimg.cn/large/006XG4i7gy1fkp14l6t1ij309k0l3ab8.jpg" alt="东莞各镇街2017年经济实力排名情况" title="">                </div>                <div class="image-caption">东莞各镇街2017年经济实力排名情况</div>            </figure><br>可以看出，经济实力与地区商户数量基本成正相关。这里说一个特例吧，那就是松山湖。本地人可能知道原因，那就是因为松山湖建立历史比较年轻，区域布局比较先进，目前仅有万科（好像是）这个大型商场，其他就以大学、高新技术产业区以及青山绿水为主，没有一脑子就开发许多商业区，所以就出现了这个经济实力与地区美食商户数量不匹配的情况。<br>接下来看看各星级商户占比情况如何<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wx3.sinaimg.cn/large/006XG4i7gy1fkp14l3hpyj30sn0bb0t4.jpg" alt="东莞不同星级商户占比饼状图" title="">                </div>                <div class="image-caption">东莞不同星级商户占比饼状图</div>            </figure><br>准四星用户占73.98%，看来东莞的饮食服务业还是可以的（毕竟是广东啊哈哈）<br>再看看东莞各菜系商户数量情况如何<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://wx1.sinaimg.cn/large/006XG4i7gy1fkp14l2dofj311y0cvgm1.jpg" alt="东莞各菜系商户数量柱状图" title="">                </div>                <div class="image-caption">东莞各菜系商户数量柱状图</div>            </figure><br>小吃快餐最多，其次是面包甜点。小吃快餐最多的原因小编猜测可能有三：</p><ol><li>大多数公司中的员工中午都在公司叫外卖，外卖以小吃快餐为主，需求较大，由此催生出一批小吃快餐店，以满足市场需求。</li><li>开小吃快餐店的成本比较低，像沙县小吃什么的快餐店，随便会做个番茄炒蛋饭青瓜肉片饭就能开个快餐店了（哈哈），比面包甜点、西餐的开店成本低。</li><li>大多数小吃快餐店都选择加入大众点评平台，以提高销售量，增加利润。</li></ol><p>至于面包甜点有3155家，这让小编感到意外，没想到东莞居然有这么多面包店。<br>好了，暂时就分析到这里，小编最爱吃的就是面包了，赶紧去看看里面有哪些面包店的，一定要去尝尝。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从美食的角度看东莞（数据来源：大众点评）&quot;&gt;&lt;a href=&quot;#从美食的角度看东莞（数据来源：大众点评）&quot; class=&quot;headerlink&quot; title=&quot;从美食的角度看东莞（数据来源：大众点评）&quot;&gt;&lt;/a&gt;从美食的角度看东莞（数据来源：大众点评）&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="数据分析" scheme="https://richardrw.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="美食" scheme="https://richardrw.github.io/tags/%E7%BE%8E%E9%A3%9F/"/>
    
      <category term="东莞" scheme="https://richardrw.github.io/tags/%E4%B8%9C%E8%8E%9E/"/>
    
  </entry>
  
  <entry>
    <title>年轻人是否到北上广深发展的博弈论分析</title>
    <link href="https://richardrw.github.io/2017/09/25/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E6%98%AF%E5%90%A6%E5%BA%94%E8%AF%A5%E5%88%B0%E5%8C%97%E4%B8%8A%E5%B9%BF%E6%B7%B1%E5%8F%91%E5%B1%95%E7%9A%84%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%88%86%E6%9E%90/"/>
    <id>https://richardrw.github.io/2017/09/25/年轻人是否应该到北上广深发展的博弈论分析/</id>
    <published>2017-09-25T14:05:11.000Z</published>
    <updated>2017-10-07T08:57:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、思考背景"><a href="#一、思考背景" class="headerlink" title="一、思考背景"></a>一、思考背景</h1><p>有人说，当你在一个岗位上工作时间超过1年的时候，你就会不自觉地思考，思考诸如你当前工作的意义是什么、这个岗位是否真的适合你等这些“终极问题”。博主现在已经毕业一年零三个月，实际工作时间已有一年零九个月，在这时间点上，大脑变的不自主地思考起一些关于人生的是非对错问题。引发博主思考这个问题的背景主要有三：</p><ol><li>曾为大学毕业生，也曾思考过到北上广深发展还是留守本地，驻地生根的问题。</li><li>身边有人说，到北上广深发展，只能当炮灰。在沉重的生活成本下，即使工资比二三线城市高，但是实际生活质量却不比二三线城市好，甚至更差。去了只能压榨自己，使自己成为一线城市的“蜡烛”，照亮了别人（成就了上层人士），燃烧了自己（折旧了自己）。</li><li>身边也有人说，到北上广深发展，机会更大。留在本地（二三线城市），固然稳定，生活压力也没那么大，但是一辈子都不会有什么变数，一生只能按现在的状态生活下去，极难遇到让自己人生变得更加美好的变数（机遇）。<br>到底谁说的对，谁说的错，是该往北上广深发展，还是驻地生根。不同的人在做这个决定的时候，他考量的是什么，决策依据是什么，决策背后的理论根据又是什么。此时慢慢地、慢慢地，博主想通过博弈论的角度，看能不能分析出什么，想知道，思考的结果又能不能为博主指明前往更美好生活的方向。</li></ol><hr><p>写着写着发现，这题目太过严肃认真了，提不起兴趣来写，姑且就先来吹吹水吧。<br>想必大家如果留意生活想象的话，应该不难发现这些现象：在足球比赛中，说说国足吧，一开始总是让人觉得放不开来打，等到落后比分的时候才奋力直追放开来打。在帆船比赛中，落后的选手总是不会老老实实地跟着领航者的路线，而是另谋航线以求超越。在LOL等电子竞技赛中，劣势的一方总是希望通过大龙来抢夺来争取一线赢机。为什么人们在处于劣势环境的情况下，总是追求那些很不稳定的方法呢？例如在篮球足球比赛中，落后一方总是采取多冒险的策略，去搞小动作去犯规。下面我们就来用数学先分析一下。我们假设在一场篮球比赛中，比赛的结果由比赛双方的能力和运气一起决定，你的取胜条件需满足：</p><pre><code>你的能力 + 你的运气 &gt; 对手的能力 + 对手的运气</code></pre><p>或者</p><pre><code>你的运气 - 对手的运气 &gt; 你的能力 - 对手的能力        L          &gt;         S</code></pre><p>在一场比赛中，你的能力、对手的能力基本是已经确定的，因为你不会像《龙珠》里的赛亚人那样，打着打着就变身为超级赛亚人提升战斗力，因此我们不妨将<strong> “你的能力 - 对手的能力” </strong>的差值S视为一确定的系数。那么剩下来，影响比赛结果的就是<strong> “你的运气 - 对手的运气“ 的差值L能否大于S </strong>。</p><p>假设对手的能力比你强，你处于劣势，此时S&gt;0，为正值。你要获胜，就必须使得“你的运气 - 对手的运气”的差值L大于S，即当且仅当L&gt;S，你才能获胜。那么我们要如何使得L&gt;S呢？运气这种东西，是我们能够控制的吗？</p><p>我们不妨从数学的角度来看“你的运气 - 对手的运气”的差值L。因为你的运气和对手的运气都是不确定的，必然，“你的运气 - 对手的运气”的差值L也是不确定的，即L的值存在概率性，因此不妨假设L的概率分布是正态曲线（如下图中的实线曲线）。横轴x的任意点，代表L可能的取值，其到曲线上的高y值代表L取某值时对应的概率，因此曲线在两点间覆盖的面积等于L取值位于这两点间的概率。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/Snip20171007_1.png" alt="L取值概率分布图" title="">                </div>                <div class="image-caption">L取值概率分布图</div>            </figure><br>由图可见，你取胜的概率为图中网格的阴影面积，即对于所有L可能的取值，满足L&gt;S的取值的概率之和。<br>到这里，我们已经知道“你的运气 - 对手的运气”的数学上的意义了。那么回到我们之前的问题：运气这种东西，是我们能够控制的吗？</p><p>答案是可以的。或许从感性理解上，这会很不可思议，但是从数学的角度看，改变运气，就是让你改变“你的运气”的概率分布，使得“你的运气 - 对手的运气”大于S变得更加可能。那么我们需要怎么做呢？还是先从数学角度看。让“你的运气 - 对手的运气”的值大于S变得更加可能，也就是让你增大图中的网格阴影面积。</p><p>问：怎么增大？<br>答：让正态曲线更加平坦即可。（如变成上图中的阴线曲线）</p><p>曲线变得更平坦后，由图可见，L&gt;S的面积增加了斜线阴影部分，也就是说L&gt;S的概率更大了。在这种情况下，你获胜的概率也就提升了。</p><p>曲线变得更平坦，意味着L的取值更具不确定性。在实际生活中，你一般只需采取更冒险、更激进的策略就能达到让“你的运气”的概率分布曲线变得更加平台的效果。就如篮球比赛中，对方实力比你强，你处于落后状态，这时，如果你陈规蹈矩，按部就班，那么你是很难有反超的机会的，因为你只能依靠进攻得分，而那些博犯规罚球得分等“非正常”得分你就很少有机会碰到，因为你打得很稳。相反，如果你采取冒险、更加激进的策略，你活得博犯规罚球得分的机会就会变大，得分机会变大，也就意味着你反超的机会变大。</p><p>因此，如果你面对一个比你强大的对手，而你又处于劣势状态，那么你就需要采取一些冒险的策略来打破这种“对手比你厉害，你处于劣势“的稳定状态，从而提高你的胜率。</p><p>回到标题中的问题，答案可以从上述中得出总结，只不过在这个比赛中，对手可能不是别人，而可能是你自己，或者整个大环境。你此时需要衡量一下自己的处境，自己能力对于大环境来说，是强是弱，自己的处境是劣势还是优势，在根据综合判断，看是否需要采取一些冒险的策略来打破平衡、打破稳定，提高自己的胜率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、思考背景&quot;&gt;&lt;a href=&quot;#一、思考背景&quot; class=&quot;headerlink&quot; title=&quot;一、思考背景&quot;&gt;&lt;/a&gt;一、思考背景&lt;/h1&gt;&lt;p&gt;有人说，当你在一个岗位上工作时间超过1年的时候，你就会不自觉地思考，思考诸如你当前工作的意义是什么、这个岗位
      
    
    </summary>
    
    
      <category term="博弈论" scheme="https://richardrw.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="稳定性" scheme="https://richardrw.github.io/tags/%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
      <category term="风险" scheme="https://richardrw.github.io/tags/%E9%A3%8E%E9%99%A9/"/>
    
      <category term="均衡" scheme="https://richardrw.github.io/tags/%E5%9D%87%E8%A1%A1/"/>
    
      <category term="北上广深" scheme="https://richardrw.github.io/tags/%E5%8C%97%E4%B8%8A%E5%B9%BF%E6%B7%B1/"/>
    
  </entry>
  
  <entry>
    <title>sublime如何添加python3版本以及中文乱码问题</title>
    <link href="https://richardrw.github.io/2017/09/24/sublime%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0python3%E7%89%88%E6%9C%AC%E4%BB%A5%E5%8F%8A%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://richardrw.github.io/2017/09/24/sublime如何添加python3版本以及中文乱码问题/</id>
    <published>2017-09-23T16:05:05.000Z</published>
    <updated>2017-09-24T01:22:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、当同时安装了python2和python3时，如何让sublime-text同时支持？"><a href="#一、当同时安装了python2和python3时，如何让sublime-text同时支持？" class="headerlink" title="一、当同时安装了python2和python3时，如何让sublime text同时支持？"></a>一、当同时安装了python2和python3时，如何让sublime text同时支持？</h1><ol><li><p>在sublime text中选择Toos—&gt;Build System—&gt;New Build System，此时会创建一个新文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> &quot;shell_cmd&quot;: &quot;make&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>将原有内容删除，把以下内容复制进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;cmd&quot;: [&quot;/Library/Frameworks/Python.framework/Versions/3.6/bin/python3&quot;, &quot;-u&quot;, &quot;$file&quot;],</div><div class="line">    &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;,</div><div class="line">    &quot;selector&quot;: &quot;source.python&quot;,</div><div class="line">    &quot;env&quot;: &#123;&quot;LANG&quot;: &quot;en_US.UTF-8&quot;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>注意：</strong> <code>/Library/Frameworks/Python.framework/Versions/3.6/bin/python3</code>为你安装python3的路径</p></li><li>查看你python2或python3的路径方法。在终端／cmd下执行    <code>which python</code>获取python2路径，执行<code>which python3</code>获取python3路径，复制替换<code>&quot;cmd&quot;</code>中python的路径即可。</li><li><code>&quot;env&quot;: {&quot;LANG&quot;: &quot;en_US.UTF-8&quot;</code>的作用是为了正常地显示中文</li><li>将文件保存为<code>Python3.sublime-build</code>，路径为sublime安装目录下的<code>Packages</code>文件夹</li></ol><h1 id="二、使用ConvertToUTF8解决中文乱码"><a href="#二、使用ConvertToUTF8解决中文乱码" class="headerlink" title="二、使用ConvertToUTF8解决中文乱码"></a>二、使用ConvertToUTF8解决中文乱码</h1><ol><li>使用Ctrl+Shift+P打开Package Control，输入install package按回车，再搜索ConvertToUTF8来安装插件</li><li>安装完后再次使用Ctrl+Shift+P打开Package Control，这次输入ConvertToUTF8，回车，再选择UTF-8编码即可。这样就会以utf-8的编码格式编辑文件。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、当同时安装了python2和python3时，如何让sublime-text同时支持？&quot;&gt;&lt;a href=&quot;#一、当同时安装了python2和python3时，如何让sublime-text同时支持？&quot; class=&quot;headerlink&quot; title=&quot;一、
      
    
    </summary>
    
    
      <category term="sublime" scheme="https://richardrw.github.io/tags/sublime/"/>
    
      <category term="python" scheme="https://richardrw.github.io/tags/python/"/>
    
      <category term="utf-8" scheme="https://richardrw.github.io/tags/utf-8/"/>
    
  </entry>
  
  <entry>
    <title>test_my_site</title>
    <link href="https://richardrw.github.io/2017/09/16/test-my-site/"/>
    <id>https://richardrw.github.io/2017/09/16/test-my-site/</id>
    <published>2017-09-16T07:23:04.000Z</published>
    <updated>2017-09-16T07:23:04.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://richardrw.github.io/2017/09/16/hello-world/"/>
    <id>https://richardrw.github.io/2017/09/16/hello-world/</id>
    <published>2017-09-16T07:08:10.000Z</published>
    <updated>2017-09-16T07:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
