<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>把《Flask Web开发》读薄系列之第八章 用户认证 | Richard‘s Blog | 记录敲码过程中遇到的细节和问题</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Flask,读书笔记">
    <meta name="description" content="重点说明：根据作者的经验，从第八章开始，若只把书上示例的代码敲上去，是很难重复实现书中效果的，基本上都会出错，原因有（1）书中省略了许多代码（2）由于扩展版本的升级，书中部分代码已不再适用。所以，强烈强烈强烈建议边看书边对照着Git上对应标签的版本阅读源代码，以免遇到巨坑又不知道哪里出错又无法debug。此时也提醒一下自己，要把代码实现一遍后再来做笔记，以免自己坑自己白费功夫。 8.1 Flask">
<meta name="keywords" content="Flask,读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="把《Flask Web开发》读薄系列之第八章 用户认证">
<meta property="og:url" content="https://richardrw.github.io/2017/12/30/把《Flask Web开发》读薄系列之第八章 用户认证/index.html">
<meta property="og:site_name" content="Richard‘s Blog">
<meta property="og:description" content="重点说明：根据作者的经验，从第八章开始，若只把书上示例的代码敲上去，是很难重复实现书中效果的，基本上都会出错，原因有（1）书中省略了许多代码（2）由于扩展版本的升级，书中部分代码已不再适用。所以，强烈强烈强烈建议边看书边对照着Git上对应标签的版本阅读源代码，以免遇到巨坑又不知道哪里出错又无法debug。此时也提醒一下自己，要把代码实现一遍后再来做笔记，以免自己坑自己白费功夫。 8.1 Flask">
<meta property="og:updated_time" content="2017-12-30T11:03:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="把《Flask Web开发》读薄系列之第八章 用户认证">
<meta name="twitter:description" content="重点说明：根据作者的经验，从第八章开始，若只把书上示例的代码敲上去，是很难重复实现书中效果的，基本上都会出错，原因有（1）书中省略了许多代码（2）由于扩展版本的升级，书中部分代码已不再适用。所以，强烈强烈强烈建议边看书边对照着Git上对应标签的版本阅读源代码，以免遇到巨坑又不知道哪里出错又无法debug。此时也提醒一下自己，要把代码实现一遍后再来做笔记，以免自己坑自己白费功夫。 8.1 Flask">
    
        <link rel="alternate" type="application/atom+xml" title="Richard‘s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/author.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Richard</h5>
          <a href="mailto:weichang321@gmail.com" title="weichang321@gmail.com" class="mail">weichang321@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/richardrw" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.weibo.com/6378627091" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">把《Flask Web开发》读薄系列之第八章 用户认证</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">把《Flask Web开发》读薄系列之第八章 用户认证</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-12-30T11:00:49.000Z" itemprop="datePublished" class="page-time">
  2017-12-30
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#8-1-Flask的认证扩展"><span class="post-toc-number">1.</span> <span class="post-toc-text">8.1 Flask的认证扩展</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#8-2-密码的安全性"><span class="post-toc-number">2.</span> <span class="post-toc-text">8.2 密码的安全性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#使用Werkzeug实现密码散列"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">使用Werkzeug实现密码散列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-使app-models-py中的User模型支持密码散列："><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">1. 使app/models.py中的User模型支持密码散列：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-在shell中测试："><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">2. 在shell中测试：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-tests-test-user-model-py支持密码散列测试："><span class="post-toc-number">2.1.3.</span> <span class="post-toc-text">3. tests/test_user_model.py支持密码散列测试：</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#8-3-创建认证蓝本"><span class="post-toc-number">3.</span> <span class="post-toc-text">8.3 创建认证蓝本</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-在app-auth-init-py中创建蓝本："><span class="post-toc-number">3.0.1.</span> <span class="post-toc-text">1. 在app/auth/__init__.py中创建蓝本：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-在app-auth-views-py中定义蓝本中的路由和视图函数："><span class="post-toc-number">3.0.2.</span> <span class="post-toc-text">2. 在app/auth/views.py中定义蓝本中的路由和视图函数：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-在app-init-py中注册蓝本："><span class="post-toc-number">3.0.3.</span> <span class="post-toc-text">3. 在app/__init__.py中注册蓝本：</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#8-4-使用Flask-Login认证用户"><span class="post-toc-number">4.</span> <span class="post-toc-text">8.4 使用Flask-Login认证用户</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-4-1-准备用于登录的用户模型"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">8.4.1 准备用于登录的用户模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-在app-models-py中修改User模型，支持用户登录："><span class="post-toc-number">4.1.1.</span> <span class="post-toc-text">1. 在app/models.py中修改User模型，支持用户登录：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-在app-init-py工厂函数中初始化Flask-Login："><span class="post-toc-number">4.1.2.</span> <span class="post-toc-text">2. 在app/__init__.py工厂函数中初始化Flask-Login：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-Flask-Login要求程序实现一个回调函数，使用指定的标识符加载用户。在app-models-py中定义加载用户的回调函数："><span class="post-toc-number">4.1.3.</span> <span class="post-toc-text">3. Flask-Login要求程序实现一个回调函数，使用指定的标识符加载用户。在app/models.py中定义加载用户的回调函数：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-4-2-保护路由"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">8.4.2 保护路由</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-可以在路由中使用Flask-Login提供的login-required修饰器，使得路由只让认证用户访问（即访问被注册的路由时要先登录用户），如："><span class="post-toc-number">4.2.1.</span> <span class="post-toc-text">1. 可以在路由中使用Flask-Login提供的login_required修饰器，使得路由只让认证用户访问（即访问被注册的路由时要先登录用户），如：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-4-3-定义登录表单"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">8.4.3 定义登录表单</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-在app-auth-forms-py中定义登录表单："><span class="post-toc-number">4.3.1.</span> <span class="post-toc-text">1. 在app/auth/forms.py中定义登录表单：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-在app-templates-base-html导航条中使用Jinja2条件语句，根据当前用户的登录状态显示“Sign-In”或“Sign-Out”："><span class="post-toc-number">4.3.2.</span> <span class="post-toc-text">2. 在app/templates/base.html导航条中使用Jinja2条件语句，根据当前用户的登录状态显示“Sign In”或“Sign Out”：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-4-4-登录用户"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">8.4.4 登录用户</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-在app-auth-views-py中定义登录路由："><span class="post-toc-number">4.4.1.</span> <span class="post-toc-text">1. 在app/auth/views.py中定义登录路由：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-在app-templates-auth-login-htm中渲染登录表单："><span class="post-toc-number">4.4.2.</span> <span class="post-toc-text">2. 在app/templates/auth/login.htm中渲染登录表单：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-4-5-登出用户"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">8.4.5 登出用户</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-在app-auth-views-py中定义登出路由："><span class="post-toc-number">4.5.1.</span> <span class="post-toc-text">1. 在app/auth/views.py中定义登出路由：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-4-6-测试登录（在shell中测试）"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">8.4.6 测试登录（在shell中测试）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-在app-templates-index-html中为已登录的用户显示一个欢迎消息："><span class="post-toc-number">4.6.1.</span> <span class="post-toc-text">1. 在app/templates/index.html中为已登录的用户显示一个欢迎消息：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-在shell中注册新用户（因为未创建用户注册功能，所以可在shell创建新用户）："><span class="post-toc-number">4.6.2.</span> <span class="post-toc-text">2. 在shell中注册新用户（因为未创建用户注册功能，所以可在shell创建新用户）：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-打开登录页面进行登录"><span class="post-toc-number">4.6.3.</span> <span class="post-toc-text">3. 打开登录页面进行登录</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#8-5-注册新用户"><span class="post-toc-number">5.</span> <span class="post-toc-text">8.5 注册新用户</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-5-1-添加用户注册表单"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">8.5.1 添加用户注册表单</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-在app-auth-forms-py中定义用户注册表单："><span class="post-toc-number">5.1.1.</span> <span class="post-toc-text">1. 在app/auth/forms.py中定义用户注册表单：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-渲染template-auth-register-html表单："><span class="post-toc-number">5.1.2.</span> <span class="post-toc-text">2. 渲染template/auth/register.html表单：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-在template-auth-login-html中添加注册页面链接："><span class="post-toc-number">5.1.3.</span> <span class="post-toc-text">3. 在template/auth/login.html中添加注册页面链接：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-5-2-注册新用户（定义注册新用户的路由）"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">8.5.2 注册新用户（定义注册新用户的路由）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-在app-auth-views-py中定义用户注册路由："><span class="post-toc-number">5.2.1.</span> <span class="post-toc-text">1. 在app/auth/views.py中定义用户注册路由：</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#8-6-确认账户（验证邮箱）"><span class="post-toc-number">6.</span> <span class="post-toc-text">8.6 确认账户（验证邮箱）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-6-1-使用itsdangerous生成确认令牌"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">8.6.1 使用itsdangerous生成确认令牌</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-在app-models-py中的User模型中添加验证用户功能："><span class="post-toc-number">6.1.1.</span> <span class="post-toc-text">1. 在app/models.py中的User模型中添加验证用户功能：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-6-2-发送确认邮件"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">8.6.2 发送确认邮件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-在app-auth-views-py中使register路由支持邮件发送："><span class="post-toc-number">6.2.1.</span> <span class="post-toc-text">1. 在app/auth/views.py中使register路由支持邮件发送：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-在app-template-auth-email-confirm-txt中编写确认邮件文本："><span class="post-toc-number">6.2.2.</span> <span class="post-toc-text">2. 在app/template/auth/email/confirm.txt中编写确认邮件文本：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-在app-auth-views-py中定义确认用户的路由："><span class="post-toc-number">6.2.3.</span> <span class="post-toc-text">3. 在app/auth/views.py中定义确认用户的路由：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-在app-auth-views-py中在before-app-request处理程序中过滤未确认的账户："><span class="post-toc-number">6.2.4.</span> <span class="post-toc-text">4. 在app/auth/views.py中在before_app_request处理程序中过滤未确认的账户：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-在app-auth-views-py中支持重新发送验证邮件："><span class="post-toc-number">6.2.5.</span> <span class="post-toc-text">5. 在app/auth/views.py中支持重新发送验证邮件：</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#8-7-管理账户"><span class="post-toc-number">7.</span> <span class="post-toc-text">8.7 管理账户</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-把《Flask Web开发》读薄系列之第八章 用户认证"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">把《Flask Web开发》读薄系列之第八章 用户认证</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-12-30 19:00:49" datetime="2017-12-30T11:00:49.000Z"  itemprop="datePublished">2017-12-30</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p><strong>重点说明</strong>：根据作者的经验，从第八章开始，若只把书上示例的代码敲上去，是很难重复实现书中效果的，基本上都会出错，原因有（1）书中省略了许多代码（2）由于扩展版本的升级，书中部分代码已不再适用。所以，强烈强烈强烈建议边看书边对照着Git上对应标签的版本阅读源代码，以免遇到巨坑又不知道哪里出错又无法debug。此时也提醒一下自己，要把代码实现一遍后再来做笔记，以免自己坑自己白费功夫。</p>
<h1 id="8-1-Flask的认证扩展"><a href="#8-1-Flask的认证扩展" class="headerlink" title="8.1 Flask的认证扩展"></a>8.1 Flask的认证扩展</h1><ol>
<li><code>Werkzeug</code>：计算密码的散列值并进行核对（将密码生成散列值，并验证密码是否正确）。</li>
<li><code>Flask-Login</code>：管理已登录用户的用户会话。</li>
<li><code>itsdangerous</code>：生成并核对加密安全令牌（例如注册账号验证邮箱时生成验证链接时用）。</li>
</ol>
<h1 id="8-2-密码的安全性"><a href="#8-2-密码的安全性" class="headerlink" title="8.2 密码的安全性"></a>8.2 密码的安全性</h1><p>若想保证存储在数据库中的用户密码的安全性，那么就不能存储密码本身，而要存储密码的散列值。当需要核对验证密码是否正确时，核对输入的密码生成的散列值是否与数据库中存储的散列值一致即可。因为计算散列值的函数是可复现的：只要输入一样，结果就一样。</p>
<h2 id="使用Werkzeug实现密码散列"><a href="#使用Werkzeug实现密码散列" class="headerlink" title="使用Werkzeug实现密码散列"></a>使用Werkzeug实现密码散列</h2><p>Werkzeug中的<code>security</code>模块可以实现散列值的计算。这一功能需要用到两个函数（<code>generate_password_hash()</code>和<code>check_password_hash()</code>)，它们分别用在<strong>注册用户</strong>阶段和<strong>验证用户</strong>阶段。</p>
<ul>
<li><p><code>generate_password_hash(password, method=pbkdf2:sha1, salt_length=8)</code>：这个函数将原始密码作为输入，以<strong>字符串</strong>形式输出密码的散列值。<code>method</code>和<code>salt_length</code>的默认值可满足大多数需求。</p>
</li>
<li><p><code>check_password_hash(hash, password)</code>：这个函数的参数分别是从数据库中读取的密码散列值，和用户输入的密码。密码正确则返回<code>True</code>。</p>
</li>
</ul>
<h3 id="1-使app-models-py中的User模型支持密码散列："><a href="#1-使app-models-py中的User模型支持密码散列：" class="headerlink" title="1. 使app/models.py中的User模型支持密码散列："></a>1. 使<code>app/models.py</code>中的<code>User</code>模型支持密码散列：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">from werkzeug.security import generate_password_hash, check_password_hash</div><div class="line"># ...</div><div class="line"></div><div class="line">class User(db.Models):</div><div class="line">    # 为User模型增加password_hash字段</div><div class="line">    password_hash = db.Column(db.String(128))</div><div class="line">    </div><div class="line">    # 当试图读取password的值时，返回错误</div><div class="line">    @property</div><div class="line">    def password(self):</div><div class="line">        raise AttributeError(&apos;password is not a readable attribute&apos;)</div><div class="line">    </div><div class="line">    # 计算密码散列值并赋值给passwo_hash    </div><div class="line">    @password.setter</div><div class="line">    def password(self, password):</div><div class="line">        self.password_hash = generate_password_hash(password)</div><div class="line">    </div><div class="line">    # 验证密码是否正确    </div><div class="line">    def verify_password(self, password):</div><div class="line">        return check_password_hash(self.password_hash, password)</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：User模型中的<code>password</code>属性为只写，不能读取。当给<code>password</code>赋值时，会调用<code>generate_password_hash()</code>函数计算散列值，并赋值给<code>password_hash</code>字段。可见下例。</p>
<h3 id="2-在shell中测试："><a href="#2-在shell中测试：" class="headerlink" title="2. 在shell中测试："></a>2. 在shell中测试：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(venv) $ python manage.py shell</div><div class="line">&gt;&gt;&gt; u = User()</div><div class="line">&gt;&gt;&gt; u.password = &apos;cat&apos;   # 根据密码`&apos;cat&apos;`计算散列值并赋值给password_hash字段</div><div class="line">&gt;&gt;&gt; u.password_hash</div><div class="line">&apos;pbkdf2:sha1:1000$duxMk......928bed&apos;</div><div class="line">&gt;&gt;&gt; u.verify_password(&apos;cat&apos;)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; u.verify_password(&apos;dog&apos;)</div><div class="line">False</div><div class="line">&gt;&gt;&gt; u2 = User()</div><div class="line">&gt;&gt;&gt; u2.password = &apos;cat&apos;</div><div class="line">&gt;&gt;&gt; u2.password_hash</div><div class="line">&apos;pbkdf2:sha1:1000$UjvnGe......75ee89&apos;</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：即使用户<code>u</code>和用户<code>u2</code>都使用了相同的密码，但他们的密码散列值是不一样的。</p>
<h3 id="3-tests-test-user-model-py支持密码散列测试："><a href="#3-tests-test-user-model-py支持密码散列测试：" class="headerlink" title="3. tests/test_user_model.py支持密码散列测试："></a>3. <code>tests/test_user_model.py</code>支持密码散列测试：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import unittest</div><div class="line">from app.models import User</div><div class="line"></div><div class="line">class UserModelTestCase(unittest.TestCase):</div><div class="line">    def test_password_setter(self):</div><div class="line">        u = User(password = &apos;cat&apos;)</div><div class="line">        self.assertTrue(u.password_hash is not None)</div><div class="line">        </div><div class="line">    </div><div class="line">    def test_no_password_getter(self):</div><div class="line">        u = User(password=&apos;cat&apos;)</div><div class="line">        with self.assertRaises(AttributeError):</div><div class="line">            u.password</div><div class="line">            </div><div class="line">    </div><div class="line">    def test_password_verification(self):</div><div class="line">        u = User(password=&apos;cat&apos;)</div><div class="line">        self.assertTrue(u.verify_password(&apos;cat&apos;))</div><div class="line">        self.assertFalse(u.verify_password(&apos;dog&apos;)</div><div class="line">        </div><div class="line">    </div><div class="line">    def test_password_salts_are_random(self):</div><div class="line">        u = User(password=&apos;cat&apos;)</div><div class="line">        u2 = User(password=&apos;dog&apos;)</div><div class="line">        self.assertTrue(u.passwors_hahs != u2.password_hash)</div></pre></td></tr></table></figure>
<h1 id="8-3-创建认证蓝本"><a href="#8-3-创建认证蓝本" class="headerlink" title="8.3 创建认证蓝本"></a>8.3 创建认证蓝本</h1><p>将与用户认证系统相关的路由定义在<code>auth</code>蓝本中。</p>
<h3 id="1-在app-auth-init-py中创建蓝本："><a href="#1-在app-auth-init-py中创建蓝本：" class="headerlink" title="1. 在app/auth/__init__.py中创建蓝本："></a>1. 在<code>app/auth/__init__.py</code>中创建蓝本：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from flask import Blueprint</div><div class="line"></div><div class="line">auth = Blueprint(&apos;auth&apos;, __name__)</div><div class="line"></div><div class="line">from app.auth import views</div></pre></td></tr></table></figure>
<h3 id="2-在app-auth-views-py中定义蓝本中的路由和视图函数："><a href="#2-在app-auth-views-py中定义蓝本中的路由和视图函数：" class="headerlink" title="2. 在app/auth/views.py中定义蓝本中的路由和视图函数："></a>2. 在<code>app/auth/views.py</code>中定义蓝本中的路由和视图函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from flask import render_template</div><div class="line">from app.auth import auth</div><div class="line"></div><div class="line">@auth.route(&apos;/login&apos;)</div><div class="line">def login():</div><div class="line">    return render_template(&apos;auth/login.html&apos;)</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：如果配置了多个模板文件夹，<code>render_tempalte()</code>函数首先会搜索程序配置的模板文件夹，然后再搜索蓝本配置的模板文件夹。</p>
<h3 id="3-在app-init-py中注册蓝本："><a href="#3-在app-init-py中注册蓝本：" class="headerlink" title="3. 在app/__init__.py中注册蓝本："></a>3. 在<code>app/__init__.py</code>中注册蓝本：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># ...</div><div class="line"></div><div class="line">def create_app(config_name):</div><div class="line">    # ...</div><div class="line">    from app.auth import auth as auth_blueprint</div><div class="line">    app.register_blueprint(auth_blueprint, url_prefix=&apos;/auth&apos;)</div><div class="line">    </div><div class="line">    return app</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：注册蓝本时，<code>url_prefix</code>参数是可选参数，使用这个参数后，蓝本中定义的理由都会加上指定的前缀。如该例中，<code>/login</code>路由会注册成<code>/auth/login</code>，完整的URL就变成<code>http://127.0.0.1:5000/auth/login</code>。</p>
<h1 id="8-4-使用Flask-Login认证用户"><a href="#8-4-使用Flask-Login认证用户" class="headerlink" title="8.4 使用Flask-Login认证用户"></a>8.4 使用Flask-Login认证用户</h1><p>用户登录程序后，他们的认证状态要被记录下来，这样浏览不同的页面时才能记住这个状态。</p>
<h2 id="8-4-1-准备用于登录的用户模型"><a href="#8-4-1-准备用于登录的用户模型" class="headerlink" title="8.4.1 准备用于登录的用户模型"></a>8.4.1 准备用于登录的用户模型</h2><p>要想使用Flask-Login扩展，程序的<code>User</code>模型必须实现以下几个方法：<br>表8-1 Flask-Login要求实现的用户方法<br>|方法     | 说明     |<br>|———|———-|<br>|is_authenticated | 如果用户已经登录，必须返回True，否则返回False|<br>|is_active | 如果允许用户登录，必须返回True，否则返回False。如果禁用账户，可以返回False|<br>|is_anonymous | 对普通用户必须返回False|<br>|get_id() | 必须返回用户的唯一标识符，使用Unicode编码字符串|</p>
<p>Flask-Login提供了一个<code>UserMixin</code>类，其中包含这些方法的默认实现，且能满足大多数需求。</p>
<h3 id="1-在app-models-py中修改User模型，支持用户登录："><a href="#1-在app-models-py中修改User模型，支持用户登录：" class="headerlink" title="1. 在app/models.py中修改User模型，支持用户登录："></a>1. 在<code>app/models.py</code>中修改User模型，支持用户登录：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">from flask_login import UserMixin</div><div class="line"># ...</div><div class="line"></div><div class="line"># 继承UserMixin类</div><div class="line">class User(UserMixin, db.models):</div><div class="line">    __tbalename__ = &apos;users&apos;</div><div class="line">    id = db.Column(db.Integer, primary_key=True)</div><div class="line">    email = db.Column(db.String(64), unique=True, index=True)</div><div class="line">    username = db.Column(db.String(64), unique=True, index=True)</div><div class="line">    password_hash = db.Column(db.String(128))</div><div class="line">    role_id = db.Column(db.Integer, db.ForeignKey(&apos;roles.id&apos;)</div></pre></td></tr></table></figure>
<h3 id="2-在app-init-py工厂函数中初始化Flask-Login："><a href="#2-在app-init-py工厂函数中初始化Flask-Login：" class="headerlink" title="2. 在app/__init__.py工厂函数中初始化Flask-Login："></a>2. 在<code>app/__init__.py</code>工厂函数中初始化Flask-Login：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from flask_login import LoginManager</div><div class="line"># ...</div><div class="line"></div><div class="line">login_manager = LoginManager()</div><div class="line">login_manager.session_protection = &apos;strong&apos;</div><div class="line">login_manager.login_view = &apos;auth.login&apos;</div><div class="line"></div><div class="line"></div><div class="line">def create_app(config_name):</div><div class="line">    # ...</div><div class="line">    </div><div class="line">    login_manager.init_app(app)</div><div class="line">    # ...</div><div class="line">    return app</div></pre></td></tr></table></figure>
<ul>
<li><code>LoginManager</code>对象的<code>session_protection</code>属性可以设为<code>None</code>、<code>&#39;basic&#39;</code>、<code>&#39;strong&#39;</code>，以提供不同安全等级防止用户会话遭篡改。设为<code>&#39;strong&#39;</code>时，Flask-Login会记录客户端IP地址和浏览器的用户代理信息，如果发现异动，就登出用户。</li>
<li><code>login_view</code>属性设置登录页面的端点。</li>
</ul>
<h3 id="3-Flask-Login要求程序实现一个回调函数，使用指定的标识符加载用户。在app-models-py中定义加载用户的回调函数："><a href="#3-Flask-Login要求程序实现一个回调函数，使用指定的标识符加载用户。在app-models-py中定义加载用户的回调函数：" class="headerlink" title="3. Flask-Login要求程序实现一个回调函数，使用指定的标识符加载用户。在app/models.py中定义加载用户的回调函数："></a>3. Flask-Login要求程序实现一个回调函数，使用指定的标识符加载用户。在<code>app/models.py</code>中定义加载用户的回调函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from app import login_manager</div><div class="line"># ...</div><div class="line"></div><div class="line">@login_manager.user_loader</div><div class="line">def load_user(user_id):</div><div class="line">    return User.query.get(int(user_id))</div></pre></td></tr></table></figure>
<p>加载用户的回调函数接收以Unicode字符串形式表示的用户标识符。如果能找到用户，则返回用户对象，否则返回None。</p>
<h2 id="8-4-2-保护路由"><a href="#8-4-2-保护路由" class="headerlink" title="8.4.2 保护路由"></a>8.4.2 保护路由</h2><h3 id="1-可以在路由中使用Flask-Login提供的login-required修饰器，使得路由只让认证用户访问（即访问被注册的路由时要先登录用户），如："><a href="#1-可以在路由中使用Flask-Login提供的login-required修饰器，使得路由只让认证用户访问（即访问被注册的路由时要先登录用户），如：" class="headerlink" title="1. 可以在路由中使用Flask-Login提供的login_required修饰器，使得路由只让认证用户访问（即访问被注册的路由时要先登录用户），如："></a>1. 可以在路由中使用Flask-Login提供的<code>login_required</code>修饰器，使得路由只让认证用户访问（即访问被注册的路由时要先登录用户），如：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">from flask_login import login_required</div><div class="line"></div><div class="line">@app.route(&apos;/secret&apos;)</div><div class="line">@login_required</div><div class="line">def secret():</div><div class="line">    return &apos;Only authenticated users are allowed!&apos;</div></pre></td></tr></table></figure>
<p>或者见8.6.2 发送确认邮件中的第三点。</p>
<h2 id="8-4-3-定义登录表单"><a href="#8-4-3-定义登录表单" class="headerlink" title="8.4.3 定义登录表单"></a>8.4.3 定义登录表单</h2><p>该表单包括一个用于输入电子邮件地址的文本字段、一个密码字段、一个“记住我”复选框、提交按钮。</p>
<h3 id="1-在app-auth-forms-py中定义登录表单："><a href="#1-在app-auth-forms-py中定义登录表单：" class="headerlink" title="1. 在app/auth/forms.py中定义登录表单："></a>1. 在<code>app/auth/forms.py</code>中定义登录表单：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from flask_wtf import Form</div><div class="line">from wtforms import StringField, PasswordField, BooleanField, SubmitField</div><div class="line">from wtforms.validators import Required, Length, Email</div><div class="line"></div><div class="line">class LoginForm(Form):</div><div class="line">    email = StringField(&apos;Email&apos;, validators=[Required(), Length(1,64), Email()])</div><div class="line">    password = PasswordField(&apos;Password&apos;, validators=[Required()])</div><div class="line">    remember_me = BooleanField(&apos;Keep me logged in&apos;)</div><div class="line">    submit = SubmitField(&apos;Log In&apos;)</div></pre></td></tr></table></figure>
<p>接下来在模板中渲染表单即可。</p>
<h3 id="2-在app-templates-base-html导航条中使用Jinja2条件语句，根据当前用户的登录状态显示“Sign-In”或“Sign-Out”："><a href="#2-在app-templates-base-html导航条中使用Jinja2条件语句，根据当前用户的登录状态显示“Sign-In”或“Sign-Out”：" class="headerlink" title="2. 在app/templates/base.html导航条中使用Jinja2条件语句，根据当前用户的登录状态显示“Sign In”或“Sign Out”："></a>2. 在<code>app/templates/base.html</code>导航条中使用Jinja2条件语句，根据当前用户的登录状态显示“Sign In”或“Sign Out”：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;</div><div class="line">    &#123;% if current_user.is_authenticated %&#125;</div><div class="line">    &lt;li&gt;</div><div class="line">        &lt;a href=&quot;&#123;&#123; url_for(&apos;auth.logout&apos;) &#125;&#125;&quot;&gt;Sign Out&lt;/a&gt;</div><div class="line">    &lt;/li&gt;</div><div class="line">    &#123;% else %&#125;</div><div class="line">    &lt;li&gt;</div><div class="line">        &lt;a href=&quot;&#123;&#123;url_for(&apos;auth.login&apos;) &#125;&#125;&quot;&gt;Sign In&lt;/a&gt;</div><div class="line">    &lt;/li&gt;</div><div class="line">    &#123;% endif %&#125;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p><strong>重点注意</strong>：变量<code>current_user</code>是由Flask-Login定义的，而且在视图函数和模板中自动可用。</p>
<h2 id="8-4-4-登录用户"><a href="#8-4-4-登录用户" class="headerlink" title="8.4.4 登录用户"></a>8.4.4 登录用户</h2><h3 id="1-在app-auth-views-py中定义登录路由："><a href="#1-在app-auth-views-py中定义登录路由：" class="headerlink" title="1. 在app/auth/views.py中定义登录路由："></a>1. 在<code>app/auth/views.py</code>中定义登录路由：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">from flask import render_template, redirect, request, url_for, flash</div><div class="line">from flask_login import login_user    # 导入登录用户函数（由Flask-Login提供）</div><div class="line">from app.auth import auth</div><div class="line">from app.models import User</div><div class="line">from app.auth.froms import LoginForm</div><div class="line"></div><div class="line">@auth.route(&apos;/login&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">def login():</div><div class="line">    form = LoginForm()</div><div class="line">    if form.validate_on_submit():</div><div class="line">        user = User.query.filter_by(email=form.email.data).first()</div><div class="line">        # 判断用户是否存在、密码是否正确</div><div class="line">        if user is not None and user.verify_password(form.password.data):</div><div class="line">            # login_user()函数由Flask-Login提供</div><div class="line">            # 若用户存在以及密码正确，则调用login_user()函数，</div><div class="line">            # 在用户会话中把用户标记为已登录状态</div><div class="line">            login_user(user, form.remember_me.data)</div><div class="line">            # 返回原先的地址或者主页index</div><div class="line">            return redirect(request.args.get(&apos;next&apos;) or url_for(&apos;main.index&apos;)</div><div class="line">        flash(&apos;Invalid usernane or password&apos;)</div><div class="line">    return render_template(&apos;auth/login.html&apos;, form=form)</div></pre></td></tr></table></figure>
<p>重定向的URL有两种可能：（1）是用户访问未授权的URL时会显示登录表单，Flask-Login会把原本的地址保存在<code>request.args</code>字典的<code>next</code>键中，可用<code>get()</code>方法获取。（2）是如果<code>next</code>的值为空，则重定向到主页。</p>
<h3 id="2-在app-templates-auth-login-htm中渲染登录表单："><a href="#2-在app-templates-auth-login-htm中渲染登录表单：" class="headerlink" title="2. 在app/templates/auth/login.htm中渲染登录表单："></a>2. 在<code>app/templates/auth/login.htm</code>中渲染登录表单：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;% extends &quot;base.html&quot; %&#125;</div><div class="line">&#123;% import &quot;bootstrap/wtf.html&quot; as wtf %&#125;</div><div class="line">&#123;% block title %&#125;Flasky - Login&#123;% endblock %&#125;</div><div class="line"></div><div class="line">&#123;% block page_content %&#125;</div><div class="line">&lt;div class=&quot;page_header&quot;&gt;</div><div class="line">    &lt;h1&gt;Login&lt;/h1&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div class=&quot;col-md-4&quot;&gt;</div><div class="line">    &#123;% wtf.quick_form(form) &#125;&#125;</div><div class="line">&lt;/div&gt;</div><div class="line">&#123;% endblock %&#125;</div></pre></td></tr></table></figure>
<h2 id="8-4-5-登出用户"><a href="#8-4-5-登出用户" class="headerlink" title="8.4.5 登出用户"></a>8.4.5 登出用户</h2><h3 id="1-在app-auth-views-py中定义登出路由："><a href="#1-在app-auth-views-py中定义登出路由：" class="headerlink" title="1. 在app/auth/views.py中定义登出路由："></a>1. 在<code>app/auth/views.py</code>中定义登出路由：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from flask_login import logout_user, login_required</div><div class="line"># ...</div><div class="line"></div><div class="line">@auth.route(&apos;/logout&apos;)</div><div class="line">@login_required</div><div class="line">def logout():</div><div class="line">    logout_user()</div><div class="line">    flash(&apos;You have been logged out.&apos;)</div><div class="line">    return redirect(url_for(&apos;main.index&apos;)</div></pre></td></tr></table></figure>
<p>Flask-Login提供的<code>logout_user()</code>函数：删除并重设用户会话。</p>
<h2 id="8-4-6-测试登录（在shell中测试）"><a href="#8-4-6-测试登录（在shell中测试）" class="headerlink" title="8.4.6 测试登录（在shell中测试）"></a>8.4.6 测试登录（在shell中测试）</h2><h3 id="1-在app-templates-index-html中为已登录的用户显示一个欢迎消息："><a href="#1-在app-templates-index-html中为已登录的用户显示一个欢迎消息：" class="headerlink" title="1. 在app/templates/index.html中为已登录的用户显示一个欢迎消息："></a>1. 在<code>app/templates/index.html</code>中为已登录的用户显示一个欢迎消息：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Hello,</div><div class="line">&#123;% if current_user.is_authenticates %&#125;</div><div class="line">    &#123;&#123; current_user.username &#125;&#125;</div><div class="line">&#123;% else %&#125;</div><div class="line">    Stranger</div><div class="line">&#123;% endif %&#125;!</div></pre></td></tr></table></figure>
<h3 id="2-在shell中注册新用户（因为未创建用户注册功能，所以可在shell创建新用户）："><a href="#2-在shell中注册新用户（因为未创建用户注册功能，所以可在shell创建新用户）：" class="headerlink" title="2. 在shell中注册新用户（因为未创建用户注册功能，所以可在shell创建新用户）："></a>2. 在shell中注册新用户（因为未创建用户注册功能，所以可在shell创建新用户）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(venv)$ python manage.py shell</div><div class="line">&gt;&gt;&gt; u = User(email=&apos;123456@qq.com&apos;, username=&apos;john&apos;, password=&apos;cat&apos;)</div><div class="line">&gt;&gt;&gt; db.session.add(u)</div><div class="line">&gt;&gt;&gt; db.session.commit()</div></pre></td></tr></table></figure>
<h3 id="3-打开登录页面进行登录"><a href="#3-打开登录页面进行登录" class="headerlink" title="3. 打开登录页面进行登录"></a>3. 打开登录页面进行登录</h3><p>登录后即可显示欢迎消息。</p>
<h1 id="8-5-注册新用户"><a href="#8-5-注册新用户" class="headerlink" title="8.5 注册新用户"></a>8.5 注册新用户</h1><h2 id="8-5-1-添加用户注册表单"><a href="#8-5-1-添加用户注册表单" class="headerlink" title="8.5.1 添加用户注册表单"></a>8.5.1 添加用户注册表单</h2><p>注册页面使用的表单要求用户输入电子邮件地址、用户名和密码。</p>
<h3 id="1-在app-auth-forms-py中定义用户注册表单："><a href="#1-在app-auth-forms-py中定义用户注册表单：" class="headerlink" title="1. 在app/auth/forms.py中定义用户注册表单："></a>1. 在<code>app/auth/forms.py</code>中定义用户注册表单：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">from falsk_wtf import Form</div><div class="line">from wtforms import StringField, PasswordField, BooleanField, SubmitField</div><div class="line">from wtforms.validators import Required, Length, Email, Regexp, EqulTo</div><div class="line">from wtforms import ValidationError</div><div class="line">from app.models import User</div><div class="line"></div><div class="line">class RegistrationForm(Form):</div><div class="line">    email = StringField(&apos;Email&apos;, validators=[Required(), Length(1,64), Email()])</div><div class="line">    username = StringField(&apos;Username&apos;, validators=[REquired(), Length(1,64),</div><div class="line">              Regexp(&apos;^[A-Za-z][A-Za-z0-9_.]*$&apos;, 0, &apos;Usernames must have only letters, numbers, dots or underscores&apos;)])</div><div class="line">    password = PasswordField(&apos;Password&apos;, validators=[Required(), EqualTo(&apos;password2&apos;, message=&apos;Password must match&apos;)])</div><div class="line">    password2 = PasswordField(&apos;Confirm password&apos;, validators=[Required()])</div><div class="line">    submit = SubmitField(&apos;Register&apos;)</div><div class="line">    </div><div class="line">    </div><div class="line">    def validate_email(self, field):</div><div class="line">        if User.query.filter_by(email=field.data).first():</div><div class="line">            raise ValidationError(&apos;Email already registered&apos;)</div><div class="line">            </div><div class="line">            </div><div class="line">    def validate_username(self, field):</div><div class="line">        if User.query.filter_by(usernanme=field.data).first():</div><div class="line">            raise ValidationError(&apos;Username already in use&apos;)</div></pre></td></tr></table></figure>
<ul>
<li><code>Regexp()</code>验证函数确<code>username</code>字段只包含字母、数字、下划线、点号。该验证函数正则后面的两个参数分别是正则的旗标和验证失败时显示的错误信息。</li>
<li><code>EqualTo()</code>验证函数确保两个密码字段一致。这个验证函数要附属到两个密码字段中的一个，另一个则作为参数传入。</li>
<li>该表单还自定义了两个验证函数，以方法的形式实现。如果表单类中定义了以<code>validate_</code>开头且后面跟着<strong>字段名</strong>的方法，这个方法就<strong>和常规的验证函数一起调用</strong>。</li>
</ul>
<h3 id="2-渲染template-auth-register-html表单："><a href="#2-渲染template-auth-register-html表单：" class="headerlink" title="2. 渲染template/auth/register.html表单："></a>2. 渲染<code>template/auth/register.html</code>表单：</h3><p>和之前渲染表单一样，使用<code>wtf.quick_form(form)</code>渲染。</p>
<h3 id="3-在template-auth-login-html中添加注册页面链接："><a href="#3-在template-auth-login-html中添加注册页面链接：" class="headerlink" title="3. 在template/auth/login.html中添加注册页面链接："></a>3. 在<code>template/auth/login.html</code>中添加注册页面链接：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># ...</div><div class="line">&lt;p&gt;</div><div class="line">    New User?</div><div class="line">    &lt;a href=&quot;&#123;&#123; url_for(&apos;auth.register&apos;) &#125;&#125;&quot;&gt;</div><div class="line">        Click here to register</div><div class="line">    &lt;/a&gt;</div><div class="line">&lt;/p&gt;</div></pre></td></tr></table></figure>
<h2 id="8-5-2-注册新用户（定义注册新用户的路由）"><a href="#8-5-2-注册新用户（定义注册新用户的路由）" class="headerlink" title="8.5.2 注册新用户（定义注册新用户的路由）"></a>8.5.2 注册新用户（定义注册新用户的路由）</h2><h3 id="1-在app-auth-views-py中定义用户注册路由："><a href="#1-在app-auth-views-py中定义用户注册路由：" class="headerlink" title="1. 在app/auth/views.py中定义用户注册路由："></a>1. 在<code>app/auth/views.py</code>中定义用户注册路由：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># ...</div><div class="line"></div><div class="line">@auth.route(&apos;/register&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">def register():</div><div class="line">    form = RegistationForm()</div><div class="line">    if form.validate_on_submit():</div><div class="line">        user = User(email=form.email.data,</div><div class="line">                    username=form.username.data,</div><div class="line">                    password=form.password.data)</div><div class="line">        db.session.add(user)</div><div class="line">        flash(&apos;You can login now.&apos;)</div><div class="line">        return redirect(url_for(&apos;auth.login&apos;))</div><div class="line">    return render_template(&apos;auth/register.html&apos;, form=form)</div></pre></td></tr></table></figure>
<h1 id="8-6-确认账户（验证邮箱）"><a href="#8-6-确认账户（验证邮箱）" class="headerlink" title="8.6 确认账户（验证邮箱）"></a>8.6 确认账户（验证邮箱）</h1><p>用户验证邮箱之前，新账户先被标记成待确认状态。账户确认过程，一般会要求用户点击一个包含<strong>确认令牌</strong>的特殊URL链接。</p>
<h2 id="8-6-1-使用itsdangerous生成确认令牌"><a href="#8-6-1-使用itsdangerous生成确认令牌" class="headerlink" title="8.6.1 使用itsdangerous生成确认令牌"></a>8.6.1 使用itsdangerous生成确认令牌</h2><p><strong>思路</strong>：确认邮件最简单的URL链接是<code>http://www.example.com/auth/confirm/&lt;id&gt;</code>这种形式，其中<code>id</code>是数据库分配给用户的数字id。用户点击链接后，处理这个路由的视图函数将<code>id</code>作为参数进行确认，然后将用户账户状态更新为已确认。</p>
<p><strong>存在问题</strong>：不安全。只要用户能判断确认链接的格式，就可以随便指定URL中的id，从而验证确认随意账户。</p>
<p><strong>解决方法</strong>：把URL中的id换成<strong>将相同信息安全加密后得到的令牌</strong>。</p>
<p><strong>解决工具</strong>：使用<code>itsdangerous</code>包中的<code>TiemdJSONWebSignatureSerializer</code>类提供的<code>dumps()</code>方法和<code>load()</code>方法。</p>
<h3 id="1-在app-models-py中的User模型中添加验证用户功能："><a href="#1-在app-models-py中的User模型中添加验证用户功能：" class="headerlink" title="1. 在app/models.py中的User模型中添加验证用户功能："></a>1. 在<code>app/models.py</code>中的User模型中添加验证用户功能：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">from itsdangerous import TimedJSONWebSignatureSerializer as Serializer</div><div class="line">from falsk import current_app</div><div class="line">from app import db</div><div class="line"></div><div class="line">class User(db.models):</div><div class="line">    # ...</div><div class="line">    </div><div class="line">    confirmed = db.Column(db.Boolean, default=False)</div><div class="line">    </div><div class="line">    </div><div class="line">    # 使用dumps()生成加密令牌</div><div class="line">    def generate_confirmation_token(self, expiration=3600):</div><div class="line">        s = Serializer(current_app.config[&apos;SECRET_KEY&apos;], expires_in=expiration)</div><div class="line">        return s.dumps(&#123;&apos;confirm&apos;: self.id&#125;)</div><div class="line">        </div><div class="line">    </div><div class="line">    # 解码加密令牌并验证原始数据是否与存储中current_app中已登录用户数据一致</div><div class="line">    def confirm(self, token)</div><div class="line">        s = Serializer(current_app.config[&apos;SECRET_KEY&apos;])</div><div class="line">        try:</div><div class="line">            data = s.loads(token)    # 解码令牌返回原始数据</div><div class="line">        except:</div><div class="line">            return False</div><div class="line">        # 判断原始数据是否跟已登录用户id一致，防止恶意验证</div><div class="line">        if data.get(&apos;confirm&apos;) != self.id:</div><div class="line">            return False</div><div class="line">        self.confirmed = True</div><div class="line">        # 更新confirmed字段</div><div class="line">        db.session.add(self)</div><div class="line">        return True</div></pre></td></tr></table></figure>
<ul>
<li><code>TimedJSONWebSignatureSerializer</code>类生成具有国旗时间的JSON Web签名。这个类的构造函数可接受两个参数：<strong>密匙</strong>（可用Flask中的SECRET_KEY密匙）和<code>expires_in</code>（设置过期时间，单位秒）。</li>
<li><code>dumps()</code>方法为指定的数据生成一个加密签名，然后再对数据和签名进行序列化，生成<strong>令牌字符串</strong>。</li>
<li><code>loads()</code>方法的唯一参数是<strong>令牌字符串</strong>。这个方法会检验签名和过期时间，如果通过则返回原始数据，否则抛出异常。</li>
</ul>
<h2 id="8-6-2-发送确认邮件"><a href="#8-6-2-发送确认邮件" class="headerlink" title="8.6.2 发送确认邮件"></a>8.6.2 发送确认邮件</h2><h3 id="1-在app-auth-views-py中使register路由支持邮件发送："><a href="#1-在app-auth-views-py中使register路由支持邮件发送：" class="headerlink" title="1. 在app/auth/views.py中使register路由支持邮件发送："></a>1. 在<code>app/auth/views.py</code>中使<code>register</code>路由支持邮件发送：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">from app.email import send_email</div><div class="line"># ...</div><div class="line"></div><div class="line">@auth.route(&apos;/register&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])</div><div class="line">def register():</div><div class="line">    form = RegistrationForm()</div><div class="line">    if form.validate_on_submit():</div><div class="line">        # ...</div><div class="line">        db.session.add(user)</div><div class="line">        # 在请求结束前先提交User实例，因为提交后才能得到新用户的id，</div><div class="line">        # 从而向generate_confirmation_token方法传参得到token</div><div class="line">        db.session.commit()</div><div class="line">        token = user.generate_confirmation_token()</div><div class="line">        send_mail(user.email, &apos;Confirm Your Account&apos;,</div><div class="line">                  &apos;auth/email/confirm&apos;, user=user, token=token)</div><div class="line">        flash(&apos;A confirmation email has been sent to you by email.&apos;)</div><div class="line">        return redirect(url_for(&apos;main.index&apos;))</div><div class="line">    return render_template(&apos;auth/register.html&apos;, form=form)</div></pre></td></tr></table></figure>
<p><strong>重点注意</strong>：即便通过设置<code>SQLALCHEMY_COMMIT_ON_TEARDOWN=True</code>，程序可以在请求末尾自动提交数据库变化，但是这里也要调用<code>db.session.commit()</code>提交变化。因为提交数据库后才能得到新用户的id值，从而将id值传参给<code>generate_confirmation_token()</code>方法生成令牌。</p>
<h3 id="2-在app-template-auth-email-confirm-txt中编写确认邮件文本："><a href="#2-在app-template-auth-email-confirm-txt中编写确认邮件文本：" class="headerlink" title="2. 在app/template/auth/email/confirm.txt中编写确认邮件文本："></a>2. 在<code>app/template/auth/email/confirm.txt</code>中编写确认邮件文本：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Welcome to Flasky!</div><div class="line"></div><div class="line">To confirm your account please click on the following link:</div><div class="line"></div><div class="line">&#123;&#123; url_for(&apos;auth/confirm&apos;, token=token, _external=True) &#125;&#125;</div><div class="line"></div><div class="line">Sincerely,</div><div class="line"></div><div class="line">The Flasky Team</div><div class="line"></div><div class="line">Note: replies to this email address ate not monitored.</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：默认情况下，<code>url_for()</code>生成的是相对URL，如<code>url_for(&#39;auth.confirm&#39;, token=&#39;abc&#39;)</code>，返回的是<code>/auth/confirm/abc&#39;</code>，显然，这不是能够在电子邮件中发送正确的URL。所以需要使用<code>_external=True</code>参数，从而生成完整的URL。</p>
<h3 id="3-在app-auth-views-py中定义确认用户的路由："><a href="#3-在app-auth-views-py中定义确认用户的路由：" class="headerlink" title="3. 在app/auth/views.py中定义确认用户的路由："></a>3. 在<code>app/auth/views.py</code>中定义确认用户的路由：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">from flask_login import current_user</div><div class="line"># ...</div><div class="line"></div><div class="line"># 路由中的token将会被作为参数传入视图函数中</div><div class="line">@auth.route(&apos;/confirm/&lt;token&gt;&apos;)</div><div class="line">@login_required</div><div class="line">def confirm(token):</div><div class="line">    # 判断user中是否已经确认过</div><div class="line">    if current_user.confirmed:</div><div class="line">        return redirect(url_for(&apos;main.index&apos;))</div><div class="line">    # 判断调用confirm()方法返回的是True还是False，从而验证用户</div><div class="line">    if current_user.confirm(token):</div><div class="line">        # 提交数据库变化（很重要）</div><div class="line">        db.session.commit()</div><div class="line">        flash(&apos;You have confirm your account. Thanks!&apos;)</div><div class="line">    else:</div><div class="line">        flash(&apos;The confirmation link is invalid or has expired.&apos;)</div><div class="line">    return redirect(url_for(&apos;main.index&apos;)</div></pre></td></tr></table></figure>
<p>Flask-Login提供的<code>login_required</code>修饰器会保护这个路由：用户点击确认邮件中的链接后，<strong>要先登录</strong>，然后才能执行这个视图函数。</p>
<h3 id="4-在app-auth-views-py中在before-app-request处理程序中过滤未确认的账户："><a href="#4-在app-auth-views-py中在before-app-request处理程序中过滤未确认的账户：" class="headerlink" title="4. 在app/auth/views.py中在before_app_request处理程序中过滤未确认的账户："></a>4. 在<code>app/auth/views.py</code>中在<code>before_app_request</code>处理程序中过滤未确认的账户：</h3><p>每个程序都可以决定用户在确认账户之前可以有哪些操作，如允许未确认的用户登录，并显示一些内容，但更进一步的看更多内容需要先确认账户。这一步可以使用Flask提供的<code>before_request</code>钩子完成。对于蓝本来说，<code>before_request</code>钩子只能应用到属于蓝本的请求，若想在蓝本中使用针对程序全局请求的钩子，需要使用<code>before_app_request</code>修饰器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># ...</div><div class="line"></div><div class="line">@auth.before_app_request</div><div class="line">def before_request():</div><div class="line">    if current_user.is_authenticated \    # 判断用户是否已登录</div><div class="line">            and not current_user.confirmed \   # 判断用户账户是否已验证</div><div class="line">            and request.endpoint[:5] != &apos;auth.&apos; \   # 判断请求的端点是否不再认证蓝本中</div><div class="line">            and request.endpoint != &apos;static&apos;:</div><div class="line">        return redirect(url_for(&apos;auth.unconfirmed&apos;))</div><div class="line">        </div><div class="line"></div><div class="line">@auth.route(&apos;/unconfirmed&apos;)</div><div class="line">def unconfirmed():</div><div class="line">    if current_user.is_anonymous or current_user.confirmed:</div><div class="line">        return redirect(url_for(&apos;main.index&apos;))</div><div class="line">    return render_template(&apos;auth/unconfirmed.htm&apos;)</div></pre></td></tr></table></figure>
<p>当满足一下三个条件时，<code>before_app_request</code>处理程序会拦截请求，将请求重定向到<code>/auth/unconfirmed</code>路由，显示一个验证账户相关信息的页面：<br>（1）用户已登录<br>（2）用户的账户还未验证<br>（3）请求的端点（使用<code>request.endpoint</code>获取）不在认证蓝本（<code>/auth</code>)中。</p>
<h3 id="5-在app-auth-views-py中支持重新发送验证邮件："><a href="#5-在app-auth-views-py中支持重新发送验证邮件：" class="headerlink" title="5. 在app/auth/views.py中支持重新发送验证邮件："></a>5. 在<code>app/auth/views.py</code>中支持重新发送验证邮件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># ...</div><div class="line"></div><div class="line">@auth.route(&apos;/confirm&apos;)</div><div class="line">@login_required</div><div class="line">def resend_confirmation():</div><div class="line">    token = current_user.generate_confirmation_token()</div><div class="line">    send_email(current_user.email, &apos;Confirm Your Account&apos;,</div><div class="line">              &apos;auth/email/confirm&apos;, user=current_user, token=token)</div><div class="line">    flash(&apos;A new confirmation email has been sent to you by email.&apos;)</div><div class="line">    return redirect(url_for(&apos;main.index&apos;))</div></pre></td></tr></table></figure>
<p>这个路由也用<code>login_required</code>保护（要先登录才能执行视图函数），确保程序知道再次发送验证邮件的是哪个用户。</p>
<p><strong>重点注意</strong>：凡是修改了数据库模型，为了使新模型能够应用到新程序，要使用Flask-Migrate进行数据库迁移，从而实现更新数据库的效果。</p>
<h1 id="8-7-管理账户"><a href="#8-7-管理账户" class="headerlink" title="8.7 管理账户"></a>8.7 管理账户</h1><p>修改密码、重设密码、修改电子邮件地址，具体代码实现可查看git仓库。</p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-12-30T11:03:27.000Z" itemprop="dateUpdated">2017-12-30 19:03:27</time>
</span><br>


        
        文章链接<a href="/2017/12/30/把《Flask Web开发》读薄系列之第八章 用户认证/" target="_blank" rel="external">https://richardrw.github.io/2017/12/30/把《Flask Web开发》读薄系列之第八章 用户认证/</a>
        
    </div>
    <footer>
        <a href="https://richardrw.github.io">
            <img src="/img/author.jpg" alt="Richard">
            Richard
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flask/">Flask</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://richardrw.github.io/2017/12/30/把《Flask Web开发》读薄系列之第八章 用户认证/&title=《把《Flask Web开发》读薄系列之第八章 用户认证》 — Richard‘s Blog&pic=https://richardrw.github.io/img/author.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://richardrw.github.io/2017/12/30/把《Flask Web开发》读薄系列之第八章 用户认证/&title=《把《Flask Web开发》读薄系列之第八章 用户认证》 — Richard‘s Blog&source=the day with Python 爱生活，爱体验，工作认真，生活随意" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://richardrw.github.io/2017/12/30/把《Flask Web开发》读薄系列之第八章 用户认证/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《把《Flask Web开发》读薄系列之第八章 用户认证》 — Richard‘s Blog&url=https://richardrw.github.io/2017/12/30/把《Flask Web开发》读薄系列之第八章 用户认证/&via=https://richardrw.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://richardrw.github.io/2017/12/30/把《Flask Web开发》读薄系列之第八章 用户认证/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/12/30/把《Flask Web开发》读薄系列之第九章 用户角色/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">把《Flask Web开发》读薄系列之第九章 用户角色</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/11/25/把《Flask Web开发》读薄系列之第七章 大型程序的结构/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">把《Flask Web开发》读薄系列之第七章 大型程序的结构</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'true';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>













</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        支持作者写出更好的文章
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/zhifubao.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Richard &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://richardrw.github.io/2017/12/30/把《Flask Web开发》读薄系列之第八章 用户认证/&title=《把《Flask Web开发》读薄系列之第八章 用户认证》 — Richard‘s Blog&pic=https://richardrw.github.io/img/author.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://richardrw.github.io/2017/12/30/把《Flask Web开发》读薄系列之第八章 用户认证/&title=《把《Flask Web开发》读薄系列之第八章 用户认证》 — Richard‘s Blog&source=the day with Python 爱生活，爱体验，工作认真，生活随意" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://richardrw.github.io/2017/12/30/把《Flask Web开发》读薄系列之第八章 用户认证/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《把《Flask Web开发》读薄系列之第八章 用户认证》 — Richard‘s Blog&url=https://richardrw.github.io/2017/12/30/把《Flask Web开发》读薄系列之第八章 用户认证/&via=https://richardrw.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://richardrw.github.io/2017/12/30/把《Flask Web开发》读薄系列之第八章 用户认证/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADOElEQVR42u3ay24bMRAEQP3/TztATgEU2d2cXUOkSidD1mNrDaQzPXw84sfX30f787/PPD///JrkXa8+53HHAxsbG3sT9te3j5yUwJ4/LXkm+cbcgo2NjX0qO/+4tWhZi73vwyl/PTY2NjZ2PlSsxWE+L+Q3FxsbGxs7/5o2qJJQTIaQ/CZiY2NjfwI7L+7by0ouKKqB4tHl4i4NGxsb++3Z9y16f//nt9hvY2NjY/8ie60SSmIpeeXaEZx5vYWNjY19Ejs/QNPWTG3Rn4wWebhG8YaNjY19ELsNhvsCaa2uSq4WGxsb+1R2PmDkI0ryfPu9k8UANjY2NvZkmZr8djK05PH5Q52EjY2NvTm7PZqThMpV9dPkGNDLZ7CxsbGPY+cRshYw+W2ajDd5AGNjY2Ofx26joh0JkqKqXetObhM2Njb2qezJqmBe368tBtpruGBTgY2Njf1m7LURYhJyyfiRR91kcMLGxsY+id0ufedjw1pd1dZY0SEebGxs7M3ZeSmTL2jX6vt8zGgj6j/fhY2NjX0Quz06065U1yKqXTwvvh4bGxv7CHZyoe1HtyNEvr69arWMjY2NfTZ7rcRpf7tWIbXR+/I12NjY2B/DvupG5MV9HmD5ldcBho2Njb0h+6pFbx5I7cGdvPqPRilsbGzs49htlTN/V3vT80Eluq3Y2NjYx7Fb3lrkrA0tk7X0y3dhY2NjH8eeVPNtJZREYFsb1Z+GjY2NfSi7rYfy5Wsbe/nRn8X1MzY2Nvah7Pw//YtHHuMDnfex+6kFGxsbeyf2WlnTjiiP+NEe3LlgFMHGxsbekJ205fNDlpPAa4eifF2BjY2NfQY7+ec+v6w8hJKFbhJa+Z/hh1IJGxsbe3P2pPpfGy3aeJvcpqi7wsbGxt6cnT/yhW67YMjjql0eYGNjY5/NbuMnGTba6qddD7dF0iiAsbGxsTdh5+vSPGDyoaINwmKVO99IY2NjY2/Fnl90smZoq/x5qRQ1atjY2Ngfw56MBHccxFmLUmxsbGzsdlnbBsx8MRANJ9jY2NjHsZNSKQdPjuC0jNvXA9jY2Nhvz2679Lw8SkqldmmRL54nhRQ2Njb2Juw/C+Xzh+0MQl4AAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '前往理查德生活记录';
            clearTimeout(titleTime);
        } else {
            document.title = '理查德生活记录';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
